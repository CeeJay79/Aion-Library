<?php
abstract class Zend_Db_Adapter_Abstract { protected $_config = array(); protected $_fetchMode = Zend_Db::FETCH_ASSOC; protected $_profiler; protected $_defaultStmtClass = 'Zend_Db_Statement'; protected $_defaultProfilerClass = 'Zend_Db_Profiler'; protected $_connection = null; protected $_caseFolding = Zend_Db::CASE_NATURAL; protected $_autoQuoteIdentifiers = true; protected $_numericDataTypes = array( Zend_Db::INT_TYPE => Zend_Db::INT_TYPE, Zend_Db::BIGINT_TYPE => Zend_Db::BIGINT_TYPE, Zend_Db::FLOAT_TYPE => Zend_Db::FLOAT_TYPE ); protected $_allowSerialization = true; protected $_autoReconnectOnUnserialize = false; public function __construct($config) { if (!is_array($config)) { if ($config instanceof Zend_Config) { $config = $config->toArray(); } else { throw new Zend_Db_Adapter_Exception('Adapter parameters must be in an array or a Zend_Config object'); } } $this->_checkRequiredOptions($config); $options = array( Zend_Db::CASE_FOLDING => $this->_caseFolding, Zend_Db::AUTO_QUOTE_IDENTIFIERS => $this->_autoQuoteIdentifiers, Zend_Db::FETCH_MODE => $this->_fetchMode, ); $driverOptions = array(); if (array_key_exists('options', $config)) { foreach ((array) $config['options'] as $key => $value) { $options[$key] = $value; } } if (array_key_exists('driver_options', $config)) { if (!empty($config['driver_options'])) { foreach ((array) $config['driver_options'] as $key => $value) { $driverOptions[$key] = $value; } } } if (!isset($config['charset'])) { $config['charset'] = null; } if (!isset($config['persistent'])) { $config['persistent'] = false; } $this->_config = array_merge($this->_config, $config); $this->_config['options'] = $options; $this->_config['driver_options'] = $driverOptions; if (array_key_exists(Zend_Db::CASE_FOLDING, $options)) { $case = (int) $options[Zend_Db::CASE_FOLDING]; switch ($case) { case Zend_Db::CASE_LOWER: case Zend_Db::CASE_UPPER: case Zend_Db::CASE_NATURAL: $this->_caseFolding = $case; break; default: throw new Zend_Db_Adapter_Exception('Case must be one of the following constants: ' . 'Zend_Db::CASE_NATURAL, Zend_Db::CASE_LOWER, Zend_Db::CASE_UPPER'); } } if (array_key_exists(Zend_Db::FETCH_MODE, $options)) { if (is_string($options[Zend_Db::FETCH_MODE])) { $constant = 'Zend_Db::FETCH_' . strtoupper($options[Zend_Db::FETCH_MODE]); if(defined($constant)) { $options[Zend_Db::FETCH_MODE] = constant($constant); } } $this->setFetchMode((int) $options[Zend_Db::FETCH_MODE]); } if (array_key_exists(Zend_Db::AUTO_QUOTE_IDENTIFIERS, $options)) { $this->_autoQuoteIdentifiers = (bool) $options[Zend_Db::AUTO_QUOTE_IDENTIFIERS]; } if (array_key_exists(Zend_Db::ALLOW_SERIALIZATION, $options)) { $this->_allowSerialization = (bool) $options[Zend_Db::ALLOW_SERIALIZATION]; } if (array_key_exists(Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE, $options)) { $this->_autoReconnectOnUnserialize = (bool) $options[Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE]; } $profiler = false; if (array_key_exists(Zend_Db::PROFILER, $this->_config)) { $profiler = $this->_config[Zend_Db::PROFILER]; unset($this->_config[Zend_Db::PROFILER]); } $this->setProfiler($profiler); } protected function _checkRequiredOptions(array $config) { if (! array_key_exists('dbname', $config)) { throw new Zend_Db_Adapter_Exception("Configuration array must have a key for 'dbname' that names the database instance"); } if (! array_key_exists('password', $config)) { throw new Zend_Db_Adapter_Exception("Configuration array must have a key for 'password' for login credentials"); } if (! array_key_exists('username', $config)) { throw new Zend_Db_Adapter_Exception("Configuration array must have a key for 'username' for login credentials"); } } public function getConnection() { $this->_connect(); return $this->_connection; } public function getConfig() { return $this->_config; } public function setProfiler($profiler) { $enabled = null; $profilerClass = $this->_defaultProfilerClass; $profilerInstance = null; if ($profilerIsObject = is_object($profiler)) { if ($profiler instanceof Zend_Db_Profiler) { $profilerInstance = $profiler; } else if ($profiler instanceof Zend_Config) { $profiler = $profiler->toArray(); } else { throw new Zend_Db_Profiler_Exception('Profiler argument must be an instance of either Zend_Db_Profiler' . ' or Zend_Config when provided as an object'); } } if (is_array($profiler)) { if (isset($profiler['enabled'])) { $enabled = (bool) $profiler['enabled']; } if (isset($profiler['class'])) { $profilerClass = $profiler['class']; } if (isset($profiler['instance'])) { $profilerInstance = $profiler['instance']; } } else if (!$profilerIsObject) { $enabled = (bool) $profiler; } if ($profilerInstance === null) { if (!class_exists($profilerClass)) { Zend_Loader::loadClass($profilerClass); } $profilerInstance = new $profilerClass(); } if (!$profilerInstance instanceof Zend_Db_Profiler) { throw new Zend_Db_Profiler_Exception('Class ' . get_class($profilerInstance) . ' does not extend ' . 'Zend_Db_Profiler'); } if (null !== $enabled) { $profilerInstance->setEnabled($enabled); } $this->_profiler = $profilerInstance; return $this; } public function getProfiler() { return $this->_profiler; } public function getStatementClass() { return $this->_defaultStmtClass; } public function setStatementClass($class) { $this->_defaultStmtClass = $class; return $this; } public function query($sql, $bind = array()) { $this->_connect(); if ($sql instanceof Zend_Db_Select) { if (empty($bind)) { $bind = $sql->getBind(); } $sql = $sql->assemble(); } if (!is_array($bind)) { $bind = array($bind); } $stmt = $this->prepare($sql); $stmt->execute($bind); $stmt->setFetchMode($this->_fetchMode); return $stmt; } public function beginTransaction() { $this->_connect(); $q = $this->_profiler->queryStart('begin', Zend_Db_Profiler::TRANSACTION); $this->_beginTransaction(); $this->_profiler->queryEnd($q); return $this; } public function commit() { $this->_connect(); $q = $this->_profiler->queryStart('commit', Zend_Db_Profiler::TRANSACTION); $this->_commit(); $this->_profiler->queryEnd($q); return $this; } public function rollBack() { $this->_connect(); $q = $this->_profiler->queryStart('rollback', Zend_Db_Profiler::TRANSACTION); $this->_rollBack(); $this->_profiler->queryEnd($q); return $this; } public function insert($table, array $bind) { $cols = array(); $vals = array(); $i = 0; foreach ($bind as $col => $val) { $cols[] = $this->quoteIdentifier($col, true); if ($val instanceof Zend_Db_Expr) { $vals[] = $val->__toString(); unset($bind[$col]); } else { if ($this->supportsParameters('positional')) { $vals[] = '?'; } else { if ($this->supportsParameters('named')) { unset($bind[$col]); $bind[':col'.$i] = $val; $vals[] = ':col'.$i; $i++; } else { throw new Zend_Db_Adapter_Exception(get_class($this) ." doesn't support positional or named binding"); } } } } $sql = "INSERT INTO " . $this->quoteIdentifier($table, true) . ' (' . implode(', ', $cols) . ') ' . 'VALUES (' . implode(', ', $vals) . ')'; if ($this->supportsParameters('positional')) { $bind = array_values($bind); } $stmt = $this->query($sql, $bind); $result = $stmt->rowCount(); return $result; } public function update($table, array $bind, $where = '') { $set = array(); $i = 0; foreach ($bind as $col => $val) { if ($val instanceof Zend_Db_Expr) { $val = $val->__toString(); unset($bind[$col]); } else { if ($this->supportsParameters('positional')) { $val = '?'; } else { if ($this->supportsParameters('named')) { unset($bind[$col]); $bind[':col'.$i] = $val; $val = ':col'.$i; $i++; } else { throw new Zend_Db_Adapter_Exception(get_class($this) ." doesn't support positional or named binding"); } } } $set[] = $this->quoteIdentifier($col, true) . ' = ' . $val; } $where = $this->_whereExpr($where); $sql = "UPDATE " . $this->quoteIdentifier($table, true) . ' SET ' . implode(', ', $set) . (($where) ? " WHERE $where" : ''); if ($this->supportsParameters('positional')) { $stmt = $this->query($sql, array_values($bind)); } else { $stmt = $this->query($sql, $bind); } $result = $stmt->rowCount(); return $result; } public function delete($table, $where = '') { $where = $this->_whereExpr($where); $sql = "DELETE FROM " . $this->quoteIdentifier($table, true) . (($where) ? " WHERE $where" : ''); $stmt = $this->query($sql); $result = $stmt->rowCount(); return $result; } protected function _whereExpr($where) { if (empty($where)) { return $where; } if (!is_array($where)) { $where = array($where); } foreach ($where as $cond => &$term) { if (is_int($cond)) { if ($term instanceof Zend_Db_Expr) { $term = $term->__toString(); } } else { $term = $this->quoteInto($cond, $term); } $term = '(' . $term . ')'; } $where = implode(' AND ', $where); return $where; } public function select() { return new Zend_Db_Select($this); } public function getFetchMode() { return $this->_fetchMode; } public function fetchAll($sql, $bind = array(), $fetchMode = null) { if ($fetchMode === null) { $fetchMode = $this->_fetchMode; } $stmt = $this->query($sql, $bind); $result = $stmt->fetchAll($fetchMode); return $result; } public function fetchRow($sql, $bind = array(), $fetchMode = null) { if ($fetchMode === null) { $fetchMode = $this->_fetchMode; } $stmt = $this->query($sql, $bind); $result = $stmt->fetch($fetchMode); return $result; } public function fetchAssoc($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $data = array(); while ($row = $stmt->fetch(Zend_Db::FETCH_ASSOC)) { $tmp = array_values(array_slice($row, 0, 1)); $data[$tmp[0]] = $row; } return $data; } public function fetchCol($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $result = $stmt->fetchAll(Zend_Db::FETCH_COLUMN, 0); return $result; } public function fetchPairs($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $data = array(); while ($row = $stmt->fetch(Zend_Db::FETCH_NUM)) { $data[$row[0]] = $row[1]; } return $data; } public function fetchOne($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $result = $stmt->fetchColumn(0); return $result; } protected function _quote($value) { if (is_int($value)) { return $value; } elseif (is_float($value)) { return sprintf('%F', $value); } return "'" . addcslashes($value, "\000\n\r\\'\"\032") . "'"; } public function quote($value, $type = null) { $this->_connect(); if ($value instanceof Zend_Db_Select) { return '(' . $value->assemble() . ')'; } if ($value instanceof Zend_Db_Expr) { return $value->__toString(); } if (is_array($value)) { foreach ($value as &$val) { $val = $this->quote($val, $type); } return implode(', ', $value); } if ($type !== null && array_key_exists($type = strtoupper($type), $this->_numericDataTypes)) { $quotedValue = '0'; switch ($this->_numericDataTypes[$type]) { case Zend_Db::INT_TYPE: $quotedValue = (string) intval($value); break; case Zend_Db::BIGINT_TYPE: if (preg_match('/^(
                          [+-]?                  # optional sign
                          (?:
                            0[Xx][\da-fA-F]+     # ODBC-style hexadecimal
                            |\d+                 # decimal or octal, or MySQL ZEROFILL decimal
                            (?:[eE][+-]?\d+)?    # optional exponent on decimals or octals
                          )
                        )/x', (string) $value, $matches)) { $quotedValue = $matches[1]; } break; case Zend_Db::FLOAT_TYPE: $quotedValue = sprintf('%F', $value); } return $quotedValue; } return $this->_quote($value); } public function quoteInto($text, $value, $type = null, $count = null) { if ($count === null) { return str_replace('?', $this->quote($value, $type), $text); } else { while ($count > 0) { if (strpos($text, '?') !== false) { $text = substr_replace($text, $this->quote($value, $type), strpos($text, '?'), 1); } --$count; } return $text; } } public function quoteIdentifier($ident, $auto=false) { return $this->_quoteIdentifierAs($ident, null, $auto); } public function quoteColumnAs($ident, $alias, $auto=false) { return $this->_quoteIdentifierAs($ident, $alias, $auto); } public function quoteTableAs($ident, $alias = null, $auto = false) { return $this->_quoteIdentifierAs($ident, $alias, $auto); } protected function _quoteIdentifierAs($ident, $alias = null, $auto = false, $as = ' AS ') { if ($ident instanceof Zend_Db_Expr) { $quoted = $ident->__toString(); } elseif ($ident instanceof Zend_Db_Select) { $quoted = '(' . $ident->assemble() . ')'; } else { if (is_string($ident)) { $ident = explode('.', $ident); } if (is_array($ident)) { $segments = array(); foreach ($ident as $segment) { if ($segment instanceof Zend_Db_Expr) { $segments[] = $segment->__toString(); } else { $segments[] = $this->_quoteIdentifier($segment, $auto); } } if ($alias !== null && end($ident) == $alias) { $alias = null; } $quoted = implode('.', $segments); } else { $quoted = $this->_quoteIdentifier($ident, $auto); } } if ($alias !== null) { $quoted .= $as . $this->_quoteIdentifier($alias, $auto); } return $quoted; } protected function _quoteIdentifier($value, $auto=false) { if ($auto === false || $this->_autoQuoteIdentifiers === true) { $q = $this->getQuoteIdentifierSymbol(); return ($q . str_replace("$q", "$q$q", $value) . $q); } return $value; } public function getQuoteIdentifierSymbol() { return '"'; } public function lastSequenceId($sequenceName) { return null; } public function nextSequenceId($sequenceName) { return null; } public function foldCase($key) { switch ($this->_caseFolding) { case Zend_Db::CASE_LOWER: $value = strtolower((string) $key); break; case Zend_Db::CASE_UPPER: $value = strtoupper((string) $key); break; case Zend_Db::CASE_NATURAL: default: $value = (string) $key; } return $value; } public function __sleep() { if ($this->_allowSerialization == false) { throw new Zend_Db_Adapter_Exception(get_class($this) ." is not allowed to be serialized"); } $this->_connection = false; return array_keys(array_diff_key(get_object_vars($this), array('_connection'=>false))); } public function __wakeup() { if ($this->_autoReconnectOnUnserialize == true) { $this->getConnection(); } } abstract public function listTables(); abstract public function describeTable($tableName, $schemaName = null); abstract protected function _connect(); abstract public function isConnected(); abstract public function closeConnection(); abstract public function prepare($sql); abstract public function lastInsertId($tableName = null, $primaryKey = null); abstract protected function _beginTransaction(); abstract protected function _commit(); abstract protected function _rollBack(); abstract public function setFetchMode($mode); abstract public function limit($sql, $count, $offset = 0); abstract public function supportsParameters($type); abstract public function getServerVersion(); } 

abstract class Zend_Db_Adapter_Pdo_Abstract extends Zend_Db_Adapter_Abstract { protected $_defaultStmtClass = 'Zend_Db_Statement_Pdo'; protected function _dsn() { $dsn = $this->_config; unset($dsn['username']); unset($dsn['password']); unset($dsn['options']); unset($dsn['charset']); unset($dsn['persistent']); unset($dsn['driver_options']); foreach ($dsn as $key => $val) { $dsn[$key] = "$key=$val"; } return $this->_pdoType . ':' . implode(';', $dsn); } protected function _connect() { if ($this->_connection) { return; } $dsn = $this->_dsn(); if (!extension_loaded('pdo')) { throw new Zend_Db_Adapter_Exception('The PDO extension is required for this adapter but the extension is not loaded'); } if (!in_array($this->_pdoType, PDO::getAvailableDrivers())) { throw new Zend_Db_Adapter_Exception('The ' . $this->_pdoType . ' driver is not currently installed'); } $q = $this->_profiler->queryStart('connect', Zend_Db_Profiler::CONNECT); if (isset($this->_config['persistent']) && ($this->_config['persistent'] == true)) { $this->_config['driver_options'][PDO::ATTR_PERSISTENT] = true; } try { $this->_connection = new PDO( $dsn, $this->_config['username'], $this->_config['password'], $this->_config['driver_options'] ); $this->_profiler->queryEnd($q); $this->_connection->setAttribute(PDO::ATTR_CASE, $this->_caseFolding); $this->_connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (PDOException $e) { throw new Zend_Db_Adapter_Exception($e->getMessage(), $e->getCode(), $e); } } public function isConnected() { return ((bool) ($this->_connection instanceof PDO)); } public function closeConnection() { $this->_connection = null; } public function prepare($sql) { $this->_connect(); $stmtClass = $this->_defaultStmtClass; if (!class_exists($stmtClass)) { Zend_Loader::loadClass($stmtClass); } $stmt = new $stmtClass($this, $sql); $stmt->setFetchMode($this->_fetchMode); return $stmt; } public function lastInsertId($tableName = null, $primaryKey = null) { $this->_connect(); return $this->_connection->lastInsertId(); } public function query($sql, $bind = array()) { if (empty($bind) && $sql instanceof Zend_Db_Select) { $bind = $sql->getBind(); } if (is_array($bind)) { foreach ($bind as $name => $value) { if (!is_int($name) && !preg_match('/^:/', $name)) { $newName = ":$name"; unset($bind[$name]); $bind[$newName] = $value; } } } try { return parent::query($sql, $bind); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function exec($sql) { if ($sql instanceof Zend_Db_Select) { $sql = $sql->assemble(); } try { $affected = $this->getConnection()->exec($sql); if ($affected === false) { $errorInfo = $this->getConnection()->errorInfo(); throw new Zend_Db_Adapter_Exception($errorInfo[2]); } return $affected; } catch (PDOException $e) { throw new Zend_Db_Adapter_Exception($e->getMessage(), $e->getCode(), $e); } } protected function _quote($value) { if (is_int($value) || is_float($value)) { return $value; } $this->_connect(); return $this->_connection->quote($value); } protected function _beginTransaction() { $this->_connect(); $this->_connection->beginTransaction(); } protected function _commit() { $this->_connect(); $this->_connection->commit(); } protected function _rollBack() { $this->_connect(); $this->_connection->rollBack(); } public function setFetchMode($mode) { if (!extension_loaded('pdo')) { throw new Zend_Db_Adapter_Exception('The PDO extension is required for this adapter but the extension is not loaded'); } switch ($mode) { case PDO::FETCH_LAZY: case PDO::FETCH_ASSOC: case PDO::FETCH_NUM: case PDO::FETCH_BOTH: case PDO::FETCH_NAMED: case PDO::FETCH_OBJ: $this->_fetchMode = $mode; break; default: throw new Zend_Db_Adapter_Exception("Invalid fetch mode '$mode' specified"); break; } } public function supportsParameters($type) { switch ($type) { case 'positional': case 'named': default: return true; } } public function getServerVersion() { $this->_connect(); try { $version = $this->_connection->getAttribute(PDO::ATTR_SERVER_VERSION); } catch (PDOException $e) { return null; } $matches = null; if (preg_match('/((?:[0-9]{1,2}\.){1,3}[0-9]{1,2})/', $version, $matches)) { return $matches[1]; } else { return null; } } } 

class Zend_Db_Adapter_Pdo_Mysql extends Zend_Db_Adapter_Pdo_Abstract { protected $_pdoType = 'mysql'; protected $_numericDataTypes = array( Zend_Db::INT_TYPE => Zend_Db::INT_TYPE, Zend_Db::BIGINT_TYPE => Zend_Db::BIGINT_TYPE, Zend_Db::FLOAT_TYPE => Zend_Db::FLOAT_TYPE, 'INT' => Zend_Db::INT_TYPE, 'INTEGER' => Zend_Db::INT_TYPE, 'MEDIUMINT' => Zend_Db::INT_TYPE, 'SMALLINT' => Zend_Db::INT_TYPE, 'TINYINT' => Zend_Db::INT_TYPE, 'BIGINT' => Zend_Db::BIGINT_TYPE, 'SERIAL' => Zend_Db::BIGINT_TYPE, 'DEC' => Zend_Db::FLOAT_TYPE, 'DECIMAL' => Zend_Db::FLOAT_TYPE, 'DOUBLE' => Zend_Db::FLOAT_TYPE, 'DOUBLE PRECISION' => Zend_Db::FLOAT_TYPE, 'FIXED' => Zend_Db::FLOAT_TYPE, 'FLOAT' => Zend_Db::FLOAT_TYPE ); protected function _dsn() { $dsn = parent::_dsn(); if (isset($this->_config['charset'])) { $dsn .= ';charset=' . $this->_config['charset']; } return $dsn; } protected function _connect() { if ($this->_connection) { return; } if (!empty($this->_config['charset'])) { $initCommand = "SET NAMES '" . $this->_config['charset'] . "'"; $this->_config['driver_options'][1002] = $initCommand; } parent::_connect(); } public function getQuoteIdentifierSymbol() { return "`"; } public function listTables() { return $this->fetchCol('SHOW TABLES'); } public function describeTable($tableName, $schemaName = null) { if ($schemaName) { $sql = 'DESCRIBE ' . $this->quoteIdentifier("$schemaName.$tableName", true); } else { $sql = 'DESCRIBE ' . $this->quoteIdentifier($tableName, true); } $stmt = $this->query($sql); $result = $stmt->fetchAll(Zend_Db::FETCH_NUM); $field = 0; $type = 1; $null = 2; $key = 3; $default = 4; $extra = 5; $desc = array(); $i = 1; $p = 1; foreach ($result as $row) { list($length, $scale, $precision, $unsigned, $primary, $primaryPosition, $identity) = array(null, null, null, null, false, null, false); if (preg_match('/unsigned/', $row[$type])) { $unsigned = true; } if (preg_match('/^((?:var)?char)\((\d+)\)/', $row[$type], $matches)) { $row[$type] = $matches[1]; $length = $matches[2]; } else if (preg_match('/^decimal\((\d+),(\d+)\)/', $row[$type], $matches)) { $row[$type] = 'decimal'; $precision = $matches[1]; $scale = $matches[2]; } else if (preg_match('/^float\((\d+),(\d+)\)/', $row[$type], $matches)) { $row[$type] = 'float'; $precision = $matches[1]; $scale = $matches[2]; } else if (preg_match('/^((?:big|medium|small|tiny)?int)\((\d+)\)/', $row[$type], $matches)) { $row[$type] = $matches[1]; } if (strtoupper($row[$key]) == 'PRI') { $primary = true; $primaryPosition = $p; if ($row[$extra] == 'auto_increment') { $identity = true; } else { $identity = false; } ++$p; } $desc[$this->foldCase($row[$field])] = array( 'SCHEMA_NAME' => null, 'TABLE_NAME' => $this->foldCase($tableName), 'COLUMN_NAME' => $this->foldCase($row[$field]), 'COLUMN_POSITION' => $i, 'DATA_TYPE' => $row[$type], 'DEFAULT' => $row[$default], 'NULLABLE' => (bool) ($row[$null] == 'YES'), 'LENGTH' => $length, 'SCALE' => $scale, 'PRECISION' => $precision, 'UNSIGNED' => $unsigned, 'PRIMARY' => $primary, 'PRIMARY_POSITION' => $primaryPosition, 'IDENTITY' => $identity ); ++$i; } return $desc; } public function limit($sql, $count, $offset = 0) { $count = intval($count); if ($count <= 0) { throw new Zend_Db_Adapter_Exception("LIMIT argument count=$count is not valid"); } $offset = intval($offset); if ($offset < 0) { throw new Zend_Db_Adapter_Exception("LIMIT argument offset=$offset is not valid"); } $sql .= " LIMIT $count"; if ($offset > 0) { $sql .= " OFFSET $offset"; } return $sql; } } 

class Zend_Db_Profiler { const CONNECT = 1; const QUERY = 2; const INSERT = 4; const UPDATE = 8; const DELETE = 16; const SELECT = 32; const TRANSACTION = 64; const STORED = 'stored'; const IGNORED = 'ignored'; protected $_queryProfiles = array(); protected $_enabled = false; protected $_filterElapsedSecs = null; protected $_filterTypes = null; public function __construct($enabled = false) { $this->setEnabled($enabled); } public function setEnabled($enable) { $this->_enabled = (boolean) $enable; return $this; } public function getEnabled() { return $this->_enabled; } public function setFilterElapsedSecs($minimumSeconds = null) { if (null === $minimumSeconds) { $this->_filterElapsedSecs = null; } else { $this->_filterElapsedSecs = (integer) $minimumSeconds; } return $this; } public function getFilterElapsedSecs() { return $this->_filterElapsedSecs; } public function setFilterQueryType($queryTypes = null) { $this->_filterTypes = $queryTypes; return $this; } public function getFilterQueryType() { return $this->_filterTypes; } public function clear() { $this->_queryProfiles = array(); return $this; } public function queryClone(Zend_Db_Profiler_Query $query) { $this->_queryProfiles[] = clone $query; end($this->_queryProfiles); return key($this->_queryProfiles); } public function queryStart($queryText, $queryType = null) { if (!$this->_enabled) { return null; } if (null === $queryType) { switch (strtolower(substr(ltrim($queryText), 0, 6))) { case 'insert': $queryType = self::INSERT; break; case 'update': $queryType = self::UPDATE; break; case 'delete': $queryType = self::DELETE; break; case 'select': $queryType = self::SELECT; break; default: $queryType = self::QUERY; break; } } $this->_queryProfiles[] = new Zend_Db_Profiler_Query($queryText, $queryType); end($this->_queryProfiles); return key($this->_queryProfiles); } public function queryEnd($queryId) { if (!$this->_enabled) { return self::IGNORED; } if (!isset($this->_queryProfiles[$queryId])) { throw new Zend_Db_Profiler_Exception("Profiler has no query with handle '$queryId'."); } $qp = $this->_queryProfiles[$queryId]; if ($qp->hasEnded()) { throw new Zend_Db_Profiler_Exception("Query with profiler handle '$queryId' has already ended."); } $qp->end(); if (null !== $this->_filterElapsedSecs && $qp->getElapsedSecs() < $this->_filterElapsedSecs) { unset($this->_queryProfiles[$queryId]); return self::IGNORED; } if (null !== $this->_filterTypes && !($qp->getQueryType() & $this->_filterTypes)) { unset($this->_queryProfiles[$queryId]); return self::IGNORED; } return self::STORED; } public function getQueryProfile($queryId) { if (!array_key_exists($queryId, $this->_queryProfiles)) { throw new Zend_Db_Profiler_Exception("Query handle '$queryId' not found in profiler log."); } return $this->_queryProfiles[$queryId]; } public function getQueryProfiles($queryType = null, $showUnfinished = false) { $queryProfiles = array(); foreach ($this->_queryProfiles as $key => $qp) { if ($queryType === null) { $condition = true; } else { $condition = ($qp->getQueryType() & $queryType); } if (($qp->hasEnded() || $showUnfinished) && $condition) { $queryProfiles[$key] = $qp; } } if (empty($queryProfiles)) { $queryProfiles = false; } return $queryProfiles; } public function getTotalElapsedSecs($queryType = null) { $elapsedSecs = 0; foreach ($this->_queryProfiles as $key => $qp) { if (null === $queryType) { $condition = true; } else { $condition = ($qp->getQueryType() & $queryType); } if (($qp->hasEnded()) && $condition) { $elapsedSecs += $qp->getElapsedSecs(); } } return $elapsedSecs; } public function getTotalNumQueries($queryType = null) { if (null === $queryType) { return count($this->_queryProfiles); } $numQueries = 0; foreach ($this->_queryProfiles as $qp) { if ($qp->hasEnded() && ($qp->getQueryType() & $queryType)) { $numQueries++; } } return $numQueries; } public function getLastQueryProfile() { if (empty($this->_queryProfiles)) { return false; } end($this->_queryProfiles); return current($this->_queryProfiles); } } 

class Zend_Db_Select { const DISTINCT = 'distinct'; const COLUMNS = 'columns'; const FROM = 'from'; const UNION = 'union'; const WHERE = 'where'; const GROUP = 'group'; const HAVING = 'having'; const ORDER = 'order'; const LIMIT_COUNT = 'limitcount'; const LIMIT_OFFSET = 'limitoffset'; const FOR_UPDATE = 'forupdate'; const INNER_JOIN = 'inner join'; const LEFT_JOIN = 'left join'; const RIGHT_JOIN = 'right join'; const FULL_JOIN = 'full join'; const CROSS_JOIN = 'cross join'; const NATURAL_JOIN = 'natural join'; const SQL_WILDCARD = '*'; const SQL_SELECT = 'SELECT'; const SQL_UNION = 'UNION'; const SQL_UNION_ALL = 'UNION ALL'; const SQL_FROM = 'FROM'; const SQL_WHERE = 'WHERE'; const SQL_DISTINCT = 'DISTINCT'; const SQL_GROUP_BY = 'GROUP BY'; const SQL_ORDER_BY = 'ORDER BY'; const SQL_HAVING = 'HAVING'; const SQL_FOR_UPDATE = 'FOR UPDATE'; const SQL_AND = 'AND'; const SQL_AS = 'AS'; const SQL_OR = 'OR'; const SQL_ON = 'ON'; const SQL_ASC = 'ASC'; const SQL_DESC = 'DESC'; protected $_bind = array(); protected $_adapter; protected static $_partsInit = array( self::DISTINCT => false, self::COLUMNS => array(), self::UNION => array(), self::FROM => array(), self::WHERE => array(), self::GROUP => array(), self::HAVING => array(), self::ORDER => array(), self::LIMIT_COUNT => null, self::LIMIT_OFFSET => null, self::FOR_UPDATE => false ); protected static $_joinTypes = array( self::INNER_JOIN, self::LEFT_JOIN, self::RIGHT_JOIN, self::FULL_JOIN, self::CROSS_JOIN, self::NATURAL_JOIN, ); protected static $_unionTypes = array( self::SQL_UNION, self::SQL_UNION_ALL ); protected $_parts = array(); protected $_tableCols = array(); public function __construct(Zend_Db_Adapter_Abstract $adapter) { $this->_adapter = $adapter; $this->_parts = self::$_partsInit; } public function getBind() { return $this->_bind; } public function bind($bind) { $this->_bind = $bind; return $this; } public function distinct($flag = true) { $this->_parts[self::DISTINCT] = (bool) $flag; return $this; } public function from($name, $cols = '*', $schema = null) { return $this->_join(self::FROM, $name, null, $cols, $schema); } public function columns($cols = '*', $correlationName = null) { if ($correlationName === null && count($this->_parts[self::FROM])) { $correlationNameKeys = array_keys($this->_parts[self::FROM]); $correlationName = current($correlationNameKeys); } if (!array_key_exists($correlationName, $this->_parts[self::FROM])) { throw new Zend_Db_Select_Exception("No table has been specified for the FROM clause"); } $this->_tableCols($correlationName, $cols); return $this; } public function union($select = array(), $type = self::SQL_UNION) { if (!is_array($select)) { throw new Zend_Db_Select_Exception( "union() only accepts an array of Zend_Db_Select instances of sql query strings." ); } if (!in_array($type, self::$_unionTypes)) { throw new Zend_Db_Select_Exception("Invalid union type '{$type}'"); } foreach ($select as $target) { $this->_parts[self::UNION][] = array($target, $type); } return $this; } public function join($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->joinInner($name, $cond, $cols, $schema); } public function joinInner($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::INNER_JOIN, $name, $cond, $cols, $schema); } public function joinLeft($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::LEFT_JOIN, $name, $cond, $cols, $schema); } public function joinRight($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::RIGHT_JOIN, $name, $cond, $cols, $schema); } public function joinFull($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::FULL_JOIN, $name, $cond, $cols, $schema); } public function joinCross($name, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::CROSS_JOIN, $name, null, $cols, $schema); } public function joinNatural($name, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::NATURAL_JOIN, $name, null, $cols, $schema); } public function where($cond, $value = null, $type = null) { $this->_parts[self::WHERE][] = $this->_where($cond, $value, $type, true); return $this; } public function orWhere($cond, $value = null, $type = null) { $this->_parts[self::WHERE][] = $this->_where($cond, $value, $type, false); return $this; } public function group($spec) { if (!is_array($spec)) { $spec = array($spec); } foreach ($spec as $val) { if (preg_match('/\(.*\)/', (string) $val)) { $val = new Zend_Db_Expr($val); } $this->_parts[self::GROUP][] = $val; } return $this; } public function having($cond, $value = null, $type = null) { if ($value !== null) { $cond = $this->_adapter->quoteInto($cond, $value, $type); } if ($this->_parts[self::HAVING]) { $this->_parts[self::HAVING][] = self::SQL_AND . " ($cond)"; } else { $this->_parts[self::HAVING][] = "($cond)"; } return $this; } public function orHaving($cond, $value = null, $type = null) { if ($value !== null) { $cond = $this->_adapter->quoteInto($cond, $value, $type); } if ($this->_parts[self::HAVING]) { $this->_parts[self::HAVING][] = self::SQL_OR . " ($cond)"; } else { $this->_parts[self::HAVING][] = "($cond)"; } return $this; } public function order($spec) { if (!is_array($spec)) { $spec = array($spec); } foreach ($spec as $val) { if ($val instanceof Zend_Db_Expr) { $expr = $val->__toString(); if (empty($expr)) { continue; } $this->_parts[self::ORDER][] = $val; } else { if (empty($val)) { continue; } $direction = self::SQL_ASC; if (preg_match('/(.*\W)(' . self::SQL_ASC . '|' . self::SQL_DESC . ')\b/si', $val, $matches)) { $val = trim($matches[1]); $direction = $matches[2]; } if (preg_match('/\(.*\)/', $val)) { $val = new Zend_Db_Expr($val); } $this->_parts[self::ORDER][] = array($val, $direction); } } return $this; } public function limit($count = null, $offset = null) { $this->_parts[self::LIMIT_COUNT] = (int) $count; $this->_parts[self::LIMIT_OFFSET] = (int) $offset; return $this; } public function limitPage($page, $rowCount) { $page = ($page > 0) ? $page : 1; $rowCount = ($rowCount > 0) ? $rowCount : 1; $this->_parts[self::LIMIT_COUNT] = (int) $rowCount; $this->_parts[self::LIMIT_OFFSET] = (int) $rowCount * ($page - 1); return $this; } public function forUpdate($flag = true) { $this->_parts[self::FOR_UPDATE] = (bool) $flag; return $this; } public function getPart($part) { $part = strtolower($part); if (!array_key_exists($part, $this->_parts)) { throw new Zend_Db_Select_Exception("Invalid Select part '$part'"); } return $this->_parts[$part]; } public function query($fetchMode = null, $bind = array()) { if (!empty($bind)) { $this->bind($bind); } $stmt = $this->_adapter->query($this); if ($fetchMode == null) { $fetchMode = $this->_adapter->getFetchMode(); } $stmt->setFetchMode($fetchMode); return $stmt; } public function assemble() { $sql = self::SQL_SELECT; foreach (array_keys(self::$_partsInit) as $part) { $method = '_render' . ucfirst($part); if (method_exists($this, $method)) { $sql = $this->$method($sql); } } return $sql; } public function reset($part = null) { if ($part == null) { $this->_parts = self::$_partsInit; } else if (array_key_exists($part, self::$_partsInit)) { $this->_parts[$part] = self::$_partsInit[$part]; } return $this; } public function getAdapter() { return $this->_adapter; } protected function _join($type, $name, $cond, $cols, $schema = null) { if (!in_array($type, self::$_joinTypes) && $type != self::FROM) { throw new Zend_Db_Select_Exception("Invalid join type '$type'"); } if (count($this->_parts[self::UNION])) { throw new Zend_Db_Select_Exception("Invalid use of table with " . self::SQL_UNION); } if (empty($name)) { $correlationName = $tableName = ''; } else if (is_array($name)) { foreach ($name as $_correlationName => $_tableName) { if (is_string($_correlationName)) { $tableName = $_tableName; $correlationName = $_correlationName; } else { $tableName = $_tableName; $correlationName = $this->_uniqueCorrelation($tableName); } break; } } else if ($name instanceof Zend_Db_Expr|| $name instanceof Zend_Db_Select) { $tableName = $name; $correlationName = $this->_uniqueCorrelation('t'); } else if (preg_match('/^(.+)\s+AS\s+(.+)$/i', $name, $m)) { $tableName = $m[1]; $correlationName = $m[2]; } else { $tableName = $name; $correlationName = $this->_uniqueCorrelation($tableName); } if (!is_object($tableName) && false !== strpos($tableName, '.')) { list($schema, $tableName) = explode('.', $tableName); } $lastFromCorrelationName = null; if (!empty($correlationName)) { if (array_key_exists($correlationName, $this->_parts[self::FROM])) { throw new Zend_Db_Select_Exception("You cannot define a correlation name '$correlationName' more than once"); } if ($type == self::FROM) { $tmpFromParts = $this->_parts[self::FROM]; $this->_parts[self::FROM] = array(); while ($tmpFromParts) { $currentCorrelationName = key($tmpFromParts); if ($tmpFromParts[$currentCorrelationName]['joinType'] != self::FROM) { break; } $lastFromCorrelationName = $currentCorrelationName; $this->_parts[self::FROM][$currentCorrelationName] = array_shift($tmpFromParts); } } else { $tmpFromParts = array(); } $this->_parts[self::FROM][$correlationName] = array( 'joinType' => $type, 'schema' => $schema, 'tableName' => $tableName, 'joinCondition' => $cond ); while ($tmpFromParts) { $currentCorrelationName = key($tmpFromParts); $this->_parts[self::FROM][$currentCorrelationName] = array_shift($tmpFromParts); } } if ($type == self::FROM && $lastFromCorrelationName == null) { $lastFromCorrelationName = true; } $this->_tableCols($correlationName, $cols, $lastFromCorrelationName); return $this; } public function _joinUsing($type, $name, $cond, $cols = '*', $schema = null) { if (empty($this->_parts[self::FROM])) { throw new Zend_Db_Select_Exception("You can only perform a joinUsing after specifying a FROM table"); } $join = $this->_adapter->quoteIdentifier(key($this->_parts[self::FROM]), true); $from = $this->_adapter->quoteIdentifier($this->_uniqueCorrelation($name), true); $cond1 = $from . '.' . $cond; $cond2 = $join . '.' . $cond; $cond = $cond1 . ' = ' . $cond2; return $this->_join($type, $name, $cond, $cols, $schema); } private function _uniqueCorrelation($name) { if (is_array($name)) { $c = end($name); } else { $dot = strrpos($name,'.'); $c = ($dot === false) ? $name : substr($name, $dot+1); } for ($i = 2; array_key_exists($c, $this->_parts[self::FROM]); ++$i) { $c = $name . '_' . (string) $i; } return $c; } protected function _tableCols($correlationName, $cols, $afterCorrelationName = null) { if (!is_array($cols)) { $cols = array($cols); } if ($correlationName == null) { $correlationName = ''; } $columnValues = array(); foreach (array_filter($cols) as $alias => $col) { $currentCorrelationName = $correlationName; if (is_string($col)) { if (preg_match('/^(.+)\s+' . self::SQL_AS . '\s+(.+)$/i', $col, $m)) { $col = $m[1]; $alias = $m[2]; } if (preg_match('/\(.*\)/', $col)) { $col = new Zend_Db_Expr($col); } elseif (preg_match('/(.+)\.(.+)/', $col, $m)) { $currentCorrelationName = $m[1]; $col = $m[2]; } } $columnValues[] = array($currentCorrelationName, $col, is_string($alias) ? $alias : null); } if ($columnValues) { if ($afterCorrelationName === true || is_string($afterCorrelationName)) { $tmpColumns = $this->_parts[self::COLUMNS]; $this->_parts[self::COLUMNS] = array(); } else { $tmpColumns = array(); } if (is_string($afterCorrelationName)) { while ($tmpColumns) { $this->_parts[self::COLUMNS][] = $currentColumn = array_shift($tmpColumns); if ($currentColumn[0] == $afterCorrelationName) { break; } } } foreach ($columnValues as $columnValue) { array_push($this->_parts[self::COLUMNS], $columnValue); } while ($tmpColumns) { array_push($this->_parts[self::COLUMNS], array_shift($tmpColumns)); } } } protected function _where($condition, $value = null, $type = null, $bool = true) { if (count($this->_parts[self::UNION])) { throw new Zend_Db_Select_Exception("Invalid use of where clause with " . self::SQL_UNION); } if ($value !== null) { $condition = $this->_adapter->quoteInto($condition, $value, $type); } $cond = ""; if ($this->_parts[self::WHERE]) { if ($bool === true) { $cond = self::SQL_AND . ' '; } else { $cond = self::SQL_OR . ' '; } } return $cond . "($condition)"; } protected function _getDummyTable() { return array(); } protected function _getQuotedSchema($schema = null) { if ($schema === null) { return null; } return $this->_adapter->quoteIdentifier($schema, true) . '.'; } protected function _getQuotedTable($tableName, $correlationName = null) { return $this->_adapter->quoteTableAs($tableName, $correlationName, true); } protected function _renderDistinct($sql) { if ($this->_parts[self::DISTINCT]) { $sql .= ' ' . self::SQL_DISTINCT; } return $sql; } protected function _renderColumns($sql) { if (!count($this->_parts[self::COLUMNS])) { return null; } $columns = array(); foreach ($this->_parts[self::COLUMNS] as $columnEntry) { list($correlationName, $column, $alias) = $columnEntry; if ($column instanceof Zend_Db_Expr) { $columns[] = $this->_adapter->quoteColumnAs($column, $alias, true); } else { if ($column == self::SQL_WILDCARD) { $column = new Zend_Db_Expr(self::SQL_WILDCARD); $alias = null; } if (empty($correlationName)) { $columns[] = $this->_adapter->quoteColumnAs($column, $alias, true); } else { $columns[] = $this->_adapter->quoteColumnAs(array($correlationName, $column), $alias, true); } } } return $sql .= ' ' . implode(', ', $columns); } protected function _renderFrom($sql) { if (empty($this->_parts[self::FROM])) { $this->_parts[self::FROM] = $this->_getDummyTable(); } $from = array(); foreach ($this->_parts[self::FROM] as $correlationName => $table) { $tmp = ''; $joinType = ($table['joinType'] == self::FROM) ? self::INNER_JOIN : $table['joinType']; if (! empty($from)) { $tmp .= ' ' . strtoupper($joinType) . ' '; } $tmp .= $this->_getQuotedSchema($table['schema']); $tmp .= $this->_getQuotedTable($table['tableName'], $correlationName); if (!empty($from) && ! empty($table['joinCondition'])) { $tmp .= ' ' . self::SQL_ON . ' ' . $table['joinCondition']; } $from[] = $tmp; } if (!empty($from)) { $sql .= ' ' . self::SQL_FROM . ' ' . implode("\n", $from); } return $sql; } protected function _renderUnion($sql) { if ($this->_parts[self::UNION]) { $parts = count($this->_parts[self::UNION]); foreach ($this->_parts[self::UNION] as $cnt => $union) { list($target, $type) = $union; if ($target instanceof Zend_Db_Select) { $target = $target->assemble(); } $sql .= $target; if ($cnt < $parts - 1) { $sql .= ' ' . $type . ' '; } } } return $sql; } protected function _renderWhere($sql) { if ($this->_parts[self::FROM] && $this->_parts[self::WHERE]) { $sql .= ' ' . self::SQL_WHERE . ' ' . implode(' ', $this->_parts[self::WHERE]); } return $sql; } protected function _renderGroup($sql) { if ($this->_parts[self::FROM] && $this->_parts[self::GROUP]) { $group = array(); foreach ($this->_parts[self::GROUP] as $term) { $group[] = $this->_adapter->quoteIdentifier($term, true); } $sql .= ' ' . self::SQL_GROUP_BY . ' ' . implode(",\n\t", $group); } return $sql; } protected function _renderHaving($sql) { if ($this->_parts[self::FROM] && $this->_parts[self::HAVING]) { $sql .= ' ' . self::SQL_HAVING . ' ' . implode(' ', $this->_parts[self::HAVING]); } return $sql; } protected function _renderOrder($sql) { if ($this->_parts[self::ORDER]) { $order = array(); foreach ($this->_parts[self::ORDER] as $term) { if (is_array($term)) { if(is_numeric($term[0]) && strval(intval($term[0])) == $term[0]) { $order[] = (int)trim($term[0]) . ' ' . $term[1]; } else { $order[] = $this->_adapter->quoteIdentifier($term[0], true) . ' ' . $term[1]; } } else if (is_numeric($term) && strval(intval($term)) == $term) { $order[] = (int)trim($term); } else { $order[] = $this->_adapter->quoteIdentifier($term, true); } } $sql .= ' ' . self::SQL_ORDER_BY . ' ' . implode(', ', $order); } return $sql; } protected function _renderLimitoffset($sql) { $count = 0; $offset = 0; if (!empty($this->_parts[self::LIMIT_OFFSET])) { $offset = (int) $this->_parts[self::LIMIT_OFFSET]; $count = PHP_INT_MAX; } if (!empty($this->_parts[self::LIMIT_COUNT])) { $count = (int) $this->_parts[self::LIMIT_COUNT]; } if ($count > 0) { $sql = trim($this->_adapter->limit($sql, $count, $offset)); } return $sql; } protected function _renderForupdate($sql) { if ($this->_parts[self::FOR_UPDATE]) { $sql .= ' ' . self::SQL_FOR_UPDATE; } return $sql; } public function __call($method, array $args) { $matches = array(); if (preg_match('/^join([a-zA-Z]*?)Using$/', $method, $matches)) { $type = strtolower($matches[1]); if ($type) { $type .= ' join'; if (!in_array($type, self::$_joinTypes)) { throw new Zend_Db_Select_Exception("Unrecognized method '$method()'"); } if (in_array($type, array(self::CROSS_JOIN, self::NATURAL_JOIN))) { throw new Zend_Db_Select_Exception("Cannot perform a joinUsing with method '$method()'"); } } else { $type = self::INNER_JOIN; } array_unshift($args, $type); return call_user_func_array(array($this, '_joinUsing'), $args); } throw new Zend_Db_Select_Exception("Unrecognized method '$method()'"); } public function __toString() { try { $sql = $this->assemble(); } catch (Exception $e) { trigger_error($e->getMessage(), E_USER_WARNING); $sql = ''; } return (string)$sql; } } 

abstract class Zend_Db_Table_Abstract { const ADAPTER = 'db'; const DEFINITION = 'definition'; const DEFINITION_CONFIG_NAME = 'definitionConfigName'; const SCHEMA = 'schema'; const NAME = 'name'; const PRIMARY = 'primary'; const COLS = 'cols'; const METADATA = 'metadata'; const METADATA_CACHE = 'metadataCache'; const METADATA_CACHE_IN_CLASS = 'metadataCacheInClass'; const ROW_CLASS = 'rowClass'; const ROWSET_CLASS = 'rowsetClass'; const REFERENCE_MAP = 'referenceMap'; const DEPENDENT_TABLES = 'dependentTables'; const SEQUENCE = 'sequence'; const COLUMNS = 'columns'; const REF_TABLE_CLASS = 'refTableClass'; const REF_COLUMNS = 'refColumns'; const ON_DELETE = 'onDelete'; const ON_UPDATE = 'onUpdate'; const CASCADE = 'cascade'; const RESTRICT = 'restrict'; const SET_NULL = 'setNull'; const DEFAULT_NONE = 'defaultNone'; const DEFAULT_CLASS = 'defaultClass'; const DEFAULT_DB = 'defaultDb'; const SELECT_WITH_FROM_PART = true; const SELECT_WITHOUT_FROM_PART = false; protected static $_defaultDb; protected $_definition = null; protected $_definitionConfigName = null; protected static $_defaultMetadataCache = null; protected $_db; protected $_schema = null; protected $_name = null; protected $_cols; protected $_primary = null; protected $_identity = 1; protected $_sequence = true; protected $_metadata = array(); protected $_metadataCache = null; protected $_metadataCacheInClass = true; protected $_rowClass = 'Zend_Db_Table_Row'; protected $_rowsetClass = 'Zend_Db_Table_Rowset'; protected $_referenceMap = array(); protected $_dependentTables = array(); protected $_defaultSource = self::DEFAULT_NONE; protected $_defaultValues = array(); public function __construct($config = array()) { if (!is_array($config)) { $config = array(self::ADAPTER => $config); } if ($config) { $this->setOptions($config); } $this->_setup(); $this->init(); } public function setOptions(Array $options) { foreach ($options as $key => $value) { switch ($key) { case self::ADAPTER: $this->_setAdapter($value); break; case self::DEFINITION: $this->setDefinition($value); break; case self::DEFINITION_CONFIG_NAME: $this->setDefinitionConfigName($value); break; case self::SCHEMA: $this->_schema = (string) $value; break; case self::NAME: $this->_name = (string) $value; break; case self::PRIMARY: $this->_primary = (array) $value; break; case self::ROW_CLASS: $this->setRowClass($value); break; case self::ROWSET_CLASS: $this->setRowsetClass($value); break; case self::REFERENCE_MAP: $this->setReferences($value); break; case self::DEPENDENT_TABLES: $this->setDependentTables($value); break; case self::METADATA_CACHE: $this->_setMetadataCache($value); break; case self::METADATA_CACHE_IN_CLASS: $this->setMetadataCacheInClass($value); break; case self::SEQUENCE: $this->_setSequence($value); break; default: break; } } return $this; } public function setDefinition(Zend_Db_Table_Definition $definition) { $this->_definition = $definition; return $this; } public function getDefinition() { return $this->_definition; } public function setDefinitionConfigName($definitionConfigName) { $this->_definitionConfigName = $definitionConfigName; return $this; } public function getDefinitionConfigName() { return $this->_definitionConfigName; } public function setRowClass($classname) { $this->_rowClass = (string) $classname; return $this; } public function getRowClass() { return $this->_rowClass; } public function setRowsetClass($classname) { $this->_rowsetClass = (string) $classname; return $this; } public function getRowsetClass() { return $this->_rowsetClass; } public function addReference($ruleKey, $columns, $refTableClass, $refColumns, $onDelete = null, $onUpdate = null) { $reference = array(self::COLUMNS => (array) $columns, self::REF_TABLE_CLASS => $refTableClass, self::REF_COLUMNS => (array) $refColumns); if (!empty($onDelete)) { $reference[self::ON_DELETE] = $onDelete; } if (!empty($onUpdate)) { $reference[self::ON_UPDATE] = $onUpdate; } $this->_referenceMap[$ruleKey] = $reference; return $this; } public function setReferences(array $referenceMap) { $this->_referenceMap = $referenceMap; return $this; } public function getReference($tableClassname, $ruleKey = null) { $thisClass = get_class($this); if ($thisClass === 'Zend_Db_Table') { $thisClass = $this->_definitionConfigName; } $refMap = $this->_getReferenceMapNormalized(); if ($ruleKey !== null) { if (!isset($refMap[$ruleKey])) { throw new Zend_Db_Table_Exception("No reference rule \"$ruleKey\" from table $thisClass to table $tableClassname"); } if ($refMap[$ruleKey][self::REF_TABLE_CLASS] != $tableClassname) { throw new Zend_Db_Table_Exception("Reference rule \"$ruleKey\" does not reference table $tableClassname"); } return $refMap[$ruleKey]; } foreach ($refMap as $reference) { if ($reference[self::REF_TABLE_CLASS] == $tableClassname) { return $reference; } } throw new Zend_Db_Table_Exception("No reference from table $thisClass to table $tableClassname"); } public function setDependentTables(array $dependentTables) { $this->_dependentTables = $dependentTables; return $this; } public function getDependentTables() { return $this->_dependentTables; } public function setDefaultSource($defaultSource = self::DEFAULT_NONE) { if (!in_array($defaultSource, array(self::DEFAULT_CLASS, self::DEFAULT_DB, self::DEFAULT_NONE))) { $defaultSource = self::DEFAULT_NONE; } $this->_defaultSource = $defaultSource; return $this; } public function getDefaultSource() { return $this->_defaultSource; } public function setDefaultValues(Array $defaultValues) { foreach ($defaultValues as $defaultName => $defaultValue) { if (array_key_exists($defaultName, $this->_metadata)) { $this->_defaultValues[$defaultName] = $defaultValue; } } return $this; } public function getDefaultValues() { return $this->_defaultValues; } public static function setDefaultAdapter($db = null) { self::$_defaultDb = self::_setupAdapter($db); } public static function getDefaultAdapter() { return self::$_defaultDb; } protected function _setAdapter($db) { $this->_db = self::_setupAdapter($db); return $this; } public function getAdapter() { return $this->_db; } protected static function _setupAdapter($db) { if ($db === null) { return null; } if (is_string($db)) { $db = Zend_Registry::get($db); } if (!$db instanceof Zend_Db_Adapter_Abstract) { throw new Zend_Db_Table_Exception('Argument must be of type Zend_Db_Adapter_Abstract, or a Registry key where a Zend_Db_Adapter_Abstract object is stored'); } return $db; } public static function setDefaultMetadataCache($metadataCache = null) { self::$_defaultMetadataCache = self::_setupMetadataCache($metadataCache); } public static function getDefaultMetadataCache() { return self::$_defaultMetadataCache; } protected function _setMetadataCache($metadataCache) { $this->_metadataCache = self::_setupMetadataCache($metadataCache); return $this; } public function getMetadataCache() { return $this->_metadataCache; } public function setMetadataCacheInClass($flag) { $this->_metadataCacheInClass = (bool) $flag; return $this; } public function metadataCacheInClass() { return $this->_metadataCacheInClass; } protected static function _setupMetadataCache($metadataCache) { if ($metadataCache === null) { return null; } if (is_string($metadataCache)) { $metadataCache = Zend_Registry::get($metadataCache); } if (!$metadataCache instanceof Zend_Cache_Core) { throw new Zend_Db_Table_Exception('Argument must be of type Zend_Cache_Core, or a Registry key where a Zend_Cache_Core object is stored'); } return $metadataCache; } protected function _setSequence($sequence) { $this->_sequence = $sequence; return $this; } protected function _setup() { $this->_setupDatabaseAdapter(); $this->_setupTableName(); } protected function _setupDatabaseAdapter() { if (! $this->_db) { $this->_db = self::getDefaultAdapter(); if (!$this->_db instanceof Zend_Db_Adapter_Abstract) { throw new Zend_Db_Table_Exception('No adapter found for ' . get_class($this)); } } } protected function _setupTableName() { if (! $this->_name) { $this->_name = get_class($this); } else if (strpos($this->_name, '.')) { list($this->_schema, $this->_name) = explode('.', $this->_name); } } protected function _setupMetadata() { if ($this->metadataCacheInClass() && (count($this->_metadata) > 0)) { return true; } $isMetadataFromCache = true; if (null === $this->_metadataCache && null !== self::$_defaultMetadataCache) { $this->_setMetadataCache(self::$_defaultMetadataCache); } if (null !== $this->_metadataCache) { $dbConfig = $this->_db->getConfig(); $port = isset($dbConfig['options']['port']) ? ':'.$dbConfig['options']['port'] : (isset($dbConfig['port']) ? ':'.$dbConfig['port'] : null); $host = isset($dbConfig['options']['host']) ? ':'.$dbConfig['options']['host'] : (isset($dbConfig['host']) ? ':'.$dbConfig['host'] : null); $cacheId = md5( $port . $host . '/'. $dbConfig['dbname'] . ':' . $this->_schema. '.' . $this->_name ); } if (null === $this->_metadataCache || !($metadata = $this->_metadataCache->load($cacheId))) { $isMetadataFromCache = false; $metadata = $this->_db->describeTable($this->_name, $this->_schema); if (null !== $this->_metadataCache && !$this->_metadataCache->save($metadata, $cacheId)) { trigger_error('Failed saving metadata to metadataCache', E_USER_NOTICE); } } $this->_metadata = $metadata; return $isMetadataFromCache; } protected function _getCols() { if (null === $this->_cols) { $this->_setupMetadata(); $this->_cols = array_keys($this->_metadata); } return $this->_cols; } protected function _setupPrimaryKey() { if (!$this->_primary) { $this->_setupMetadata(); $this->_primary = array(); foreach ($this->_metadata as $col) { if ($col['PRIMARY']) { $this->_primary[ $col['PRIMARY_POSITION'] ] = $col['COLUMN_NAME']; if ($col['IDENTITY']) { $this->_identity = $col['PRIMARY_POSITION']; } } } if (empty($this->_primary)) { throw new Zend_Db_Table_Exception('A table must have a primary key, but none was found'); } } else if (!is_array($this->_primary)) { $this->_primary = array(1 => $this->_primary); } else if (isset($this->_primary[0])) { array_unshift($this->_primary, null); unset($this->_primary[0]); } $cols = $this->_getCols(); if (! array_intersect((array) $this->_primary, $cols) == (array) $this->_primary) { throw new Zend_Db_Table_Exception("Primary key column(s) (" . implode(',', (array) $this->_primary) . ") are not columns in this table (" . implode(',', $cols) . ")"); } $primary = (array) $this->_primary; $pkIdentity = $primary[(int) $this->_identity]; if ($this->_sequence === true && $this->_db instanceof Zend_Db_Adapter_Pdo_Pgsql) { $this->_sequence = $this->_db->quoteIdentifier("{$this->_name}_{$pkIdentity}_seq"); if ($this->_schema) { $this->_sequence = $this->_db->quoteIdentifier($this->_schema) . '.' . $this->_sequence; } } } protected function _getReferenceMapNormalized() { $referenceMapNormalized = array(); foreach ($this->_referenceMap as $rule => $map) { $referenceMapNormalized[$rule] = array(); foreach ($map as $key => $value) { switch ($key) { case self::COLUMNS: case self::REF_COLUMNS: if (!is_array($value)) { $referenceMapNormalized[$rule][$key] = array($value); } else { $referenceMapNormalized[$rule][$key] = $value; } break; default: $referenceMapNormalized[$rule][$key] = $value; break; } } } return $referenceMapNormalized; } public function init() { } public function info($key = null) { $this->_setupPrimaryKey(); $info = array( self::SCHEMA => $this->_schema, self::NAME => $this->_name, self::COLS => $this->_getCols(), self::PRIMARY => (array) $this->_primary, self::METADATA => $this->_metadata, self::ROW_CLASS => $this->getRowClass(), self::ROWSET_CLASS => $this->getRowsetClass(), self::REFERENCE_MAP => $this->_referenceMap, self::DEPENDENT_TABLES => $this->_dependentTables, self::SEQUENCE => $this->_sequence ); if ($key === null) { return $info; } if (!array_key_exists($key, $info)) { throw new Zend_Db_Table_Exception('There is no table information for the key "' . $key . '"'); } return $info[$key]; } public function select($withFromPart = self::SELECT_WITHOUT_FROM_PART) { $select = new Zend_Db_Table_Select($this); if ($withFromPart == self::SELECT_WITH_FROM_PART) { $select->from($this->info(self::NAME), Zend_Db_Table_Select::SQL_WILDCARD, $this->info(self::SCHEMA)); } return $select; } public function insert(array $data) { $this->_setupPrimaryKey(); $primary = (array) $this->_primary; $pkIdentity = $primary[(int)$this->_identity]; if (is_string($this->_sequence) && !isset($data[$pkIdentity])) { $data[$pkIdentity] = $this->_db->nextSequenceId($this->_sequence); $pkSuppliedBySequence = true; } if (!isset($pkSuppliedBySequence) && array_key_exists($pkIdentity, $data)) { if ($data[$pkIdentity] === null || $data[$pkIdentity] === '' || is_bool($data[$pkIdentity]) || (is_array($data[$pkIdentity]) && empty($data[$pkIdentity]))) { unset($data[$pkIdentity]); } } $tableSpec = ($this->_schema ? $this->_schema . '.' : '') . $this->_name; $this->_db->insert($tableSpec, $data); if ($this->_sequence === true && !isset($data[$pkIdentity])) { $data[$pkIdentity] = $this->_db->lastInsertId(); } $pkData = array_intersect_key($data, array_flip($primary)); if (count($primary) == 1) { reset($pkData); return current($pkData); } return $pkData; } public function isIdentity($column) { $this->_setupPrimaryKey(); if (!isset($this->_metadata[$column])) { throw new Zend_Db_Table_Exception('Column "' . $column . '" not found in table.'); } return (bool) $this->_metadata[$column]['IDENTITY']; } public function update(array $data, $where) { $tableSpec = ($this->_schema ? $this->_schema . '.' : '') . $this->_name; return $this->_db->update($tableSpec, $data, $where); } public function _cascadeUpdate($parentTableClassname, array $oldPrimaryKey, array $newPrimaryKey) { $this->_setupMetadata(); $rowsAffected = 0; foreach ($this->_getReferenceMapNormalized() as $map) { if ($map[self::REF_TABLE_CLASS] == $parentTableClassname && isset($map[self::ON_UPDATE])) { switch ($map[self::ON_UPDATE]) { case self::CASCADE: $newRefs = array(); $where = array(); for ($i = 0; $i < count($map[self::COLUMNS]); ++$i) { $col = $this->_db->foldCase($map[self::COLUMNS][$i]); $refCol = $this->_db->foldCase($map[self::REF_COLUMNS][$i]); if (array_key_exists($refCol, $newPrimaryKey)) { $newRefs[$col] = $newPrimaryKey[$refCol]; } $type = $this->_metadata[$col]['DATA_TYPE']; $where[] = $this->_db->quoteInto( $this->_db->quoteIdentifier($col, true) . ' = ?', $oldPrimaryKey[$refCol], $type); } $rowsAffected += $this->update($newRefs, $where); break; default: break; } } } return $rowsAffected; } public function delete($where) { $tableSpec = ($this->_schema ? $this->_schema . '.' : '') . $this->_name; return $this->_db->delete($tableSpec, $where); } public function _cascadeDelete($parentTableClassname, array $primaryKey) { $this->_setupMetadata(); $rowsAffected = 0; foreach ($this->_getReferenceMapNormalized() as $map) { if ($map[self::REF_TABLE_CLASS] == $parentTableClassname && isset($map[self::ON_DELETE])) { switch ($map[self::ON_DELETE]) { case self::CASCADE: $where = array(); for ($i = 0; $i < count($map[self::COLUMNS]); ++$i) { $col = $this->_db->foldCase($map[self::COLUMNS][$i]); $refCol = $this->_db->foldCase($map[self::REF_COLUMNS][$i]); $type = $this->_metadata[$col]['DATA_TYPE']; $where[] = $this->_db->quoteInto( $this->_db->quoteIdentifier($col, true) . ' = ?', $primaryKey[$refCol], $type); } $rowsAffected += $this->delete($where); break; default: break; } } } return $rowsAffected; } public function find() { $this->_setupPrimaryKey(); $args = func_get_args(); $keyNames = array_values((array) $this->_primary); if (count($args) < count($keyNames)) { throw new Zend_Db_Table_Exception("Too few columns for the primary key"); } if (count($args) > count($keyNames)) { throw new Zend_Db_Table_Exception("Too many columns for the primary key"); } $whereList = array(); $numberTerms = 0; foreach ($args as $keyPosition => $keyValues) { $keyValuesCount = count($keyValues); if (!is_array($keyValues)) { $keyValues = array($keyValues); } if ($numberTerms == 0) { $numberTerms = $keyValuesCount; } else if ($keyValuesCount != $numberTerms) { throw new Zend_Db_Table_Exception("Missing value(s) for the primary key"); } $keyValues = array_values($keyValues); for ($i = 0; $i < $keyValuesCount; ++$i) { if (!isset($whereList[$i])) { $whereList[$i] = array(); } $whereList[$i][$keyPosition] = $keyValues[$i]; } } $whereClause = null; if (count($whereList)) { $whereOrTerms = array(); $tableName = $this->_db->quoteTableAs($this->_name, null, true); foreach ($whereList as $keyValueSets) { $whereAndTerms = array(); foreach ($keyValueSets as $keyPosition => $keyValue) { $type = $this->_metadata[$keyNames[$keyPosition]]['DATA_TYPE']; $columnName = $this->_db->quoteIdentifier($keyNames[$keyPosition], true); $whereAndTerms[] = $this->_db->quoteInto( $tableName . '.' . $columnName . ' = ?', $keyValue, $type); } $whereOrTerms[] = '(' . implode(' AND ', $whereAndTerms) . ')'; } $whereClause = '(' . implode(' OR ', $whereOrTerms) . ')'; } if ($whereClause == null) { $rowsetClass = $this->getRowsetClass(); if (!class_exists($rowsetClass)) { Zend_Loader::loadClass($rowsetClass); } return new $rowsetClass(array('table' => $this, 'rowClass' => $this->getRowClass(), 'stored' => true)); } return $this->fetchAll($whereClause); } public function fetchAll($where = null, $order = null, $count = null, $offset = null) { if (!($where instanceof Zend_Db_Table_Select)) { $select = $this->select(); if ($where !== null) { $this->_where($select, $where); } if ($order !== null) { $this->_order($select, $order); } if ($count !== null || $offset !== null) { $select->limit($count, $offset); } } else { $select = $where; } $rows = $this->_fetch($select); $data = array( 'table' => $this, 'data' => $rows, 'readOnly' => $select->isReadOnly(), 'rowClass' => $this->getRowClass(), 'stored' => true ); $rowsetClass = $this->getRowsetClass(); if (!class_exists($rowsetClass)) { Zend_Loader::loadClass($rowsetClass); } return new $rowsetClass($data); } public function fetchRow($where = null, $order = null, $offset = null) { if (!($where instanceof Zend_Db_Table_Select)) { $select = $this->select(); if ($where !== null) { $this->_where($select, $where); } if ($order !== null) { $this->_order($select, $order); } $select->limit(1, ((is_numeric($offset)) ? (int) $offset : null)); } else { $select = $where->limit(1, $where->getPart(Zend_Db_Select::LIMIT_OFFSET)); } $rows = $this->_fetch($select); if (count($rows) == 0) { return null; } $data = array( 'table' => $this, 'data' => $rows[0], 'readOnly' => $select->isReadOnly(), 'stored' => true ); $rowClass = $this->getRowClass(); if (!class_exists($rowClass)) { Zend_Loader::loadClass($rowClass); } return new $rowClass($data); } public function fetchNew() { return $this->createRow(); } public function createRow(array $data = array(), $defaultSource = null) { $cols = $this->_getCols(); $defaults = array_combine($cols, array_fill(0, count($cols), null)); if ($defaultSource == null) { $defaultSource = $this->_defaultSource; } if (!in_array($defaultSource, array(self::DEFAULT_CLASS, self::DEFAULT_DB, self::DEFAULT_NONE))) { $defaultSource = self::DEFAULT_NONE; } if ($defaultSource == self::DEFAULT_DB) { foreach ($this->_metadata as $metadataName => $metadata) { if (($metadata['DEFAULT'] != null) && ($metadata['NULLABLE'] !== true || ($metadata['NULLABLE'] === true && isset($this->_defaultValues[$metadataName]) && $this->_defaultValues[$metadataName] === true)) && (!(isset($this->_defaultValues[$metadataName]) && $this->_defaultValues[$metadataName] === false))) { $defaults[$metadataName] = $metadata['DEFAULT']; } } } elseif ($defaultSource == self::DEFAULT_CLASS && $this->_defaultValues) { foreach ($this->_defaultValues as $defaultName => $defaultValue) { if (array_key_exists($defaultName, $defaults)) { $defaults[$defaultName] = $defaultValue; } } } $config = array( 'table' => $this, 'data' => $defaults, 'readOnly' => false, 'stored' => false ); $rowClass = $this->getRowClass(); if (!class_exists($rowClass)) { Zend_Loader::loadClass($rowClass); } $row = new $rowClass($config); $row->setFromArray($data); return $row; } protected function _where(Zend_Db_Table_Select $select, $where) { $where = (array) $where; foreach ($where as $key => $val) { if (is_int($key)) { $select->where($val); } else { $select->where($key, $val); } } return $select; } protected function _order(Zend_Db_Table_Select $select, $order) { if (!is_array($order)) { $order = array($order); } foreach ($order as $val) { $select->order($val); } return $select; } protected function _fetch(Zend_Db_Table_Select $select) { $stmt = $this->_db->query($select); $data = $stmt->fetchAll(Zend_Db::FETCH_ASSOC); return $data; } } 

class Zend_Db_Table extends Zend_Db_Table_Abstract { public function __construct($config = array(), $definition = null) { if ($definition !== null && is_array($definition)) { $definition = new Zend_Db_Table_Definition($definition); } if (is_string($config)) { if (Zend_Registry::isRegistered($config)) { trigger_error(__CLASS__ . '::' . __METHOD__ . '(\'registryName\') is not valid usage of Zend_Db_Table, ' . 'try extending Zend_Db_Table_Abstract in your extending classes.', E_USER_NOTICE ); $config = array(self::ADAPTER => $config); } else { if ($definition instanceof Zend_Db_Table_Definition && $definition->hasTableConfig($config)) { $config = $definition->getTableConfig($config); } else { $config = array(self::NAME => $config); } } } parent::__construct($config); } } 

class Zend_Db_Table_Definition { protected $_tableConfigs = array(); public function __construct($options = null) { if ($options instanceof Zend_Config) { $this->setConfig($options); } elseif (is_array($options)) { $this->setOptions($options); } } public function setConfig(Zend_Config $config) { $this->setOptions($config->toArray()); return $this; } public function setOptions(Array $options) { foreach ($options as $optionName => $optionValue) { $this->setTableConfig($optionName, $optionValue); } return $this; } public function setTableConfig($tableName, array $tableConfig) { $tableConfig[Zend_Db_Table::DEFINITION_CONFIG_NAME] = $tableName; $tableConfig[Zend_Db_Table::DEFINITION] = $this; if (!isset($tableConfig[Zend_Db_Table::NAME])) { $tableConfig[Zend_Db_Table::NAME] = $tableName; } $this->_tableConfigs[$tableName] = $tableConfig; return $this; } public function getTableConfig($tableName) { return $this->_tableConfigs[$tableName]; } public function removeTableConfig($tableName) { unset($this->_tableConfigs[$tableName]); } public function hasTableConfig($tableName) { return (isset($this->_tableConfigs[$tableName])); } } 


class Zend_Exception extends Exception { private $_previous = null; public function __construct($msg = '', $code = 0, Exception $previous = null) { if (version_compare(PHP_VERSION, '5.3.0', '<')) { parent::__construct($msg, (int) $code); $this->_previous = $previous; } else { parent::__construct($msg, (int) $code, $previous); } } public function __call($method, array $args) { if ('getprevious' == strtolower($method)) { return $this->_getPrevious(); } return null; } public function __toString() { if (version_compare(PHP_VERSION, '5.3.0', '<')) { if (null !== ($e = $this->getPrevious())) { return $e->__toString() . "\n\nNext " . parent::__toString(); } } return parent::__toString(); } protected function _getPrevious() { return $this->_previous; } } 

class Zend_Db_Exception extends Zend_Exception { } 

class Zend_Db_Table_Exception extends Zend_Db_Exception { } 



abstract class Zend_Db_Table_Row_Abstract implements ArrayAccess, IteratorAggregate { protected $_data = array(); protected $_cleanData = array(); protected $_modifiedFields = array(); protected $_table = null; protected $_connected = true; protected $_readOnly = false; protected $_tableClass = null; protected $_primary; public function __construct(array $config = array()) { if (isset($config['table']) && $config['table'] instanceof Zend_Db_Table_Abstract) { $this->_table = $config['table']; $this->_tableClass = get_class($this->_table); } elseif ($this->_tableClass !== null) { $this->_table = $this->_getTableFromString($this->_tableClass); } if (isset($config['data'])) { if (!is_array($config['data'])) { throw new Zend_Db_Table_Row_Exception('Data must be an array'); } $this->_data = $config['data']; } if (isset($config['stored']) && $config['stored'] === true) { $this->_cleanData = $this->_data; } if (isset($config['readOnly']) && $config['readOnly'] === true) { $this->setReadOnly(true); } if (($table = $this->_getTable())) { $info = $table->info(); $this->_primary = (array) $info['primary']; } $this->init(); } protected function _transformColumn($columnName) { if (!is_string($columnName)) { throw new Zend_Db_Table_Row_Exception('Specified column is not a string'); } return $columnName; } public function __get($columnName) { $columnName = $this->_transformColumn($columnName); if (!array_key_exists($columnName, $this->_data)) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is not in the row"); } return $this->_data[$columnName]; } public function __set($columnName, $value) { $columnName = $this->_transformColumn($columnName); if (!array_key_exists($columnName, $this->_data)) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is not in the row"); } $this->_data[$columnName] = $value; $this->_modifiedFields[$columnName] = true; } public function __unset($columnName) { $columnName = $this->_transformColumn($columnName); if (!array_key_exists($columnName, $this->_data)) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is not in the row"); } if ($this->isConnected() && in_array($columnName, $this->_table->info('primary'))) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is a primary key and should not be unset"); } unset($this->_data[$columnName]); return $this; } public function __isset($columnName) { $columnName = $this->_transformColumn($columnName); return array_key_exists($columnName, $this->_data); } public function __sleep() { return array('_tableClass', '_primary', '_data', '_cleanData', '_readOnly' ,'_modifiedFields'); } public function __wakeup() { $this->_connected = false; } public function offsetExists($offset) { return $this->__isset($offset); } public function offsetGet($offset) { return $this->__get($offset); } public function offsetSet($offset, $value) { $this->__set($offset, $value); } public function offsetUnset($offset) { return $this->__unset($offset); } public function init() { } public function getTable() { return $this->_table; } public function setTable(Zend_Db_Table_Abstract $table = null) { if ($table == null) { $this->_table = null; $this->_connected = false; return false; } $tableClass = get_class($table); if (! $table instanceof $this->_tableClass) { throw new Zend_Db_Table_Row_Exception("The specified Table is of class $tableClass, expecting class to be instance of $this->_tableClass"); } $this->_table = $table; $this->_tableClass = $tableClass; $info = $this->_table->info(); if ($info['cols'] != array_keys($this->_data)) { throw new Zend_Db_Table_Row_Exception('The specified Table does not have the same columns as the Row'); } if (! array_intersect((array) $this->_primary, $info['primary']) == (array) $this->_primary) { throw new Zend_Db_Table_Row_Exception("The specified Table '$tableClass' does not have the same primary key as the Row"); } $this->_connected = true; return true; } public function getTableClass() { return $this->_tableClass; } public function isConnected() { return $this->_connected; } public function isReadOnly() { return $this->_readOnly; } public function setReadOnly($flag) { $this->_readOnly = (bool) $flag; } public function select() { return $this->getTable()->select(); } public function save() { if (empty($this->_cleanData)) { return $this->_doInsert(); } else { return $this->_doUpdate(); } } protected function _doInsert() { if ($this->_readOnly === true) { throw new Zend_Db_Table_Row_Exception('This row has been marked read-only'); } $this->_insert(); $data = array_intersect_key($this->_data, $this->_modifiedFields); $primaryKey = $this->_getTable()->insert($data); if (is_array($primaryKey)) { $newPrimaryKey = $primaryKey; } else { $tempPrimaryKey = (array) $this->_primary; $newPrimaryKey = array(current($tempPrimaryKey) => $primaryKey); } $this->_data = array_merge($this->_data, $newPrimaryKey); $this->_postInsert(); $this->_refresh(); return $primaryKey; } protected function _doUpdate() { if ($this->_readOnly === true) { throw new Zend_Db_Table_Row_Exception('This row has been marked read-only'); } $where = $this->_getWhereQuery(false); $this->_update(); $diffData = array_intersect_key($this->_data, $this->_modifiedFields); $pkDiffData = array_intersect_key($diffData, array_flip((array)$this->_primary)); if (count($pkDiffData) > 0) { $depTables = $this->_getTable()->getDependentTables(); if (!empty($depTables)) { $pkNew = $this->_getPrimaryKey(true); $pkOld = $this->_getPrimaryKey(false); foreach ($depTables as $tableClass) { $t = $this->_getTableFromString($tableClass); $t->_cascadeUpdate($this->getTableClass(), $pkOld, $pkNew); } } } if (count($diffData) > 0) { $this->_getTable()->update($diffData, $where); } $this->_postUpdate(); $this->_refresh(); $primaryKey = $this->_getPrimaryKey(true); if (count($primaryKey) == 1) { return current($primaryKey); } return $primaryKey; } public function delete() { if ($this->_readOnly === true) { throw new Zend_Db_Table_Row_Exception('This row has been marked read-only'); } $where = $this->_getWhereQuery(); $this->_delete(); $depTables = $this->_getTable()->getDependentTables(); if (!empty($depTables)) { $pk = $this->_getPrimaryKey(); foreach ($depTables as $tableClass) { $t = $this->_getTableFromString($tableClass); $t->_cascadeDelete($this->getTableClass(), $pk); } } $result = $this->_getTable()->delete($where); $this->_postDelete(); $this->_data = array_combine( array_keys($this->_data), array_fill(0, count($this->_data), null) ); return $result; } public function getIterator() { return new ArrayIterator((array) $this->_data); } public function toArray() { return (array)$this->_data; } public function setFromArray(array $data) { $data = array_intersect_key($data, $this->_data); foreach ($data as $columnName => $value) { $this->__set($columnName, $value); } return $this; } public function refresh() { return $this->_refresh(); } protected function _getTable() { if (!$this->_connected) { throw new Zend_Db_Table_Row_Exception('Cannot save a Row unless it is connected'); } return $this->_table; } protected function _getPrimaryKey($useDirty = true) { if (!is_array($this->_primary)) { throw new Zend_Db_Table_Row_Exception("The primary key must be set as an array"); } $primary = array_flip($this->_primary); if ($useDirty) { $array = array_intersect_key($this->_data, $primary); } else { $array = array_intersect_key($this->_cleanData, $primary); } if (count($primary) != count($array)) { throw new Zend_Db_Table_Row_Exception("The specified Table '$this->_tableClass' does not have the same primary key as the Row"); } return $array; } protected function _getWhereQuery($useDirty = true) { $where = array(); $db = $this->_getTable()->getAdapter(); $primaryKey = $this->_getPrimaryKey($useDirty); $info = $this->_getTable()->info(); $metadata = $info[Zend_Db_Table_Abstract::METADATA]; $where = array(); foreach ($primaryKey as $column => $value) { $tableName = $db->quoteIdentifier($info[Zend_Db_Table_Abstract::NAME], true); $type = $metadata[$column]['DATA_TYPE']; $columnName = $db->quoteIdentifier($column, true); $where[] = $db->quoteInto("{$tableName}.{$columnName} = ?", $value, $type); } return $where; } protected function _refresh() { $where = $this->_getWhereQuery(); $row = $this->_getTable()->fetchRow($where); if (null === $row) { throw new Zend_Db_Table_Row_Exception('Cannot refresh row as parent is missing'); } $this->_data = $row->toArray(); $this->_cleanData = $this->_data; $this->_modifiedFields = array(); } protected function _insert() { } protected function _postInsert() { } protected function _update() { } protected function _postUpdate() { } protected function _delete() { } protected function _postDelete() { } protected function _prepareReference(Zend_Db_Table_Abstract $dependentTable, Zend_Db_Table_Abstract $parentTable, $ruleKey) { $parentTableName = (get_class($parentTable) === 'Zend_Db_Table') ? $parentTable->getDefinitionConfigName() : get_class($parentTable); $map = $dependentTable->getReference($parentTableName, $ruleKey); if (!isset($map[Zend_Db_Table_Abstract::REF_COLUMNS])) { $parentInfo = $parentTable->info(); $map[Zend_Db_Table_Abstract::REF_COLUMNS] = array_values((array) $parentInfo['primary']); } $map[Zend_Db_Table_Abstract::COLUMNS] = (array) $map[Zend_Db_Table_Abstract::COLUMNS]; $map[Zend_Db_Table_Abstract::REF_COLUMNS] = (array) $map[Zend_Db_Table_Abstract::REF_COLUMNS]; return $map; } public function findDependentRowset($dependentTable, $ruleKey = null, Zend_Db_Table_Select $select = null) { $db = $this->_getTable()->getAdapter(); if (is_string($dependentTable)) { $dependentTable = $this->_getTableFromString($dependentTable); } if (!$dependentTable instanceof Zend_Db_Table_Abstract) { $type = gettype($dependentTable); if ($type == 'object') { $type = get_class($dependentTable); } throw new Zend_Db_Table_Row_Exception("Dependent table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($dependentTable->getDefinition() == null)) { $dependentTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if ($select === null) { $select = $dependentTable->select(); } else { $select->setTable($dependentTable); } $map = $this->_prepareReference($dependentTable, $this->_getTable(), $ruleKey); for ($i = 0; $i < count($map[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $parentColumnName = $db->foldCase($map[Zend_Db_Table_Abstract::REF_COLUMNS][$i]); $value = $this->_data[$parentColumnName]; $dependentDb = $dependentTable->getAdapter(); $dependentColumnName = $dependentDb->foldCase($map[Zend_Db_Table_Abstract::COLUMNS][$i]); $dependentColumn = $dependentDb->quoteIdentifier($dependentColumnName, true); $dependentInfo = $dependentTable->info(); $type = $dependentInfo[Zend_Db_Table_Abstract::METADATA][$dependentColumnName]['DATA_TYPE']; $select->where("$dependentColumn = ?", $value, $type); } return $dependentTable->fetchAll($select); } public function findParentRow($parentTable, $ruleKey = null, Zend_Db_Table_Select $select = null) { $db = $this->_getTable()->getAdapter(); if (is_string($parentTable)) { $parentTable = $this->_getTableFromString($parentTable); } if (!$parentTable instanceof Zend_Db_Table_Abstract) { $type = gettype($parentTable); if ($type == 'object') { $type = get_class($parentTable); } throw new Zend_Db_Table_Row_Exception("Parent table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($parentTable->getDefinition() == null)) { $parentTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if ($select === null) { $select = $parentTable->select(); } else { $select->setTable($parentTable); } $map = $this->_prepareReference($this->_getTable(), $parentTable, $ruleKey); for ($i = 0; $i < count($map[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $dependentColumnName = $db->foldCase($map[Zend_Db_Table_Abstract::COLUMNS][$i]); $value = $this->_data[$dependentColumnName]; $parentDb = $parentTable->getAdapter(); $parentColumnName = $parentDb->foldCase($map[Zend_Db_Table_Abstract::REF_COLUMNS][$i]); $parentColumn = $parentDb->quoteIdentifier($parentColumnName, true); $parentInfo = $parentTable->info(); $type = $parentInfo[Zend_Db_Table_Abstract::METADATA][$parentColumnName]['DATA_TYPE']; $nullable = $parentInfo[Zend_Db_Table_Abstract::METADATA][$parentColumnName]['NULLABLE']; if ($value === null && $nullable == true) { $select->where("$parentColumn IS NULL"); } elseif ($value === null && $nullable == false) { return null; } else { $select->where("$parentColumn = ?", $value, $type); } } return $parentTable->fetchRow($select); } public function findManyToManyRowset($matchTable, $intersectionTable, $callerRefRule = null, $matchRefRule = null, Zend_Db_Table_Select $select = null) { $db = $this->_getTable()->getAdapter(); if (is_string($intersectionTable)) { $intersectionTable = $this->_getTableFromString($intersectionTable); } if (!$intersectionTable instanceof Zend_Db_Table_Abstract) { $type = gettype($intersectionTable); if ($type == 'object') { $type = get_class($intersectionTable); } throw new Zend_Db_Table_Row_Exception("Intersection table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($intersectionTable->getDefinition() == null)) { $intersectionTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if (is_string($matchTable)) { $matchTable = $this->_getTableFromString($matchTable); } if (! $matchTable instanceof Zend_Db_Table_Abstract) { $type = gettype($matchTable); if ($type == 'object') { $type = get_class($matchTable); } throw new Zend_Db_Table_Row_Exception("Match table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($matchTable->getDefinition() == null)) { $matchTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if ($select === null) { $select = $matchTable->select(); } else { $select->setTable($matchTable); } $interInfo = $intersectionTable->info(); $interDb = $intersectionTable->getAdapter(); $interName = $interInfo['name']; $interSchema = isset($interInfo['schema']) ? $interInfo['schema'] : null; $matchInfo = $matchTable->info(); $matchName = $matchInfo['name']; $matchSchema = isset($matchInfo['schema']) ? $matchInfo['schema'] : null; $matchMap = $this->_prepareReference($intersectionTable, $matchTable, $matchRefRule); for ($i = 0; $i < count($matchMap[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $interCol = $interDb->quoteIdentifier('i' . '.' . $matchMap[Zend_Db_Table_Abstract::COLUMNS][$i], true); $matchCol = $interDb->quoteIdentifier('m' . '.' . $matchMap[Zend_Db_Table_Abstract::REF_COLUMNS][$i], true); $joinCond[] = "$interCol = $matchCol"; } $joinCond = implode(' AND ', $joinCond); $select->from(array('i' => $interName), array(), $interSchema) ->joinInner(array('m' => $matchName), $joinCond, Zend_Db_Select::SQL_WILDCARD, $matchSchema) ->setIntegrityCheck(false); $callerMap = $this->_prepareReference($intersectionTable, $this->_getTable(), $callerRefRule); for ($i = 0; $i < count($callerMap[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $callerColumnName = $db->foldCase($callerMap[Zend_Db_Table_Abstract::REF_COLUMNS][$i]); $value = $this->_data[$callerColumnName]; $interColumnName = $interDb->foldCase($callerMap[Zend_Db_Table_Abstract::COLUMNS][$i]); $interCol = $interDb->quoteIdentifier("i.$interColumnName", true); $interInfo = $intersectionTable->info(); $type = $interInfo[Zend_Db_Table_Abstract::METADATA][$interColumnName]['DATA_TYPE']; $select->where($interDb->quoteInto("$interCol = ?", $value, $type)); } $stmt = $select->query(); $config = array( 'table' => $matchTable, 'data' => $stmt->fetchAll(Zend_Db::FETCH_ASSOC), 'rowClass' => $matchTable->getRowClass(), 'readOnly' => false, 'stored' => true ); $rowsetClass = $matchTable->getRowsetClass(); if (!class_exists($rowsetClass)) { try { Zend_Loader::loadClass($rowsetClass); } catch (Zend_Exception $e) { throw new Zend_Db_Table_Row_Exception($e->getMessage(), $e->getCode(), $e); } } $rowset = new $rowsetClass($config); return $rowset; } public function __call($method, array $args) { $matches = array(); if (count($args) && $args[0] instanceof Zend_Db_Table_Select) { $select = $args[0]; } else { $select = null; } if (preg_match('/^findParent(\w+?)(?:By(\w+))?$/', $method, $matches)) { $class = $matches[1]; $ruleKey1 = isset($matches[2]) ? $matches[2] : null; return $this->findParentRow($class, $ruleKey1, $select); } if (preg_match('/^find(\w+?)Via(\w+?)(?:By(\w+?)(?:And(\w+))?)?$/', $method, $matches)) { $class = $matches[1]; $viaClass = $matches[2]; $ruleKey1 = isset($matches[3]) ? $matches[3] : null; $ruleKey2 = isset($matches[4]) ? $matches[4] : null; return $this->findManyToManyRowset($class, $viaClass, $ruleKey1, $ruleKey2, $select); } if (preg_match('/^find(\w+?)(?:By(\w+))?$/', $method, $matches)) { $class = $matches[1]; $ruleKey1 = isset($matches[2]) ? $matches[2] : null; return $this->findDependentRowset($class, $ruleKey1, $select); } throw new Zend_Db_Table_Row_Exception("Unrecognized method '$method()'"); } protected function _getTableFromString($tableName) { if ($this->_table instanceof Zend_Db_Table_Abstract) { $tableDefinition = $this->_table->getDefinition(); if ($tableDefinition !== null && $tableDefinition->hasTableConfig($tableName)) { return new Zend_Db_Table($tableName, $tableDefinition); } } if (!class_exists($tableName)) { try { Zend_Loader::loadClass($tableName); } catch (Zend_Exception $e) { throw new Zend_Db_Table_Row_Exception($e->getMessage(), $e->getCode(), $e); } } $options = array(); if (($table = $this->_getTable())) { $options['db'] = $table->getAdapter(); } if (isset($tableDefinition) && $tableDefinition !== null) { $options[Zend_Db_Table_Abstract::DEFINITION] = $tableDefinition; } return new $tableName($options); } } 

class Zend_Db_Table_Row extends Zend_Db_Table_Row_Abstract { } 

class Zend_Db_Table_Row_Exception extends Zend_Db_Table_Exception { } 



abstract class Zend_Db_Table_Rowset_Abstract implements SeekableIterator, Countable, ArrayAccess { protected $_data = array(); protected $_table; protected $_connected = true; protected $_tableClass; protected $_rowClass = 'Zend_Db_Table_Row'; protected $_pointer = 0; protected $_count; protected $_rows = array(); protected $_stored = false; protected $_readOnly = false; public function __construct(array $config) { if (isset($config['table'])) { $this->_table = $config['table']; $this->_tableClass = get_class($this->_table); } if (isset($config['rowClass'])) { $this->_rowClass = $config['rowClass']; } if (!class_exists($this->_rowClass)) { Zend_Loader::loadClass($this->_rowClass); } if (isset($config['data'])) { $this->_data = $config['data']; } if (isset($config['readOnly'])) { $this->_readOnly = $config['readOnly']; } if (isset($config['stored'])) { $this->_stored = $config['stored']; } $this->_count = count($this->_data); $this->init(); } public function __sleep() { return array('_data', '_tableClass', '_rowClass', '_pointer', '_count', '_rows', '_stored', '_readOnly'); } public function __wakeup() { $this->_connected = false; } public function init() { } public function isConnected() { return $this->_connected; } public function getTable() { return $this->_table; } public function setTable(Zend_Db_Table_Abstract $table) { $this->_table = $table; $this->_connected = false; foreach ($this as $row) { $connected = $row->setTable($table); if ($connected == true) { $this->_connected = true; } } return $this->_connected; } public function getTableClass() { return $this->_tableClass; } public function rewind() { $this->_pointer = 0; return $this; } public function current() { if ($this->valid() === false) { return null; } return $this->_loadAndReturnRow($this->_pointer); } public function key() { return $this->_pointer; } public function next() { ++$this->_pointer; } public function valid() { return $this->_pointer >= 0 && $this->_pointer < $this->_count; } public function count() { return $this->_count; } public function seek($position) { $position = (int) $position; if ($position < 0 || $position >= $this->_count) { throw new Zend_Db_Table_Rowset_Exception("Illegal index $position"); } $this->_pointer = $position; return $this; } public function offsetExists($offset) { return isset($this->_data[(int) $offset]); } public function offsetGet($offset) { $offset = (int) $offset; if ($offset < 0 || $offset >= $this->_count) { throw new Zend_Db_Table_Rowset_Exception("Illegal index $offset"); } $this->_pointer = $offset; return $this->current(); } public function offsetSet($offset, $value) { } public function offsetUnset($offset) { } public function getRow($position, $seek = false) { try { $row = $this->_loadAndReturnRow($position); } catch (Zend_Db_Table_Rowset_Exception $e) { throw new Zend_Db_Table_Rowset_Exception('No row could be found at position ' . (int) $position, 0, $e); } if ($seek == true) { $this->seek($position); } return $row; } public function toArray() { foreach ($this->_rows as $i => $row) { $this->_data[$i] = $row->toArray(); } return $this->_data; } protected function _loadAndReturnRow($position) { if (!isset($this->_data[$position])) { throw new Zend_Db_Table_Rowset_Exception("Data for provided position does not exist"); } if (empty($this->_rows[$position])) { $this->_rows[$position] = new $this->_rowClass( array( 'table' => $this->_table, 'data' => $this->_data[$position], 'stored' => $this->_stored, 'readOnly' => $this->_readOnly ) ); } return $this->_rows[$position]; } } 

class Zend_Db_Table_Rowset extends Zend_Db_Table_Rowset_Abstract { } 

class Zend_Db_Table_Rowset_Exception extends Zend_Db_Table_Exception { } 

class Zend_Db_Table_Select extends Zend_Db_Select { protected $_info; protected $_integrityCheck = true; protected $_table; public function __construct(Zend_Db_Table_Abstract $table) { parent::__construct($table->getAdapter()); $this->setTable($table); } public function getTable() { return $this->_table; } public function setTable(Zend_Db_Table_Abstract $table) { $this->_adapter = $table->getAdapter(); $this->_info = $table->info(); $this->_table = $table; return $this; } public function setIntegrityCheck($flag = true) { $this->_integrityCheck = $flag; return $this; } public function isReadOnly() { $readOnly = false; $fields = $this->getPart(Zend_Db_Table_Select::COLUMNS); $cols = $this->_info[Zend_Db_Table_Abstract::COLS]; if (!count($fields)) { return $readOnly; } foreach ($fields as $columnEntry) { $column = $columnEntry[1]; $alias = $columnEntry[2]; if ($alias !== null) { $column = $alias; } switch (true) { case ($column == self::SQL_WILDCARD): break; case ($column instanceof Zend_Db_Expr): case (!in_array($column, $cols)): $readOnly = true; break 2; } } return $readOnly; } public function from($name, $cols = self::SQL_WILDCARD, $schema = null) { if ($name instanceof Zend_Db_Table_Abstract) { $info = $name->info(); $name = $info[Zend_Db_Table_Abstract::NAME]; if (isset($info[Zend_Db_Table_Abstract::SCHEMA])) { $schema = $info[Zend_Db_Table_Abstract::SCHEMA]; } } return $this->joinInner($name, null, $cols, $schema); } public function assemble() { $fields = $this->getPart(Zend_Db_Table_Select::COLUMNS); $primary = $this->_info[Zend_Db_Table_Abstract::NAME]; $schema = $this->_info[Zend_Db_Table_Abstract::SCHEMA]; if (count($this->_parts[self::UNION]) == 0) { if (!count($fields)) { $this->from($primary, self::SQL_WILDCARD, $schema); $fields = $this->getPart(Zend_Db_Table_Select::COLUMNS); } $from = $this->getPart(Zend_Db_Table_Select::FROM); if ($this->_integrityCheck !== false) { foreach ($fields as $columnEntry) { list($table, $column) = $columnEntry; if ($column) { if (!isset($from[$table]) || $from[$table]['tableName'] != $primary) { throw new Zend_Db_Table_Select_Exception('Select query cannot join with another table'); } } } } } return parent::assemble(); } }

class Zend_Db_Select_Exception extends Zend_Db_Exception { } 

class Zend_Db_Table_Select_Exception extends Zend_Db_Select_Exception { } 

class Zend_Loader { public static function loadClass($class, $dirs = null) { if (class_exists($class, false) || interface_exists($class, false)) { return; } if ((null !== $dirs) && !is_string($dirs) && !is_array($dirs)) { throw new Zend_Exception('Directory argument must be a string or an array'); } $className = ltrim($class, '\\'); $file = ''; $namespace = ''; if ($lastNsPos = strripos($className, '\\')) { $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $file = str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; } $file .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; if (!empty($dirs)) { $dirPath = dirname($file); if (is_string($dirs)) { $dirs = explode(PATH_SEPARATOR, $dirs); } foreach ($dirs as $key => $dir) { if ($dir == '.') { $dirs[$key] = $dirPath; } else { $dir = rtrim($dir, '\\/'); $dirs[$key] = $dir . DIRECTORY_SEPARATOR . $dirPath; } } $file = basename($file); self::loadFile($file, $dirs, true); } else { self::loadFile($file, null, true); } if (!class_exists($class, false) && !interface_exists($class, false)) { throw new Zend_Exception("File \"$file\" does not exist or class \"$class\" was not found in the file"); } } public static function loadFile($filename, $dirs = null, $once = false) { self::_securityCheck($filename); $incPath = false; if (!empty($dirs) && (is_array($dirs) || is_string($dirs))) { if (is_array($dirs)) { $dirs = implode(PATH_SEPARATOR, $dirs); } $incPath = get_include_path(); set_include_path($dirs . PATH_SEPARATOR . $incPath); } if ($once) { include_once $filename; } else { include $filename; } if ($incPath) { set_include_path($incPath); } return true; } public static function isReadable($filename) { if (is_readable($filename)) { return true; } if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN' && preg_match('/^[a-z]:/i', $filename) ) { return false; } foreach (self::explodeIncludePath() as $path) { if ($path == '.') { if (is_readable($filename)) { return true; } continue; } $file = $path . '/' . $filename; if (is_readable($file)) { return true; } } return false; } public static function explodeIncludePath($path = null) { if (null === $path) { $path = get_include_path(); } if (PATH_SEPARATOR == ':') { $paths = preg_split('#:(?!//)#', $path); } else { $paths = explode(PATH_SEPARATOR, $path); } return $paths; } public static function autoload($class) { trigger_error(__CLASS__ . '::' . __METHOD__ . ' is deprecated as of 1.8.0 and will be removed with 2.0.0; use Zend_Loader_Autoloader instead', E_USER_NOTICE); try { @self::loadClass($class); return $class; } catch (Exception $e) { return false; } } public static function registerAutoload($class = 'Zend_Loader', $enabled = true) { trigger_error(__CLASS__ . '::' . __METHOD__ . ' is deprecated as of 1.8.0 and will be removed with 2.0.0; use Zend_Loader_Autoloader instead', E_USER_NOTICE); $autoloader = Zend_Loader_Autoloader::getInstance(); $autoloader->setFallbackAutoloader(true); if ('Zend_Loader' != $class) { self::loadClass($class); $methods = get_class_methods($class); if (!in_array('autoload', (array) $methods)) { throw new Zend_Exception("The class \"$class\" does not have an autoload() method"); } $callback = array($class, 'autoload'); if ($enabled) { $autoloader->pushAutoloader($callback); } else { $autoloader->removeAutoloader($callback); } } } protected static function _securityCheck($filename) { if (preg_match('/[^a-z0-9\\/\\\\_.:-]/i', $filename)) { throw new Zend_Exception('Security check: Illegal character in filename'); } } protected static function _includeFile($filespec, $once = false) { if ($once) { return include_once $filespec; } else { return include $filespec ; } } } 

class Zend_Loader_Autoloader { protected static $_instance; protected $_autoloaders = array(); protected $_defaultAutoloader = array('Zend_Loader', 'loadClass'); protected $_fallbackAutoloader = false; protected $_internalAutoloader; protected $_namespaces = array( 'Zend_' => true, 'ZendX_' => true, ); protected $_namespaceAutoloaders = array(); protected $_suppressNotFoundWarnings = false; protected $_zfPath; public static function getInstance() { if (null === self::$_instance) { self::$_instance = new self(); } return self::$_instance; } public static function resetInstance() { self::$_instance = null; } public static function autoload($class) { $self = self::getInstance(); foreach ($self->getClassAutoloaders($class) as $autoloader) { if ($autoloader instanceof Zend_Loader_Autoloader_Interface) { if ($autoloader->autoload($class)) { return true; } } elseif (is_array($autoloader)) { if (call_user_func($autoloader, $class)) { return true; } } elseif (is_string($autoloader) || is_callable($autoloader)) { if ($autoloader($class)) { return true; } } } return false; } public function setDefaultAutoloader($callback) { if (!is_callable($callback)) { throw new Zend_Loader_Exception('Invalid callback specified for default autoloader'); } $this->_defaultAutoloader = $callback; return $this; } public function getDefaultAutoloader() { return $this->_defaultAutoloader; } public function setAutoloaders(array $autoloaders) { $this->_autoloaders = $autoloaders; return $this; } public function getAutoloaders() { return $this->_autoloaders; } public function getNamespaceAutoloaders($namespace) { $namespace = (string) $namespace; if (!array_key_exists($namespace, $this->_namespaceAutoloaders)) { return array(); } return $this->_namespaceAutoloaders[$namespace]; } public function registerNamespace($namespace) { if (is_string($namespace)) { $namespace = (array) $namespace; } elseif (!is_array($namespace)) { throw new Zend_Loader_Exception('Invalid namespace provided'); } foreach ($namespace as $ns) { if (!isset($this->_namespaces[$ns])) { $this->_namespaces[$ns] = true; } } return $this; } public function unregisterNamespace($namespace) { if (is_string($namespace)) { $namespace = (array) $namespace; } elseif (!is_array($namespace)) { throw new Zend_Loader_Exception('Invalid namespace provided'); } foreach ($namespace as $ns) { if (isset($this->_namespaces[$ns])) { unset($this->_namespaces[$ns]); } } return $this; } public function getRegisteredNamespaces() { return array_keys($this->_namespaces); } public function setZfPath($spec, $version = 'latest') { $path = $spec; if (is_array($spec)) { if (!isset($spec['path'])) { throw new Zend_Loader_Exception('No path specified for ZF'); } $path = $spec['path']; if (isset($spec['version'])) { $version = $spec['version']; } } $this->_zfPath = $this->_getVersionPath($path, $version); set_include_path(implode(PATH_SEPARATOR, array( $this->_zfPath, get_include_path(), ))); return $this; } public function getZfPath() { return $this->_zfPath; } public function suppressNotFoundWarnings($flag = null) { if (null === $flag) { return $this->_suppressNotFoundWarnings; } $this->_suppressNotFoundWarnings = (bool) $flag; return $this; } public function setFallbackAutoloader($flag) { $this->_fallbackAutoloader = (bool) $flag; return $this; } public function isFallbackAutoloader() { return $this->_fallbackAutoloader; } public function getClassAutoloaders($class) { $namespace = false; $autoloaders = array(); foreach (array_keys($this->_namespaceAutoloaders) as $ns) { if ('' == $ns) { continue; } if (0 === strpos($class, $ns)) { if ((false === $namespace) || (strlen($ns) > strlen($namespace))) { $namespace = $ns; $autoloaders = $this->getNamespaceAutoloaders($ns); } } } foreach ($this->getRegisteredNamespaces() as $ns) { if (0 === strpos($class, $ns)) { $namespace = $ns; $autoloaders[] = $this->_internalAutoloader; break; } } $autoloadersNonNamespace = $this->getNamespaceAutoloaders(''); if (count($autoloadersNonNamespace)) { foreach ($autoloadersNonNamespace as $ns) { $autoloaders[] = $ns; } unset($autoloadersNonNamespace); } if (!$namespace && $this->isFallbackAutoloader()) { $autoloaders[] = $this->_internalAutoloader; } return $autoloaders; } public function unshiftAutoloader($callback, $namespace = '') { $autoloaders = $this->getAutoloaders(); array_unshift($autoloaders, $callback); $this->setAutoloaders($autoloaders); $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); array_unshift($autoloaders, $callback); $this->_setNamespaceAutoloaders($autoloaders, $ns); } return $this; } public function pushAutoloader($callback, $namespace = '') { $autoloaders = $this->getAutoloaders(); array_push($autoloaders, $callback); $this->setAutoloaders($autoloaders); $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); array_push($autoloaders, $callback); $this->_setNamespaceAutoloaders($autoloaders, $ns); } return $this; } public function removeAutoloader($callback, $namespace = null) { if (null === $namespace) { $autoloaders = $this->getAutoloaders(); if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->setAutoloaders($autoloaders); } foreach ($this->_namespaceAutoloaders as $ns => $autoloaders) { if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->_setNamespaceAutoloaders($autoloaders, $ns); } } } else { $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->_setNamespaceAutoloaders($autoloaders, $ns); } } } return $this; } protected function __construct() { spl_autoload_register(array(__CLASS__, 'autoload')); $this->_internalAutoloader = array($this, '_autoload'); } protected function _autoload($class) { $callback = $this->getDefaultAutoloader(); try { if ($this->suppressNotFoundWarnings()) { @call_user_func($callback, $class); } else { call_user_func($callback, $class); } return $class; } catch (Zend_Exception $e) { return false; } } protected function _setNamespaceAutoloaders(array $autoloaders, $namespace = '') { $namespace = (string) $namespace; $this->_namespaceAutoloaders[$namespace] = $autoloaders; return $this; } protected function _getVersionPath($path, $version) { $type = $this->_getVersionType($version); if ($type == 'latest') { $version = 'latest'; } $availableVersions = $this->_getAvailableVersions($path, $version); if (empty($availableVersions)) { throw new Zend_Loader_Exception('No valid ZF installations discovered'); } $matchedVersion = array_pop($availableVersions); return $matchedVersion; } protected function _getVersionType($version) { if (strtolower($version) == 'latest') { return 'latest'; } $parts = explode('.', $version); $count = count($parts); if (1 == $count) { return 'major'; } if (2 == $count) { return 'minor'; } if (3 < $count) { throw new Zend_Loader_Exception('Invalid version string provided'); } return 'specific'; } protected function _getAvailableVersions($path, $version) { if (!is_dir($path)) { throw new Zend_Loader_Exception('Invalid ZF path provided'); } $path = rtrim($path, '/'); $path = rtrim($path, '\\'); $versionLen = strlen($version); $versions = array(); $dirs = glob("$path/*", GLOB_ONLYDIR); foreach ((array) $dirs as $dir) { $dirName = substr($dir, strlen($path) + 1); if (!preg_match('/^(?:ZendFramework-)?(\d+\.\d+\.\d+((a|b|pl|pr|p|rc)\d+)?)(?:-minimal)?$/i', $dirName, $matches)) { continue; } $matchedVersion = $matches[1]; if (('latest' == $version) || ((strlen($matchedVersion) >= $versionLen) && (0 === strpos($matchedVersion, $version))) ) { $versions[$matchedVersion] = $dir . '/library'; } } uksort($versions, 'version_compare'); return $versions; } } 

class Zend_Db { const PROFILER = 'profiler'; const CASE_FOLDING = 'caseFolding'; const FETCH_MODE = 'fetchMode'; const AUTO_QUOTE_IDENTIFIERS = 'autoQuoteIdentifiers'; const ALLOW_SERIALIZATION = 'allowSerialization'; const AUTO_RECONNECT_ON_UNSERIALIZE = 'autoReconnectOnUnserialize'; const INT_TYPE = 0; const BIGINT_TYPE = 1; const FLOAT_TYPE = 2; const ATTR_AUTOCOMMIT = 0; const ATTR_CASE = 8; const ATTR_CLIENT_VERSION = 5; const ATTR_CONNECTION_STATUS = 7; const ATTR_CURSOR = 10; const ATTR_CURSOR_NAME = 9; const ATTR_DRIVER_NAME = 16; const ATTR_ERRMODE = 3; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_PREFETCH = 1; const ATTR_SERVER_INFO = 6; const ATTR_SERVER_VERSION = 4; const ATTR_STATEMENT_CLASS = 13; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_TIMEOUT = 2; const CASE_LOWER = 2; const CASE_NATURAL = 0; const CASE_UPPER = 1; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERR_ALREADY_EXISTS = NULL; const ERR_CANT_MAP = NULL; const ERR_CONSTRAINT = NULL; const ERR_DISCONNECTED = NULL; const ERR_MISMATCH = NULL; const ERR_NO_PERM = NULL; const ERR_NONE = '00000'; const ERR_NOT_FOUND = NULL; const ERR_NOT_IMPLEMENTED = NULL; const ERR_SYNTAX = NULL; const ERR_TRUNCATED = NULL; const ERRMODE_EXCEPTION = 2; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const FETCH_ASSOC = 2; const FETCH_BOTH = 4; const FETCH_BOUND = 6; const FETCH_CLASS = 8; const FETCH_CLASSTYPE = 262144; const FETCH_COLUMN = 7; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_INTO = 9; const FETCH_LAZY = 1; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_OBJ = 5; const FETCH_ORI_ABS = 4; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_REL = 5; const FETCH_SERIALIZE = 524288; const FETCH_UNIQUE = 196608; const NULL_EMPTY_STRING = 1; const NULL_NATURAL = 0; const NULL_TO_STRING = NULL; const PARAM_BOOL = 5; const PARAM_INPUT_OUTPUT = -2147483648; const PARAM_INT = 1; const PARAM_LOB = 3; const PARAM_NULL = 0; const PARAM_STMT = 4; const PARAM_STR = 2; public static function factory($adapter, $config = array()) { if ($config instanceof Zend_Config) { $config = $config->toArray(); } if ($adapter instanceof Zend_Config) { if (isset($adapter->params)) { $config = $adapter->params->toArray(); } if (isset($adapter->adapter)) { $adapter = (string) $adapter->adapter; } else { $adapter = null; } } if (!is_array($config)) { throw new Zend_Db_Exception('Adapter parameters must be in an array or a Zend_Config object'); } if (!is_string($adapter) || empty($adapter)) { throw new Zend_Db_Exception('Adapter name must be specified in a string'); } $adapterNamespace = 'Zend_Db_Adapter'; if (isset($config['adapterNamespace'])) { if ($config['adapterNamespace'] != '') { $adapterNamespace = $config['adapterNamespace']; } unset($config['adapterNamespace']); } $adapterName = $adapterNamespace . '_'; $adapterName .= str_replace(' ', '_', ucwords(str_replace('_', ' ', strtolower($adapter)))); if (!class_exists($adapterName)) { Zend_Loader::loadClass($adapterName); } $dbAdapter = new $adapterName($config); if (! $dbAdapter instanceof Zend_Db_Adapter_Abstract) { throw new Zend_Db_Exception("Adapter class '$adapterName' does not extend Zend_Db_Adapter_Abstract"); } return $dbAdapter; } } 

class Zend_Db_Adapter_Exception extends Zend_Db_Exception { protected $_chainedException = null; public function __construct($message = '', $code = 0, Exception $e = null) { if ($e && (0 === $code)) { $code = $e->getCode(); } parent::__construct($message, $code, $e); } public function hasChainedException() { return ($this->_previous !== null); } public function getChainedException() { return $this->getPrevious(); } } 

class Zend_Db_Profiler_Exception extends Zend_Db_Exception { } 

class Zend_Db_Expr { protected $_expression; public function __construct($expression) { $this->_expression = (string) $expression; } public function __toString() { return $this->_expression; } } 

interface Zend_Db_Statement_Interface { public function bindColumn($column, &$param, $type = null); public function bindParam($parameter, &$variable, $type = null, $length = null, $options = null); public function bindValue($parameter, $value, $type = null); public function closeCursor(); public function columnCount(); public function errorCode(); public function errorInfo(); public function execute(array $params = array()); public function fetch($style = null, $cursor = null, $offset = null); public function fetchAll($style = null, $col = null); public function fetchColumn($col = 0); public function fetchObject($class = 'stdClass', array $config = array()); public function getAttribute($key); public function nextRowset(); public function rowCount(); public function setAttribute($key, $val); public function setFetchMode($mode); } 

abstract class Zend_Db_Statement implements Zend_Db_Statement_Interface { protected $_stmt = null; protected $_adapter = null; protected $_fetchMode = Zend_Db::FETCH_ASSOC; protected $_attribute = array(); protected $_bindColumn = array(); protected $_bindParam = array(); protected $_sqlSplit = array(); protected $_sqlParam = array(); protected $_queryId = null; public function __construct($adapter, $sql) { $this->_adapter = $adapter; if ($sql instanceof Zend_Db_Select) { $sql = $sql->assemble(); } $this->_parseParameters($sql); $this->_prepare($sql); $this->_queryId = $this->_adapter->getProfiler()->queryStart($sql); } protected function _prepare($sql) { return; } protected function _parseParameters($sql) { $sql = $this->_stripQuoted($sql); $this->_sqlSplit = preg_split('/(\?|\:[a-zA-Z0-9_]+)/', $sql, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY); $this->_sqlParam = array(); foreach ($this->_sqlSplit as $key => $val) { if ($val == '?') { if ($this->_adapter->supportsParameters('positional') === false) { throw new Zend_Db_Statement_Exception("Invalid bind-variable position '$val'"); } } else if ($val[0] == ':') { if ($this->_adapter->supportsParameters('named') === false) { throw new Zend_Db_Statement_Exception("Invalid bind-variable name '$val'"); } } $this->_sqlParam[] = $val; } $this->_bindParam = array(); } protected function _stripQuoted($sql) { $d = $this->_adapter->quoteIdentifier('a'); $d = $d[0]; $de = $this->_adapter->quoteIdentifier($d); $de = substr($de, 1, 2); $de = str_replace('\\', '\\\\', $de); $q = $this->_adapter->quote('a'); $q = $q[0]; $qe = $this->_adapter->quote($q); $qe = substr($qe, 1, 2); $qe = str_replace('\\', '\\\\', $qe); $sql = preg_replace("/$q($qe|\\\\{2}|[^$q])*$q/", '', $sql); if (!empty($q)) { $sql = preg_replace("/$q($qe|[^$q])*$q/", '', $sql); } return $sql; } public function bindColumn($column, &$param, $type = null) { $this->_bindColumn[$column] =& $param; return true; } public function bindParam($parameter, &$variable, $type = null, $length = null, $options = null) { if (!is_int($parameter) && !is_string($parameter)) { throw new Zend_Db_Statement_Exception('Invalid bind-variable position'); } $position = null; if (($intval = (int) $parameter) > 0 && $this->_adapter->supportsParameters('positional')) { if ($intval >= 1 || $intval <= count($this->_sqlParam)) { $position = $intval; } } else if ($this->_adapter->supportsParameters('named')) { if ($parameter[0] != ':') { $parameter = ':' . $parameter; } if (in_array($parameter, $this->_sqlParam) !== false) { $position = $parameter; } } if ($position === null) { throw new Zend_Db_Statement_Exception("Invalid bind-variable position '$parameter'"); } $this->_bindParam[$position] =& $variable; return $this->_bindParam($position, $variable, $type, $length, $options); } public function bindValue($parameter, $value, $type = null) { return $this->bindParam($parameter, $value, $type); } public function execute(array $params = null) { if ($this->_queryId === null) { return $this->_execute($params); } $prof = $this->_adapter->getProfiler(); $qp = $prof->getQueryProfile($this->_queryId); if ($qp->hasEnded()) { $this->_queryId = $prof->queryClone($qp); $qp = $prof->getQueryProfile($this->_queryId); } if ($params !== null) { $qp->bindParams($params); } else { $qp->bindParams($this->_bindParam); } $qp->start($this->_queryId); $retval = $this->_execute($params); $prof->queryEnd($this->_queryId); return $retval; } public function fetchAll($style = null, $col = null) { $data = array(); if ($style === Zend_Db::FETCH_COLUMN && $col === null) { $col = 0; } if ($col === null) { while ($row = $this->fetch($style)) { $data[] = $row; } } else { while (false !== ($val = $this->fetchColumn($col))) { $data[] = $val; } } return $data; } public function fetchColumn($col = 0) { $data = array(); $col = (int) $col; $row = $this->fetch(Zend_Db::FETCH_NUM); if (!is_array($row)) { return false; } return $row[$col]; } public function fetchObject($class = 'stdClass', array $config = array()) { $obj = new $class($config); $row = $this->fetch(Zend_Db::FETCH_ASSOC); if (!is_array($row)) { return false; } foreach ($row as $key => $val) { $obj->$key = $val; } return $obj; } public function getAttribute($key) { if (array_key_exists($key, $this->_attribute)) { return $this->_attribute[$key]; } } public function setAttribute($key, $val) { $this->_attribute[$key] = $val; } public function setFetchMode($mode) { switch ($mode) { case Zend_Db::FETCH_NUM: case Zend_Db::FETCH_ASSOC: case Zend_Db::FETCH_BOTH: case Zend_Db::FETCH_OBJ: $this->_fetchMode = $mode; break; case Zend_Db::FETCH_BOUND: default: $this->closeCursor(); throw new Zend_Db_Statement_Exception('invalid fetch mode'); break; } } public function _fetchBound($row) { foreach ($row as $key => $value) { if (is_int($key)) { $key++; } if (isset($this->_bindColumn[$key])) { $this->_bindColumn[$key] = $value; } } return true; } public function getAdapter() { return $this->_adapter; } public function getDriverStatement() { return $this->_stmt; } } 

class Zend_Db_Statement_Exception extends Zend_Db_Exception { public function hasChainedException() { return ($this->getPrevious() !== null); } public function getChainedException() { return $this->getPrevious(); } } 

class Zend_Db_Statement_Pdo extends Zend_Db_Statement implements IteratorAggregate { protected $_fetchMode = PDO::FETCH_ASSOC; protected function _prepare($sql) { try { $this->_stmt = $this->_adapter->getConnection()->prepare($sql); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function bindColumn($column, &$param, $type = null) { try { if ($type === null) { return $this->_stmt->bindColumn($column, $param); } else { return $this->_stmt->bindColumn($column, $param, $type); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } protected function _bindParam($parameter, &$variable, $type = null, $length = null, $options = null) { try { if ($type === null) { if (is_bool($variable)) { $type = PDO::PARAM_BOOL; } elseif ($variable === null) { $type = PDO::PARAM_NULL; } elseif (is_integer($variable)) { $type = PDO::PARAM_INT; } else { $type = PDO::PARAM_STR; } } return $this->_stmt->bindParam($parameter, $variable, $type, $length, $options); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function bindValue($parameter, $value, $type = null) { if (is_string($parameter) && $parameter[0] != ':') { $parameter = ":$parameter"; } $this->_bindParam[$parameter] = $value; try { if ($type === null) { return $this->_stmt->bindValue($parameter, $value); } else { return $this->_stmt->bindValue($parameter, $value, $type); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function closeCursor() { try { return $this->_stmt->closeCursor(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function columnCount() { try { return $this->_stmt->columnCount(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function errorCode() { try { return $this->_stmt->errorCode(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function errorInfo() { try { return $this->_stmt->errorInfo(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function _execute(array $params = null) { try { if ($params !== null) { return $this->_stmt->execute($params); } else { return $this->_stmt->execute(); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), (int) $e->getCode(), $e); } } public function fetch($style = null, $cursor = null, $offset = null) { if ($style === null) { $style = $this->_fetchMode; } try { return $this->_stmt->fetch($style, $cursor, $offset); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function getIterator() { return new IteratorIterator($this->_stmt); } public function fetchAll($style = null, $col = null) { if ($style === null) { $style = $this->_fetchMode; } try { if ($style == PDO::FETCH_COLUMN) { if ($col === null) { $col = 0; } return $this->_stmt->fetchAll($style, $col); } else { return $this->_stmt->fetchAll($style); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function fetchColumn($col = 0) { try { return $this->_stmt->fetchColumn($col); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function fetchObject($class = 'stdClass', array $config = array()) { try { return $this->_stmt->fetchObject($class, $config); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function getAttribute($key) { try { return $this->_stmt->getAttribute($key); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function getColumnMeta($column) { try { return $this->_stmt->getColumnMeta($column); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function nextRowset() { try { return $this->_stmt->nextRowset(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function rowCount() { try { return $this->_stmt->rowCount(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function setAttribute($key, $val) { try { return $this->_stmt->setAttribute($key, $val); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function setFetchMode($mode) { $this->_fetchMode = $mode; try { return $this->_stmt->setFetchMode($mode); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } } 

class Zend_Db_Profiler_Query { protected $_query = ''; protected $_queryType = 0; protected $_startedMicrotime = null; protected $_endedMicrotime = null; protected $_boundParams = array(); public function __construct($query, $queryType) { $this->_query = $query; $this->_queryType = $queryType; $this->start(); } public function __clone() { $this->_boundParams = array(); $this->_endedMicrotime = null; $this->start(); } public function start() { $this->_startedMicrotime = microtime(true); } public function end() { $this->_endedMicrotime = microtime(true); } public function hasEnded() { return $this->_endedMicrotime !== null; } public function getQuery() { return $this->_query; } public function getQueryType() { return $this->_queryType; } public function bindParam($param, $variable) { $this->_boundParams[$param] = $variable; } public function bindParams(array $params) { if (array_key_exists(0, $params)) { array_unshift($params, null); unset($params[0]); } foreach ($params as $param => $value) { $this->bindParam($param, $value); } } public function getQueryParams() { return $this->_boundParams; } public function getElapsedSecs() { if (null === $this->_endedMicrotime) { return false; } return $this->_endedMicrotime - $this->_startedMicrotime; } public function getStartedMicrotime() { if(null === $this->_startedMicrotime) { return false; } return $this->_startedMicrotime; } } 


class Zend_Registry extends ArrayObject { private static $_registryClassName = 'Zend_Registry'; private static $_registry = null; public static function getInstance() { if (self::$_registry === null) { self::init(); } return self::$_registry; } public static function setInstance(Zend_Registry $registry) { if (self::$_registry !== null) { throw new Zend_Exception('Registry is already initialized'); } self::setClassName(get_class($registry)); self::$_registry = $registry; } protected static function init() { self::setInstance(new self::$_registryClassName()); } public static function setClassName($registryClassName = 'Zend_Registry') { if (self::$_registry !== null) { throw new Zend_Exception('Registry is already initialized'); } if (!is_string($registryClassName)) { throw new Zend_Exception("Argument is not a class name"); } if (!class_exists($registryClassName)) { Zend_Loader::loadClass($registryClassName); } self::$_registryClassName = $registryClassName; } public static function _unsetInstance() { self::$_registry = null; } public static function get($index) { $instance = self::getInstance(); if (!$instance->offsetExists($index)) { throw new Zend_Exception("No entry is registered for key '$index'"); } return $instance->offsetGet($index); } public static function set($index, $value) { $instance = self::getInstance(); $instance->offsetSet($index, $value); } public static function isRegistered($index) { if (self::$_registry === null) { return false; } return self::$_registry->offsetExists($index); } public function __construct($array = array(), $flags = parent::ARRAY_AS_PROPS) { parent::__construct($array, $flags); } public function offsetExists($index) { return array_key_exists($index, $this); } } 

