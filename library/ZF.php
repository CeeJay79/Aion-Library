<?php
abstract class Zend_Db_Adapter_Abstract { protected $_config = array(); protected $_fetchMode = Zend_Db::FETCH_ASSOC; protected $_profiler; protected $_defaultStmtClass = 'Zend_Db_Statement'; protected $_defaultProfilerClass = 'Zend_Db_Profiler'; protected $_connection = null; protected $_caseFolding = Zend_Db::CASE_NATURAL; protected $_autoQuoteIdentifiers = true; protected $_numericDataTypes = array( Zend_Db::INT_TYPE => Zend_Db::INT_TYPE, Zend_Db::BIGINT_TYPE => Zend_Db::BIGINT_TYPE, Zend_Db::FLOAT_TYPE => Zend_Db::FLOAT_TYPE ); protected $_allowSerialization = true; protected $_autoReconnectOnUnserialize = false; public function __construct($config) { if (!is_array($config)) { if ($config instanceof Zend_Config) { $config = $config->toArray(); } else { throw new Zend_Db_Adapter_Exception('Adapter parameters must be in an array or a Zend_Config object'); } } $this->_checkRequiredOptions($config); $options = array( Zend_Db::CASE_FOLDING => $this->_caseFolding, Zend_Db::AUTO_QUOTE_IDENTIFIERS => $this->_autoQuoteIdentifiers, Zend_Db::FETCH_MODE => $this->_fetchMode, ); $driverOptions = array(); if (array_key_exists('options', $config)) { foreach ((array) $config['options'] as $key => $value) { $options[$key] = $value; } } if (array_key_exists('driver_options', $config)) { if (!empty($config['driver_options'])) { foreach ((array) $config['driver_options'] as $key => $value) { $driverOptions[$key] = $value; } } } if (!isset($config['charset'])) { $config['charset'] = null; } if (!isset($config['persistent'])) { $config['persistent'] = false; } $this->_config = array_merge($this->_config, $config); $this->_config['options'] = $options; $this->_config['driver_options'] = $driverOptions; if (array_key_exists(Zend_Db::CASE_FOLDING, $options)) { $case = (int) $options[Zend_Db::CASE_FOLDING]; switch ($case) { case Zend_Db::CASE_LOWER: case Zend_Db::CASE_UPPER: case Zend_Db::CASE_NATURAL: $this->_caseFolding = $case; break; default: throw new Zend_Db_Adapter_Exception('Case must be one of the following constants: ' . 'Zend_Db::CASE_NATURAL, Zend_Db::CASE_LOWER, Zend_Db::CASE_UPPER'); } } if (array_key_exists(Zend_Db::FETCH_MODE, $options)) { if (is_string($options[Zend_Db::FETCH_MODE])) { $constant = 'Zend_Db::FETCH_' . strtoupper($options[Zend_Db::FETCH_MODE]); if(defined($constant)) { $options[Zend_Db::FETCH_MODE] = constant($constant); } } $this->setFetchMode((int) $options[Zend_Db::FETCH_MODE]); } if (array_key_exists(Zend_Db::AUTO_QUOTE_IDENTIFIERS, $options)) { $this->_autoQuoteIdentifiers = (bool) $options[Zend_Db::AUTO_QUOTE_IDENTIFIERS]; } if (array_key_exists(Zend_Db::ALLOW_SERIALIZATION, $options)) { $this->_allowSerialization = (bool) $options[Zend_Db::ALLOW_SERIALIZATION]; } if (array_key_exists(Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE, $options)) { $this->_autoReconnectOnUnserialize = (bool) $options[Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE]; } $profiler = false; if (array_key_exists(Zend_Db::PROFILER, $this->_config)) { $profiler = $this->_config[Zend_Db::PROFILER]; unset($this->_config[Zend_Db::PROFILER]); } $this->setProfiler($profiler); } protected function _checkRequiredOptions(array $config) { if (! array_key_exists('dbname', $config)) { throw new Zend_Db_Adapter_Exception("Configuration array must have a key for 'dbname' that names the database instance"); } if (! array_key_exists('password', $config)) { throw new Zend_Db_Adapter_Exception("Configuration array must have a key for 'password' for login credentials"); } if (! array_key_exists('username', $config)) { throw new Zend_Db_Adapter_Exception("Configuration array must have a key for 'username' for login credentials"); } } public function getConnection() { $this->_connect(); return $this->_connection; } public function getConfig() { return $this->_config; } public function setProfiler($profiler) { $enabled = null; $profilerClass = $this->_defaultProfilerClass; $profilerInstance = null; if ($profilerIsObject = is_object($profiler)) { if ($profiler instanceof Zend_Db_Profiler) { $profilerInstance = $profiler; } else if ($profiler instanceof Zend_Config) { $profiler = $profiler->toArray(); } else { throw new Zend_Db_Profiler_Exception('Profiler argument must be an instance of either Zend_Db_Profiler' . ' or Zend_Config when provided as an object'); } } if (is_array($profiler)) { if (isset($profiler['enabled'])) { $enabled = (bool) $profiler['enabled']; } if (isset($profiler['class'])) { $profilerClass = $profiler['class']; } if (isset($profiler['instance'])) { $profilerInstance = $profiler['instance']; } } else if (!$profilerIsObject) { $enabled = (bool) $profiler; } if ($profilerInstance === null) { if (!class_exists($profilerClass)) { Zend_Loader::loadClass($profilerClass); } $profilerInstance = new $profilerClass(); } if (!$profilerInstance instanceof Zend_Db_Profiler) { throw new Zend_Db_Profiler_Exception('Class ' . get_class($profilerInstance) . ' does not extend ' . 'Zend_Db_Profiler'); } if (null !== $enabled) { $profilerInstance->setEnabled($enabled); } $this->_profiler = $profilerInstance; return $this; } public function getProfiler() { return $this->_profiler; } public function getStatementClass() { return $this->_defaultStmtClass; } public function setStatementClass($class) { $this->_defaultStmtClass = $class; return $this; } public function query($sql, $bind = array()) { $this->_connect(); if ($sql instanceof Zend_Db_Select) { if (empty($bind)) { $bind = $sql->getBind(); } $sql = $sql->assemble(); } if (!is_array($bind)) { $bind = array($bind); } $stmt = $this->prepare($sql); $stmt->execute($bind); $stmt->setFetchMode($this->_fetchMode); return $stmt; } public function beginTransaction() { $this->_connect(); $q = $this->_profiler->queryStart('begin', Zend_Db_Profiler::TRANSACTION); $this->_beginTransaction(); $this->_profiler->queryEnd($q); return $this; } public function commit() { $this->_connect(); $q = $this->_profiler->queryStart('commit', Zend_Db_Profiler::TRANSACTION); $this->_commit(); $this->_profiler->queryEnd($q); return $this; } public function rollBack() { $this->_connect(); $q = $this->_profiler->queryStart('rollback', Zend_Db_Profiler::TRANSACTION); $this->_rollBack(); $this->_profiler->queryEnd($q); return $this; } public function insert($table, array $bind) { $cols = array(); $vals = array(); $i = 0; foreach ($bind as $col => $val) { $cols[] = $this->quoteIdentifier($col, true); if ($val instanceof Zend_Db_Expr) { $vals[] = $val->__toString(); unset($bind[$col]); } else { if ($this->supportsParameters('positional')) { $vals[] = '?'; } else { if ($this->supportsParameters('named')) { unset($bind[$col]); $bind[':col'.$i] = $val; $vals[] = ':col'.$i; $i++; } else { throw new Zend_Db_Adapter_Exception(get_class($this) ." doesn't support positional or named binding"); } } } } $sql = "INSERT INTO " . $this->quoteIdentifier($table, true) . ' (' . implode(', ', $cols) . ') ' . 'VALUES (' . implode(', ', $vals) . ')'; if ($this->supportsParameters('positional')) { $bind = array_values($bind); } $stmt = $this->query($sql, $bind); $result = $stmt->rowCount(); return $result; } public function update($table, array $bind, $where = '') { $set = array(); $i = 0; foreach ($bind as $col => $val) { if ($val instanceof Zend_Db_Expr) { $val = $val->__toString(); unset($bind[$col]); } else { if ($this->supportsParameters('positional')) { $val = '?'; } else { if ($this->supportsParameters('named')) { unset($bind[$col]); $bind[':col'.$i] = $val; $val = ':col'.$i; $i++; } else { throw new Zend_Db_Adapter_Exception(get_class($this) ." doesn't support positional or named binding"); } } } $set[] = $this->quoteIdentifier($col, true) . ' = ' . $val; } $where = $this->_whereExpr($where); $sql = "UPDATE " . $this->quoteIdentifier($table, true) . ' SET ' . implode(', ', $set) . (($where) ? " WHERE $where" : ''); if ($this->supportsParameters('positional')) { $stmt = $this->query($sql, array_values($bind)); } else { $stmt = $this->query($sql, $bind); } $result = $stmt->rowCount(); return $result; } public function delete($table, $where = '') { $where = $this->_whereExpr($where); $sql = "DELETE FROM " . $this->quoteIdentifier($table, true) . (($where) ? " WHERE $where" : ''); $stmt = $this->query($sql); $result = $stmt->rowCount(); return $result; } protected function _whereExpr($where) { if (empty($where)) { return $where; } if (!is_array($where)) { $where = array($where); } foreach ($where as $cond => &$term) { if (is_int($cond)) { if ($term instanceof Zend_Db_Expr) { $term = $term->__toString(); } } else { $term = $this->quoteInto($cond, $term); } $term = '(' . $term . ')'; } $where = implode(' AND ', $where); return $where; } public function select() { return new Zend_Db_Select($this); } public function getFetchMode() { return $this->_fetchMode; } public function fetchAll($sql, $bind = array(), $fetchMode = null) { if ($fetchMode === null) { $fetchMode = $this->_fetchMode; } $stmt = $this->query($sql, $bind); $result = $stmt->fetchAll($fetchMode); return $result; } public function fetchRow($sql, $bind = array(), $fetchMode = null) { if ($fetchMode === null) { $fetchMode = $this->_fetchMode; } $stmt = $this->query($sql, $bind); $result = $stmt->fetch($fetchMode); return $result; } public function fetchAssoc($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $data = array(); while ($row = $stmt->fetch(Zend_Db::FETCH_ASSOC)) { $tmp = array_values(array_slice($row, 0, 1)); $data[$tmp[0]] = $row; } return $data; } public function fetchCol($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $result = $stmt->fetchAll(Zend_Db::FETCH_COLUMN, 0); return $result; } public function fetchPairs($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $data = array(); while ($row = $stmt->fetch(Zend_Db::FETCH_NUM)) { $data[$row[0]] = $row[1]; } return $data; } public function fetchOne($sql, $bind = array()) { $stmt = $this->query($sql, $bind); $result = $stmt->fetchColumn(0); return $result; } protected function _quote($value) { if (is_int($value)) { return $value; } elseif (is_float($value)) { return sprintf('%F', $value); } return "'" . addcslashes($value, "\000\n\r\\'\"\032") . "'"; } public function quote($value, $type = null) { $this->_connect(); if ($value instanceof Zend_Db_Select) { return '(' . $value->assemble() . ')'; } if ($value instanceof Zend_Db_Expr) { return $value->__toString(); } if (is_array($value)) { foreach ($value as &$val) { $val = $this->quote($val, $type); } return implode(', ', $value); } if ($type !== null && array_key_exists($type = strtoupper($type), $this->_numericDataTypes)) { $quotedValue = '0'; switch ($this->_numericDataTypes[$type]) { case Zend_Db::INT_TYPE: $quotedValue = (string) intval($value); break; case Zend_Db::BIGINT_TYPE: if (preg_match('/^(
                          [+-]?                  # optional sign
                          (?:
                            0[Xx][\da-fA-F]+     # ODBC-style hexadecimal
                            |\d+                 # decimal or octal, or MySQL ZEROFILL decimal
                            (?:[eE][+-]?\d+)?    # optional exponent on decimals or octals
                          )
                        )/x', (string) $value, $matches)) { $quotedValue = $matches[1]; } break; case Zend_Db::FLOAT_TYPE: $quotedValue = sprintf('%F', $value); } return $quotedValue; } return $this->_quote($value); } public function quoteInto($text, $value, $type = null, $count = null) { if ($count === null) { return str_replace('?', $this->quote($value, $type), $text); } else { while ($count > 0) { if (strpos($text, '?') !== false) { $text = substr_replace($text, $this->quote($value, $type), strpos($text, '?'), 1); } --$count; } return $text; } } public function quoteIdentifier($ident, $auto=false) { return $this->_quoteIdentifierAs($ident, null, $auto); } public function quoteColumnAs($ident, $alias, $auto=false) { return $this->_quoteIdentifierAs($ident, $alias, $auto); } public function quoteTableAs($ident, $alias = null, $auto = false) { return $this->_quoteIdentifierAs($ident, $alias, $auto); } protected function _quoteIdentifierAs($ident, $alias = null, $auto = false, $as = ' AS ') { if ($ident instanceof Zend_Db_Expr) { $quoted = $ident->__toString(); } elseif ($ident instanceof Zend_Db_Select) { $quoted = '(' . $ident->assemble() . ')'; } else { if (is_string($ident)) { $ident = explode('.', $ident); } if (is_array($ident)) { $segments = array(); foreach ($ident as $segment) { if ($segment instanceof Zend_Db_Expr) { $segments[] = $segment->__toString(); } else { $segments[] = $this->_quoteIdentifier($segment, $auto); } } if ($alias !== null && end($ident) == $alias) { $alias = null; } $quoted = implode('.', $segments); } else { $quoted = $this->_quoteIdentifier($ident, $auto); } } if ($alias !== null) { $quoted .= $as . $this->_quoteIdentifier($alias, $auto); } return $quoted; } protected function _quoteIdentifier($value, $auto=false) { if ($auto === false || $this->_autoQuoteIdentifiers === true) { $q = $this->getQuoteIdentifierSymbol(); return ($q . str_replace("$q", "$q$q", $value) . $q); } return $value; } public function getQuoteIdentifierSymbol() { return '"'; } public function lastSequenceId($sequenceName) { return null; } public function nextSequenceId($sequenceName) { return null; } public function foldCase($key) { switch ($this->_caseFolding) { case Zend_Db::CASE_LOWER: $value = strtolower((string) $key); break; case Zend_Db::CASE_UPPER: $value = strtoupper((string) $key); break; case Zend_Db::CASE_NATURAL: default: $value = (string) $key; } return $value; } public function __sleep() { if ($this->_allowSerialization == false) { throw new Zend_Db_Adapter_Exception(get_class($this) ." is not allowed to be serialized"); } $this->_connection = false; return array_keys(array_diff_key(get_object_vars($this), array('_connection'=>false))); } public function __wakeup() { if ($this->_autoReconnectOnUnserialize == true) { $this->getConnection(); } } abstract public function listTables(); abstract public function describeTable($tableName, $schemaName = null); abstract protected function _connect(); abstract public function isConnected(); abstract public function closeConnection(); abstract public function prepare($sql); abstract public function lastInsertId($tableName = null, $primaryKey = null); abstract protected function _beginTransaction(); abstract protected function _commit(); abstract protected function _rollBack(); abstract public function setFetchMode($mode); abstract public function limit($sql, $count, $offset = 0); abstract public function supportsParameters($type); abstract public function getServerVersion(); } 

abstract class Zend_Db_Adapter_Pdo_Abstract extends Zend_Db_Adapter_Abstract { protected $_defaultStmtClass = 'Zend_Db_Statement_Pdo'; protected function _dsn() { $dsn = $this->_config; unset($dsn['username']); unset($dsn['password']); unset($dsn['options']); unset($dsn['charset']); unset($dsn['persistent']); unset($dsn['driver_options']); foreach ($dsn as $key => $val) { $dsn[$key] = "$key=$val"; } return $this->_pdoType . ':' . implode(';', $dsn); } protected function _connect() { if ($this->_connection) { return; } $dsn = $this->_dsn(); if (!extension_loaded('pdo')) { throw new Zend_Db_Adapter_Exception('The PDO extension is required for this adapter but the extension is not loaded'); } if (!in_array($this->_pdoType, PDO::getAvailableDrivers())) { throw new Zend_Db_Adapter_Exception('The ' . $this->_pdoType . ' driver is not currently installed'); } $q = $this->_profiler->queryStart('connect', Zend_Db_Profiler::CONNECT); if (isset($this->_config['persistent']) && ($this->_config['persistent'] == true)) { $this->_config['driver_options'][PDO::ATTR_PERSISTENT] = true; } try { $this->_connection = new PDO( $dsn, $this->_config['username'], $this->_config['password'], $this->_config['driver_options'] ); $this->_profiler->queryEnd($q); $this->_connection->setAttribute(PDO::ATTR_CASE, $this->_caseFolding); $this->_connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (PDOException $e) { throw new Zend_Db_Adapter_Exception($e->getMessage(), $e->getCode(), $e); } } public function isConnected() { return ((bool) ($this->_connection instanceof PDO)); } public function closeConnection() { $this->_connection = null; } public function prepare($sql) { $this->_connect(); $stmtClass = $this->_defaultStmtClass; if (!class_exists($stmtClass)) { Zend_Loader::loadClass($stmtClass); } $stmt = new $stmtClass($this, $sql); $stmt->setFetchMode($this->_fetchMode); return $stmt; } public function lastInsertId($tableName = null, $primaryKey = null) { $this->_connect(); return $this->_connection->lastInsertId(); } public function query($sql, $bind = array()) { if (empty($bind) && $sql instanceof Zend_Db_Select) { $bind = $sql->getBind(); } if (is_array($bind)) { foreach ($bind as $name => $value) { if (!is_int($name) && !preg_match('/^:/', $name)) { $newName = ":$name"; unset($bind[$name]); $bind[$newName] = $value; } } } try { return parent::query($sql, $bind); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function exec($sql) { if ($sql instanceof Zend_Db_Select) { $sql = $sql->assemble(); } try { $affected = $this->getConnection()->exec($sql); if ($affected === false) { $errorInfo = $this->getConnection()->errorInfo(); throw new Zend_Db_Adapter_Exception($errorInfo[2]); } return $affected; } catch (PDOException $e) { throw new Zend_Db_Adapter_Exception($e->getMessage(), $e->getCode(), $e); } } protected function _quote($value) { if (is_int($value) || is_float($value)) { return $value; } $this->_connect(); return $this->_connection->quote($value); } protected function _beginTransaction() { $this->_connect(); $this->_connection->beginTransaction(); } protected function _commit() { $this->_connect(); $this->_connection->commit(); } protected function _rollBack() { $this->_connect(); $this->_connection->rollBack(); } public function setFetchMode($mode) { if (!extension_loaded('pdo')) { throw new Zend_Db_Adapter_Exception('The PDO extension is required for this adapter but the extension is not loaded'); } switch ($mode) { case PDO::FETCH_LAZY: case PDO::FETCH_ASSOC: case PDO::FETCH_NUM: case PDO::FETCH_BOTH: case PDO::FETCH_NAMED: case PDO::FETCH_OBJ: $this->_fetchMode = $mode; break; default: throw new Zend_Db_Adapter_Exception("Invalid fetch mode '$mode' specified"); break; } } public function supportsParameters($type) { switch ($type) { case 'positional': case 'named': default: return true; } } public function getServerVersion() { $this->_connect(); try { $version = $this->_connection->getAttribute(PDO::ATTR_SERVER_VERSION); } catch (PDOException $e) { return null; } $matches = null; if (preg_match('/((?:[0-9]{1,2}\.){1,3}[0-9]{1,2})/', $version, $matches)) { return $matches[1]; } else { return null; } } } 

class Zend_Db_Adapter_Pdo_Mysql extends Zend_Db_Adapter_Pdo_Abstract { protected $_pdoType = 'mysql'; protected $_numericDataTypes = array( Zend_Db::INT_TYPE => Zend_Db::INT_TYPE, Zend_Db::BIGINT_TYPE => Zend_Db::BIGINT_TYPE, Zend_Db::FLOAT_TYPE => Zend_Db::FLOAT_TYPE, 'INT' => Zend_Db::INT_TYPE, 'INTEGER' => Zend_Db::INT_TYPE, 'MEDIUMINT' => Zend_Db::INT_TYPE, 'SMALLINT' => Zend_Db::INT_TYPE, 'TINYINT' => Zend_Db::INT_TYPE, 'BIGINT' => Zend_Db::BIGINT_TYPE, 'SERIAL' => Zend_Db::BIGINT_TYPE, 'DEC' => Zend_Db::FLOAT_TYPE, 'DECIMAL' => Zend_Db::FLOAT_TYPE, 'DOUBLE' => Zend_Db::FLOAT_TYPE, 'DOUBLE PRECISION' => Zend_Db::FLOAT_TYPE, 'FIXED' => Zend_Db::FLOAT_TYPE, 'FLOAT' => Zend_Db::FLOAT_TYPE ); protected function _dsn() { $dsn = parent::_dsn(); if (isset($this->_config['charset'])) { $dsn .= ';charset=' . $this->_config['charset']; } return $dsn; } protected function _connect() { if ($this->_connection) { return; } if (!empty($this->_config['charset'])) { $initCommand = "SET NAMES '" . $this->_config['charset'] . "'"; $this->_config['driver_options'][1002] = $initCommand; } parent::_connect(); } public function getQuoteIdentifierSymbol() { return "`"; } public function listTables() { return $this->fetchCol('SHOW TABLES'); } public function describeTable($tableName, $schemaName = null) { if ($schemaName) { $sql = 'DESCRIBE ' . $this->quoteIdentifier("$schemaName.$tableName", true); } else { $sql = 'DESCRIBE ' . $this->quoteIdentifier($tableName, true); } $stmt = $this->query($sql); $result = $stmt->fetchAll(Zend_Db::FETCH_NUM); $field = 0; $type = 1; $null = 2; $key = 3; $default = 4; $extra = 5; $desc = array(); $i = 1; $p = 1; foreach ($result as $row) { list($length, $scale, $precision, $unsigned, $primary, $primaryPosition, $identity) = array(null, null, null, null, false, null, false); if (preg_match('/unsigned/', $row[$type])) { $unsigned = true; } if (preg_match('/^((?:var)?char)\((\d+)\)/', $row[$type], $matches)) { $row[$type] = $matches[1]; $length = $matches[2]; } else if (preg_match('/^decimal\((\d+),(\d+)\)/', $row[$type], $matches)) { $row[$type] = 'decimal'; $precision = $matches[1]; $scale = $matches[2]; } else if (preg_match('/^float\((\d+),(\d+)\)/', $row[$type], $matches)) { $row[$type] = 'float'; $precision = $matches[1]; $scale = $matches[2]; } else if (preg_match('/^((?:big|medium|small|tiny)?int)\((\d+)\)/', $row[$type], $matches)) { $row[$type] = $matches[1]; } if (strtoupper($row[$key]) == 'PRI') { $primary = true; $primaryPosition = $p; if ($row[$extra] == 'auto_increment') { $identity = true; } else { $identity = false; } ++$p; } $desc[$this->foldCase($row[$field])] = array( 'SCHEMA_NAME' => null, 'TABLE_NAME' => $this->foldCase($tableName), 'COLUMN_NAME' => $this->foldCase($row[$field]), 'COLUMN_POSITION' => $i, 'DATA_TYPE' => $row[$type], 'DEFAULT' => $row[$default], 'NULLABLE' => (bool) ($row[$null] == 'YES'), 'LENGTH' => $length, 'SCALE' => $scale, 'PRECISION' => $precision, 'UNSIGNED' => $unsigned, 'PRIMARY' => $primary, 'PRIMARY_POSITION' => $primaryPosition, 'IDENTITY' => $identity ); ++$i; } return $desc; } public function limit($sql, $count, $offset = 0) { $count = intval($count); if ($count <= 0) { throw new Zend_Db_Adapter_Exception("LIMIT argument count=$count is not valid"); } $offset = intval($offset); if ($offset < 0) { throw new Zend_Db_Adapter_Exception("LIMIT argument offset=$offset is not valid"); } $sql .= " LIMIT $count"; if ($offset > 0) { $sql .= " OFFSET $offset"; } return $sql; } } 

class Zend_Db_Profiler { const CONNECT = 1; const QUERY = 2; const INSERT = 4; const UPDATE = 8; const DELETE = 16; const SELECT = 32; const TRANSACTION = 64; const STORED = 'stored'; const IGNORED = 'ignored'; protected $_queryProfiles = array(); protected $_enabled = false; protected $_filterElapsedSecs = null; protected $_filterTypes = null; public function __construct($enabled = false) { $this->setEnabled($enabled); } public function setEnabled($enable) { $this->_enabled = (boolean) $enable; return $this; } public function getEnabled() { return $this->_enabled; } public function setFilterElapsedSecs($minimumSeconds = null) { if (null === $minimumSeconds) { $this->_filterElapsedSecs = null; } else { $this->_filterElapsedSecs = (integer) $minimumSeconds; } return $this; } public function getFilterElapsedSecs() { return $this->_filterElapsedSecs; } public function setFilterQueryType($queryTypes = null) { $this->_filterTypes = $queryTypes; return $this; } public function getFilterQueryType() { return $this->_filterTypes; } public function clear() { $this->_queryProfiles = array(); return $this; } public function queryClone(Zend_Db_Profiler_Query $query) { $this->_queryProfiles[] = clone $query; end($this->_queryProfiles); return key($this->_queryProfiles); } public function queryStart($queryText, $queryType = null) { if (!$this->_enabled) { return null; } if (null === $queryType) { switch (strtolower(substr(ltrim($queryText), 0, 6))) { case 'insert': $queryType = self::INSERT; break; case 'update': $queryType = self::UPDATE; break; case 'delete': $queryType = self::DELETE; break; case 'select': $queryType = self::SELECT; break; default: $queryType = self::QUERY; break; } } $this->_queryProfiles[] = new Zend_Db_Profiler_Query($queryText, $queryType); end($this->_queryProfiles); return key($this->_queryProfiles); } public function queryEnd($queryId) { if (!$this->_enabled) { return self::IGNORED; } if (!isset($this->_queryProfiles[$queryId])) { throw new Zend_Db_Profiler_Exception("Profiler has no query with handle '$queryId'."); } $qp = $this->_queryProfiles[$queryId]; if ($qp->hasEnded()) { throw new Zend_Db_Profiler_Exception("Query with profiler handle '$queryId' has already ended."); } $qp->end(); if (null !== $this->_filterElapsedSecs && $qp->getElapsedSecs() < $this->_filterElapsedSecs) { unset($this->_queryProfiles[$queryId]); return self::IGNORED; } if (null !== $this->_filterTypes && !($qp->getQueryType() & $this->_filterTypes)) { unset($this->_queryProfiles[$queryId]); return self::IGNORED; } return self::STORED; } public function getQueryProfile($queryId) { if (!array_key_exists($queryId, $this->_queryProfiles)) { throw new Zend_Db_Profiler_Exception("Query handle '$queryId' not found in profiler log."); } return $this->_queryProfiles[$queryId]; } public function getQueryProfiles($queryType = null, $showUnfinished = false) { $queryProfiles = array(); foreach ($this->_queryProfiles as $key => $qp) { if ($queryType === null) { $condition = true; } else { $condition = ($qp->getQueryType() & $queryType); } if (($qp->hasEnded() || $showUnfinished) && $condition) { $queryProfiles[$key] = $qp; } } if (empty($queryProfiles)) { $queryProfiles = false; } return $queryProfiles; } public function getTotalElapsedSecs($queryType = null) { $elapsedSecs = 0; foreach ($this->_queryProfiles as $key => $qp) { if (null === $queryType) { $condition = true; } else { $condition = ($qp->getQueryType() & $queryType); } if (($qp->hasEnded()) && $condition) { $elapsedSecs += $qp->getElapsedSecs(); } } return $elapsedSecs; } public function getTotalNumQueries($queryType = null) { if (null === $queryType) { return count($this->_queryProfiles); } $numQueries = 0; foreach ($this->_queryProfiles as $qp) { if ($qp->hasEnded() && ($qp->getQueryType() & $queryType)) { $numQueries++; } } return $numQueries; } public function getLastQueryProfile() { if (empty($this->_queryProfiles)) { return false; } end($this->_queryProfiles); return current($this->_queryProfiles); } } 


class Zend_Exception extends Exception { private $_previous = null; public function __construct($msg = '', $code = 0, Exception $previous = null) { if (version_compare(PHP_VERSION, '5.3.0', '<')) { parent::__construct($msg, (int) $code); $this->_previous = $previous; } else { parent::__construct($msg, (int) $code, $previous); } } public function __call($method, array $args) { if ('getprevious' == strtolower($method)) { return $this->_getPrevious(); } return null; } public function __toString() { if (version_compare(PHP_VERSION, '5.3.0', '<')) { if (null !== ($e = $this->getPrevious())) { return $e->__toString() . "\n\nNext " . parent::__toString(); } } return parent::__toString(); } protected function _getPrevious() { return $this->_previous; } } 

class Zend_Db_Exception extends Zend_Exception { } 

class Zend_Db_Profiler_Exception extends Zend_Db_Exception { } 

class Zend_Db_Profiler_Query { protected $_query = ''; protected $_queryType = 0; protected $_startedMicrotime = null; protected $_endedMicrotime = null; protected $_boundParams = array(); public function __construct($query, $queryType) { $this->_query = $query; $this->_queryType = $queryType; $this->start(); } public function __clone() { $this->_boundParams = array(); $this->_endedMicrotime = null; $this->start(); } public function start() { $this->_startedMicrotime = microtime(true); } public function end() { $this->_endedMicrotime = microtime(true); } public function hasEnded() { return $this->_endedMicrotime !== null; } public function getQuery() { return $this->_query; } public function getQueryType() { return $this->_queryType; } public function bindParam($param, $variable) { $this->_boundParams[$param] = $variable; } public function bindParams(array $params) { if (array_key_exists(0, $params)) { array_unshift($params, null); unset($params[0]); } foreach ($params as $param => $value) { $this->bindParam($param, $value); } } public function getQueryParams() { return $this->_boundParams; } public function getElapsedSecs() { if (null === $this->_endedMicrotime) { return false; } return $this->_endedMicrotime - $this->_startedMicrotime; } public function getStartedMicrotime() { if(null === $this->_startedMicrotime) { return false; } return $this->_startedMicrotime; } } 

abstract class Zend_Db_Table_Abstract { const ADAPTER = 'db'; const DEFINITION = 'definition'; const DEFINITION_CONFIG_NAME = 'definitionConfigName'; const SCHEMA = 'schema'; const NAME = 'name'; const PRIMARY = 'primary'; const COLS = 'cols'; const METADATA = 'metadata'; const METADATA_CACHE = 'metadataCache'; const METADATA_CACHE_IN_CLASS = 'metadataCacheInClass'; const ROW_CLASS = 'rowClass'; const ROWSET_CLASS = 'rowsetClass'; const REFERENCE_MAP = 'referenceMap'; const DEPENDENT_TABLES = 'dependentTables'; const SEQUENCE = 'sequence'; const COLUMNS = 'columns'; const REF_TABLE_CLASS = 'refTableClass'; const REF_COLUMNS = 'refColumns'; const ON_DELETE = 'onDelete'; const ON_UPDATE = 'onUpdate'; const CASCADE = 'cascade'; const RESTRICT = 'restrict'; const SET_NULL = 'setNull'; const DEFAULT_NONE = 'defaultNone'; const DEFAULT_CLASS = 'defaultClass'; const DEFAULT_DB = 'defaultDb'; const SELECT_WITH_FROM_PART = true; const SELECT_WITHOUT_FROM_PART = false; protected static $_defaultDb; protected $_definition = null; protected $_definitionConfigName = null; protected static $_defaultMetadataCache = null; protected $_db; protected $_schema = null; protected $_name = null; protected $_cols; protected $_primary = null; protected $_identity = 1; protected $_sequence = true; protected $_metadata = array(); protected $_metadataCache = null; protected $_metadataCacheInClass = true; protected $_rowClass = 'Zend_Db_Table_Row'; protected $_rowsetClass = 'Zend_Db_Table_Rowset'; protected $_referenceMap = array(); protected $_dependentTables = array(); protected $_defaultSource = self::DEFAULT_NONE; protected $_defaultValues = array(); public function __construct($config = array()) { if (!is_array($config)) { $config = array(self::ADAPTER => $config); } if ($config) { $this->setOptions($config); } $this->_setup(); $this->init(); } public function setOptions(Array $options) { foreach ($options as $key => $value) { switch ($key) { case self::ADAPTER: $this->_setAdapter($value); break; case self::DEFINITION: $this->setDefinition($value); break; case self::DEFINITION_CONFIG_NAME: $this->setDefinitionConfigName($value); break; case self::SCHEMA: $this->_schema = (string) $value; break; case self::NAME: $this->_name = (string) $value; break; case self::PRIMARY: $this->_primary = (array) $value; break; case self::ROW_CLASS: $this->setRowClass($value); break; case self::ROWSET_CLASS: $this->setRowsetClass($value); break; case self::REFERENCE_MAP: $this->setReferences($value); break; case self::DEPENDENT_TABLES: $this->setDependentTables($value); break; case self::METADATA_CACHE: $this->_setMetadataCache($value); break; case self::METADATA_CACHE_IN_CLASS: $this->setMetadataCacheInClass($value); break; case self::SEQUENCE: $this->_setSequence($value); break; default: break; } } return $this; } public function setDefinition(Zend_Db_Table_Definition $definition) { $this->_definition = $definition; return $this; } public function getDefinition() { return $this->_definition; } public function setDefinitionConfigName($definitionConfigName) { $this->_definitionConfigName = $definitionConfigName; return $this; } public function getDefinitionConfigName() { return $this->_definitionConfigName; } public function setRowClass($classname) { $this->_rowClass = (string) $classname; return $this; } public function getRowClass() { return $this->_rowClass; } public function setRowsetClass($classname) { $this->_rowsetClass = (string) $classname; return $this; } public function getRowsetClass() { return $this->_rowsetClass; } public function addReference($ruleKey, $columns, $refTableClass, $refColumns, $onDelete = null, $onUpdate = null) { $reference = array(self::COLUMNS => (array) $columns, self::REF_TABLE_CLASS => $refTableClass, self::REF_COLUMNS => (array) $refColumns); if (!empty($onDelete)) { $reference[self::ON_DELETE] = $onDelete; } if (!empty($onUpdate)) { $reference[self::ON_UPDATE] = $onUpdate; } $this->_referenceMap[$ruleKey] = $reference; return $this; } public function setReferences(array $referenceMap) { $this->_referenceMap = $referenceMap; return $this; } public function getReference($tableClassname, $ruleKey = null) { $thisClass = get_class($this); if ($thisClass === 'Zend_Db_Table') { $thisClass = $this->_definitionConfigName; } $refMap = $this->_getReferenceMapNormalized(); if ($ruleKey !== null) { if (!isset($refMap[$ruleKey])) { throw new Zend_Db_Table_Exception("No reference rule \"$ruleKey\" from table $thisClass to table $tableClassname"); } if ($refMap[$ruleKey][self::REF_TABLE_CLASS] != $tableClassname) { throw new Zend_Db_Table_Exception("Reference rule \"$ruleKey\" does not reference table $tableClassname"); } return $refMap[$ruleKey]; } foreach ($refMap as $reference) { if ($reference[self::REF_TABLE_CLASS] == $tableClassname) { return $reference; } } throw new Zend_Db_Table_Exception("No reference from table $thisClass to table $tableClassname"); } public function setDependentTables(array $dependentTables) { $this->_dependentTables = $dependentTables; return $this; } public function getDependentTables() { return $this->_dependentTables; } public function setDefaultSource($defaultSource = self::DEFAULT_NONE) { if (!in_array($defaultSource, array(self::DEFAULT_CLASS, self::DEFAULT_DB, self::DEFAULT_NONE))) { $defaultSource = self::DEFAULT_NONE; } $this->_defaultSource = $defaultSource; return $this; } public function getDefaultSource() { return $this->_defaultSource; } public function setDefaultValues(Array $defaultValues) { foreach ($defaultValues as $defaultName => $defaultValue) { if (array_key_exists($defaultName, $this->_metadata)) { $this->_defaultValues[$defaultName] = $defaultValue; } } return $this; } public function getDefaultValues() { return $this->_defaultValues; } public static function setDefaultAdapter($db = null) { self::$_defaultDb = self::_setupAdapter($db); } public static function getDefaultAdapter() { return self::$_defaultDb; } protected function _setAdapter($db) { $this->_db = self::_setupAdapter($db); return $this; } public function getAdapter() { return $this->_db; } protected static function _setupAdapter($db) { if ($db === null) { return null; } if (is_string($db)) { $db = Zend_Registry::get($db); } if (!$db instanceof Zend_Db_Adapter_Abstract) { throw new Zend_Db_Table_Exception('Argument must be of type Zend_Db_Adapter_Abstract, or a Registry key where a Zend_Db_Adapter_Abstract object is stored'); } return $db; } public static function setDefaultMetadataCache($metadataCache = null) { self::$_defaultMetadataCache = self::_setupMetadataCache($metadataCache); } public static function getDefaultMetadataCache() { return self::$_defaultMetadataCache; } protected function _setMetadataCache($metadataCache) { $this->_metadataCache = self::_setupMetadataCache($metadataCache); return $this; } public function getMetadataCache() { return $this->_metadataCache; } public function setMetadataCacheInClass($flag) { $this->_metadataCacheInClass = (bool) $flag; return $this; } public function metadataCacheInClass() { return $this->_metadataCacheInClass; } protected static function _setupMetadataCache($metadataCache) { if ($metadataCache === null) { return null; } if (is_string($metadataCache)) { $metadataCache = Zend_Registry::get($metadataCache); } if (!$metadataCache instanceof Zend_Cache_Core) { throw new Zend_Db_Table_Exception('Argument must be of type Zend_Cache_Core, or a Registry key where a Zend_Cache_Core object is stored'); } return $metadataCache; } protected function _setSequence($sequence) { $this->_sequence = $sequence; return $this; } protected function _setup() { $this->_setupDatabaseAdapter(); $this->_setupTableName(); } protected function _setupDatabaseAdapter() { if (! $this->_db) { $this->_db = self::getDefaultAdapter(); if (!$this->_db instanceof Zend_Db_Adapter_Abstract) { throw new Zend_Db_Table_Exception('No adapter found for ' . get_class($this)); } } } protected function _setupTableName() { if (! $this->_name) { $this->_name = get_class($this); } else if (strpos($this->_name, '.')) { list($this->_schema, $this->_name) = explode('.', $this->_name); } } protected function _setupMetadata() { if ($this->metadataCacheInClass() && (count($this->_metadata) > 0)) { return true; } $isMetadataFromCache = true; if (null === $this->_metadataCache && null !== self::$_defaultMetadataCache) { $this->_setMetadataCache(self::$_defaultMetadataCache); } if (null !== $this->_metadataCache) { $dbConfig = $this->_db->getConfig(); $port = isset($dbConfig['options']['port']) ? ':'.$dbConfig['options']['port'] : (isset($dbConfig['port']) ? ':'.$dbConfig['port'] : null); $host = isset($dbConfig['options']['host']) ? ':'.$dbConfig['options']['host'] : (isset($dbConfig['host']) ? ':'.$dbConfig['host'] : null); $cacheId = md5( $port . $host . '/'. $dbConfig['dbname'] . ':' . $this->_schema. '.' . $this->_name ); } if (null === $this->_metadataCache || !($metadata = $this->_metadataCache->load($cacheId))) { $isMetadataFromCache = false; $metadata = $this->_db->describeTable($this->_name, $this->_schema); if (null !== $this->_metadataCache && !$this->_metadataCache->save($metadata, $cacheId)) { trigger_error('Failed saving metadata to metadataCache', E_USER_NOTICE); } } $this->_metadata = $metadata; return $isMetadataFromCache; } protected function _getCols() { if (null === $this->_cols) { $this->_setupMetadata(); $this->_cols = array_keys($this->_metadata); } return $this->_cols; } protected function _setupPrimaryKey() { if (!$this->_primary) { $this->_setupMetadata(); $this->_primary = array(); foreach ($this->_metadata as $col) { if ($col['PRIMARY']) { $this->_primary[ $col['PRIMARY_POSITION'] ] = $col['COLUMN_NAME']; if ($col['IDENTITY']) { $this->_identity = $col['PRIMARY_POSITION']; } } } if (empty($this->_primary)) { throw new Zend_Db_Table_Exception('A table must have a primary key, but none was found'); } } else if (!is_array($this->_primary)) { $this->_primary = array(1 => $this->_primary); } else if (isset($this->_primary[0])) { array_unshift($this->_primary, null); unset($this->_primary[0]); } $cols = $this->_getCols(); if (! array_intersect((array) $this->_primary, $cols) == (array) $this->_primary) { throw new Zend_Db_Table_Exception("Primary key column(s) (" . implode(',', (array) $this->_primary) . ") are not columns in this table (" . implode(',', $cols) . ")"); } $primary = (array) $this->_primary; $pkIdentity = $primary[(int) $this->_identity]; if ($this->_sequence === true && $this->_db instanceof Zend_Db_Adapter_Pdo_Pgsql) { $this->_sequence = $this->_db->quoteIdentifier("{$this->_name}_{$pkIdentity}_seq"); if ($this->_schema) { $this->_sequence = $this->_db->quoteIdentifier($this->_schema) . '.' . $this->_sequence; } } } protected function _getReferenceMapNormalized() { $referenceMapNormalized = array(); foreach ($this->_referenceMap as $rule => $map) { $referenceMapNormalized[$rule] = array(); foreach ($map as $key => $value) { switch ($key) { case self::COLUMNS: case self::REF_COLUMNS: if (!is_array($value)) { $referenceMapNormalized[$rule][$key] = array($value); } else { $referenceMapNormalized[$rule][$key] = $value; } break; default: $referenceMapNormalized[$rule][$key] = $value; break; } } } return $referenceMapNormalized; } public function init() { } public function info($key = null) { $this->_setupPrimaryKey(); $info = array( self::SCHEMA => $this->_schema, self::NAME => $this->_name, self::COLS => $this->_getCols(), self::PRIMARY => (array) $this->_primary, self::METADATA => $this->_metadata, self::ROW_CLASS => $this->getRowClass(), self::ROWSET_CLASS => $this->getRowsetClass(), self::REFERENCE_MAP => $this->_referenceMap, self::DEPENDENT_TABLES => $this->_dependentTables, self::SEQUENCE => $this->_sequence ); if ($key === null) { return $info; } if (!array_key_exists($key, $info)) { throw new Zend_Db_Table_Exception('There is no table information for the key "' . $key . '"'); } return $info[$key]; } public function select($withFromPart = self::SELECT_WITHOUT_FROM_PART) { $select = new Zend_Db_Table_Select($this); if ($withFromPart == self::SELECT_WITH_FROM_PART) { $select->from($this->info(self::NAME), Zend_Db_Table_Select::SQL_WILDCARD, $this->info(self::SCHEMA)); } return $select; } public function insert(array $data) { $this->_setupPrimaryKey(); $primary = (array) $this->_primary; $pkIdentity = $primary[(int)$this->_identity]; if (is_string($this->_sequence) && !isset($data[$pkIdentity])) { $data[$pkIdentity] = $this->_db->nextSequenceId($this->_sequence); $pkSuppliedBySequence = true; } if (!isset($pkSuppliedBySequence) && array_key_exists($pkIdentity, $data)) { if ($data[$pkIdentity] === null || $data[$pkIdentity] === '' || is_bool($data[$pkIdentity]) || (is_array($data[$pkIdentity]) && empty($data[$pkIdentity]))) { unset($data[$pkIdentity]); } } $tableSpec = ($this->_schema ? $this->_schema . '.' : '') . $this->_name; $this->_db->insert($tableSpec, $data); if ($this->_sequence === true && !isset($data[$pkIdentity])) { $data[$pkIdentity] = $this->_db->lastInsertId(); } $pkData = array_intersect_key($data, array_flip($primary)); if (count($primary) == 1) { reset($pkData); return current($pkData); } return $pkData; } public function isIdentity($column) { $this->_setupPrimaryKey(); if (!isset($this->_metadata[$column])) { throw new Zend_Db_Table_Exception('Column "' . $column . '" not found in table.'); } return (bool) $this->_metadata[$column]['IDENTITY']; } public function update(array $data, $where) { $tableSpec = ($this->_schema ? $this->_schema . '.' : '') . $this->_name; return $this->_db->update($tableSpec, $data, $where); } public function _cascadeUpdate($parentTableClassname, array $oldPrimaryKey, array $newPrimaryKey) { $this->_setupMetadata(); $rowsAffected = 0; foreach ($this->_getReferenceMapNormalized() as $map) { if ($map[self::REF_TABLE_CLASS] == $parentTableClassname && isset($map[self::ON_UPDATE])) { switch ($map[self::ON_UPDATE]) { case self::CASCADE: $newRefs = array(); $where = array(); for ($i = 0; $i < count($map[self::COLUMNS]); ++$i) { $col = $this->_db->foldCase($map[self::COLUMNS][$i]); $refCol = $this->_db->foldCase($map[self::REF_COLUMNS][$i]); if (array_key_exists($refCol, $newPrimaryKey)) { $newRefs[$col] = $newPrimaryKey[$refCol]; } $type = $this->_metadata[$col]['DATA_TYPE']; $where[] = $this->_db->quoteInto( $this->_db->quoteIdentifier($col, true) . ' = ?', $oldPrimaryKey[$refCol], $type); } $rowsAffected += $this->update($newRefs, $where); break; default: break; } } } return $rowsAffected; } public function delete($where) { $tableSpec = ($this->_schema ? $this->_schema . '.' : '') . $this->_name; return $this->_db->delete($tableSpec, $where); } public function _cascadeDelete($parentTableClassname, array $primaryKey) { $this->_setupMetadata(); $rowsAffected = 0; foreach ($this->_getReferenceMapNormalized() as $map) { if ($map[self::REF_TABLE_CLASS] == $parentTableClassname && isset($map[self::ON_DELETE])) { switch ($map[self::ON_DELETE]) { case self::CASCADE: $where = array(); for ($i = 0; $i < count($map[self::COLUMNS]); ++$i) { $col = $this->_db->foldCase($map[self::COLUMNS][$i]); $refCol = $this->_db->foldCase($map[self::REF_COLUMNS][$i]); $type = $this->_metadata[$col]['DATA_TYPE']; $where[] = $this->_db->quoteInto( $this->_db->quoteIdentifier($col, true) . ' = ?', $primaryKey[$refCol], $type); } $rowsAffected += $this->delete($where); break; default: break; } } } return $rowsAffected; } public function find() { $this->_setupPrimaryKey(); $args = func_get_args(); $keyNames = array_values((array) $this->_primary); if (count($args) < count($keyNames)) { throw new Zend_Db_Table_Exception("Too few columns for the primary key"); } if (count($args) > count($keyNames)) { throw new Zend_Db_Table_Exception("Too many columns for the primary key"); } $whereList = array(); $numberTerms = 0; foreach ($args as $keyPosition => $keyValues) { $keyValuesCount = count($keyValues); if (!is_array($keyValues)) { $keyValues = array($keyValues); } if ($numberTerms == 0) { $numberTerms = $keyValuesCount; } else if ($keyValuesCount != $numberTerms) { throw new Zend_Db_Table_Exception("Missing value(s) for the primary key"); } $keyValues = array_values($keyValues); for ($i = 0; $i < $keyValuesCount; ++$i) { if (!isset($whereList[$i])) { $whereList[$i] = array(); } $whereList[$i][$keyPosition] = $keyValues[$i]; } } $whereClause = null; if (count($whereList)) { $whereOrTerms = array(); $tableName = $this->_db->quoteTableAs($this->_name, null, true); foreach ($whereList as $keyValueSets) { $whereAndTerms = array(); foreach ($keyValueSets as $keyPosition => $keyValue) { $type = $this->_metadata[$keyNames[$keyPosition]]['DATA_TYPE']; $columnName = $this->_db->quoteIdentifier($keyNames[$keyPosition], true); $whereAndTerms[] = $this->_db->quoteInto( $tableName . '.' . $columnName . ' = ?', $keyValue, $type); } $whereOrTerms[] = '(' . implode(' AND ', $whereAndTerms) . ')'; } $whereClause = '(' . implode(' OR ', $whereOrTerms) . ')'; } if ($whereClause == null) { $rowsetClass = $this->getRowsetClass(); if (!class_exists($rowsetClass)) { Zend_Loader::loadClass($rowsetClass); } return new $rowsetClass(array('table' => $this, 'rowClass' => $this->getRowClass(), 'stored' => true)); } return $this->fetchAll($whereClause); } public function fetchAll($where = null, $order = null, $count = null, $offset = null) { if (!($where instanceof Zend_Db_Table_Select)) { $select = $this->select(); if ($where !== null) { $this->_where($select, $where); } if ($order !== null) { $this->_order($select, $order); } if ($count !== null || $offset !== null) { $select->limit($count, $offset); } } else { $select = $where; } $rows = $this->_fetch($select); $data = array( 'table' => $this, 'data' => $rows, 'readOnly' => $select->isReadOnly(), 'rowClass' => $this->getRowClass(), 'stored' => true ); $rowsetClass = $this->getRowsetClass(); if (!class_exists($rowsetClass)) { Zend_Loader::loadClass($rowsetClass); } return new $rowsetClass($data); } public function fetchRow($where = null, $order = null, $offset = null) { if (!($where instanceof Zend_Db_Table_Select)) { $select = $this->select(); if ($where !== null) { $this->_where($select, $where); } if ($order !== null) { $this->_order($select, $order); } $select->limit(1, ((is_numeric($offset)) ? (int) $offset : null)); } else { $select = $where->limit(1, $where->getPart(Zend_Db_Select::LIMIT_OFFSET)); } $rows = $this->_fetch($select); if (count($rows) == 0) { return null; } $data = array( 'table' => $this, 'data' => $rows[0], 'readOnly' => $select->isReadOnly(), 'stored' => true ); $rowClass = $this->getRowClass(); if (!class_exists($rowClass)) { Zend_Loader::loadClass($rowClass); } return new $rowClass($data); } public function fetchNew() { return $this->createRow(); } public function createRow(array $data = array(), $defaultSource = null) { $cols = $this->_getCols(); $defaults = array_combine($cols, array_fill(0, count($cols), null)); if ($defaultSource == null) { $defaultSource = $this->_defaultSource; } if (!in_array($defaultSource, array(self::DEFAULT_CLASS, self::DEFAULT_DB, self::DEFAULT_NONE))) { $defaultSource = self::DEFAULT_NONE; } if ($defaultSource == self::DEFAULT_DB) { foreach ($this->_metadata as $metadataName => $metadata) { if (($metadata['DEFAULT'] != null) && ($metadata['NULLABLE'] !== true || ($metadata['NULLABLE'] === true && isset($this->_defaultValues[$metadataName]) && $this->_defaultValues[$metadataName] === true)) && (!(isset($this->_defaultValues[$metadataName]) && $this->_defaultValues[$metadataName] === false))) { $defaults[$metadataName] = $metadata['DEFAULT']; } } } elseif ($defaultSource == self::DEFAULT_CLASS && $this->_defaultValues) { foreach ($this->_defaultValues as $defaultName => $defaultValue) { if (array_key_exists($defaultName, $defaults)) { $defaults[$defaultName] = $defaultValue; } } } $config = array( 'table' => $this, 'data' => $defaults, 'readOnly' => false, 'stored' => false ); $rowClass = $this->getRowClass(); if (!class_exists($rowClass)) { Zend_Loader::loadClass($rowClass); } $row = new $rowClass($config); $row->setFromArray($data); return $row; } protected function _where(Zend_Db_Table_Select $select, $where) { $where = (array) $where; foreach ($where as $key => $val) { if (is_int($key)) { $select->where($val); } else { $select->where($key, $val); } } return $select; } protected function _order(Zend_Db_Table_Select $select, $order) { if (!is_array($order)) { $order = array($order); } foreach ($order as $val) { $select->order($val); } return $select; } protected function _fetch(Zend_Db_Table_Select $select) { $stmt = $this->_db->query($select); $data = $stmt->fetchAll(Zend_Db::FETCH_ASSOC); return $data; } } 

class Zend_Db_Table extends Zend_Db_Table_Abstract { public function __construct($config = array(), $definition = null) { if ($definition !== null && is_array($definition)) { $definition = new Zend_Db_Table_Definition($definition); } if (is_string($config)) { if (Zend_Registry::isRegistered($config)) { trigger_error(__CLASS__ . '::' . __METHOD__ . '(\'registryName\') is not valid usage of Zend_Db_Table, ' . 'try extending Zend_Db_Table_Abstract in your extending classes.', E_USER_NOTICE ); $config = array(self::ADAPTER => $config); } else { if ($definition instanceof Zend_Db_Table_Definition && $definition->hasTableConfig($config)) { $config = $definition->getTableConfig($config); } else { $config = array(self::NAME => $config); } } } parent::__construct($config); } } 

class Zend_Db_Table_Definition { protected $_tableConfigs = array(); public function __construct($options = null) { if ($options instanceof Zend_Config) { $this->setConfig($options); } elseif (is_array($options)) { $this->setOptions($options); } } public function setConfig(Zend_Config $config) { $this->setOptions($config->toArray()); return $this; } public function setOptions(Array $options) { foreach ($options as $optionName => $optionValue) { $this->setTableConfig($optionName, $optionValue); } return $this; } public function setTableConfig($tableName, array $tableConfig) { $tableConfig[Zend_Db_Table::DEFINITION_CONFIG_NAME] = $tableName; $tableConfig[Zend_Db_Table::DEFINITION] = $this; if (!isset($tableConfig[Zend_Db_Table::NAME])) { $tableConfig[Zend_Db_Table::NAME] = $tableName; } $this->_tableConfigs[$tableName] = $tableConfig; return $this; } public function getTableConfig($tableName) { return $this->_tableConfigs[$tableName]; } public function removeTableConfig($tableName) { unset($this->_tableConfigs[$tableName]); } public function hasTableConfig($tableName) { return (isset($this->_tableConfigs[$tableName])); } } 

class Zend_Db_Table_Exception extends Zend_Db_Exception { } 



abstract class Zend_Db_Table_Row_Abstract implements ArrayAccess, IteratorAggregate { protected $_data = array(); protected $_cleanData = array(); protected $_modifiedFields = array(); protected $_table = null; protected $_connected = true; protected $_readOnly = false; protected $_tableClass = null; protected $_primary; public function __construct(array $config = array()) { if (isset($config['table']) && $config['table'] instanceof Zend_Db_Table_Abstract) { $this->_table = $config['table']; $this->_tableClass = get_class($this->_table); } elseif ($this->_tableClass !== null) { $this->_table = $this->_getTableFromString($this->_tableClass); } if (isset($config['data'])) { if (!is_array($config['data'])) { throw new Zend_Db_Table_Row_Exception('Data must be an array'); } $this->_data = $config['data']; } if (isset($config['stored']) && $config['stored'] === true) { $this->_cleanData = $this->_data; } if (isset($config['readOnly']) && $config['readOnly'] === true) { $this->setReadOnly(true); } if (($table = $this->_getTable())) { $info = $table->info(); $this->_primary = (array) $info['primary']; } $this->init(); } protected function _transformColumn($columnName) { if (!is_string($columnName)) { throw new Zend_Db_Table_Row_Exception('Specified column is not a string'); } return $columnName; } public function __get($columnName) { $columnName = $this->_transformColumn($columnName); if (!array_key_exists($columnName, $this->_data)) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is not in the row"); } return $this->_data[$columnName]; } public function __set($columnName, $value) { $columnName = $this->_transformColumn($columnName); if (!array_key_exists($columnName, $this->_data)) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is not in the row"); } $this->_data[$columnName] = $value; $this->_modifiedFields[$columnName] = true; } public function __unset($columnName) { $columnName = $this->_transformColumn($columnName); if (!array_key_exists($columnName, $this->_data)) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is not in the row"); } if ($this->isConnected() && in_array($columnName, $this->_table->info('primary'))) { throw new Zend_Db_Table_Row_Exception("Specified column \"$columnName\" is a primary key and should not be unset"); } unset($this->_data[$columnName]); return $this; } public function __isset($columnName) { $columnName = $this->_transformColumn($columnName); return array_key_exists($columnName, $this->_data); } public function __sleep() { return array('_tableClass', '_primary', '_data', '_cleanData', '_readOnly' ,'_modifiedFields'); } public function __wakeup() { $this->_connected = false; } public function offsetExists($offset) { return $this->__isset($offset); } public function offsetGet($offset) { return $this->__get($offset); } public function offsetSet($offset, $value) { $this->__set($offset, $value); } public function offsetUnset($offset) { return $this->__unset($offset); } public function init() { } public function getTable() { return $this->_table; } public function setTable(Zend_Db_Table_Abstract $table = null) { if ($table == null) { $this->_table = null; $this->_connected = false; return false; } $tableClass = get_class($table); if (! $table instanceof $this->_tableClass) { throw new Zend_Db_Table_Row_Exception("The specified Table is of class $tableClass, expecting class to be instance of $this->_tableClass"); } $this->_table = $table; $this->_tableClass = $tableClass; $info = $this->_table->info(); if ($info['cols'] != array_keys($this->_data)) { throw new Zend_Db_Table_Row_Exception('The specified Table does not have the same columns as the Row'); } if (! array_intersect((array) $this->_primary, $info['primary']) == (array) $this->_primary) { throw new Zend_Db_Table_Row_Exception("The specified Table '$tableClass' does not have the same primary key as the Row"); } $this->_connected = true; return true; } public function getTableClass() { return $this->_tableClass; } public function isConnected() { return $this->_connected; } public function isReadOnly() { return $this->_readOnly; } public function setReadOnly($flag) { $this->_readOnly = (bool) $flag; } public function select() { return $this->getTable()->select(); } public function save() { if (empty($this->_cleanData)) { return $this->_doInsert(); } else { return $this->_doUpdate(); } } protected function _doInsert() { if ($this->_readOnly === true) { throw new Zend_Db_Table_Row_Exception('This row has been marked read-only'); } $this->_insert(); $data = array_intersect_key($this->_data, $this->_modifiedFields); $primaryKey = $this->_getTable()->insert($data); if (is_array($primaryKey)) { $newPrimaryKey = $primaryKey; } else { $tempPrimaryKey = (array) $this->_primary; $newPrimaryKey = array(current($tempPrimaryKey) => $primaryKey); } $this->_data = array_merge($this->_data, $newPrimaryKey); $this->_postInsert(); $this->_refresh(); return $primaryKey; } protected function _doUpdate() { if ($this->_readOnly === true) { throw new Zend_Db_Table_Row_Exception('This row has been marked read-only'); } $where = $this->_getWhereQuery(false); $this->_update(); $diffData = array_intersect_key($this->_data, $this->_modifiedFields); $pkDiffData = array_intersect_key($diffData, array_flip((array)$this->_primary)); if (count($pkDiffData) > 0) { $depTables = $this->_getTable()->getDependentTables(); if (!empty($depTables)) { $pkNew = $this->_getPrimaryKey(true); $pkOld = $this->_getPrimaryKey(false); foreach ($depTables as $tableClass) { $t = $this->_getTableFromString($tableClass); $t->_cascadeUpdate($this->getTableClass(), $pkOld, $pkNew); } } } if (count($diffData) > 0) { $this->_getTable()->update($diffData, $where); } $this->_postUpdate(); $this->_refresh(); $primaryKey = $this->_getPrimaryKey(true); if (count($primaryKey) == 1) { return current($primaryKey); } return $primaryKey; } public function delete() { if ($this->_readOnly === true) { throw new Zend_Db_Table_Row_Exception('This row has been marked read-only'); } $where = $this->_getWhereQuery(); $this->_delete(); $depTables = $this->_getTable()->getDependentTables(); if (!empty($depTables)) { $pk = $this->_getPrimaryKey(); foreach ($depTables as $tableClass) { $t = $this->_getTableFromString($tableClass); $t->_cascadeDelete($this->getTableClass(), $pk); } } $result = $this->_getTable()->delete($where); $this->_postDelete(); $this->_data = array_combine( array_keys($this->_data), array_fill(0, count($this->_data), null) ); return $result; } public function getIterator() { return new ArrayIterator((array) $this->_data); } public function toArray() { return (array)$this->_data; } public function setFromArray(array $data) { $data = array_intersect_key($data, $this->_data); foreach ($data as $columnName => $value) { $this->__set($columnName, $value); } return $this; } public function refresh() { return $this->_refresh(); } protected function _getTable() { if (!$this->_connected) { throw new Zend_Db_Table_Row_Exception('Cannot save a Row unless it is connected'); } return $this->_table; } protected function _getPrimaryKey($useDirty = true) { if (!is_array($this->_primary)) { throw new Zend_Db_Table_Row_Exception("The primary key must be set as an array"); } $primary = array_flip($this->_primary); if ($useDirty) { $array = array_intersect_key($this->_data, $primary); } else { $array = array_intersect_key($this->_cleanData, $primary); } if (count($primary) != count($array)) { throw new Zend_Db_Table_Row_Exception("The specified Table '$this->_tableClass' does not have the same primary key as the Row"); } return $array; } protected function _getWhereQuery($useDirty = true) { $where = array(); $db = $this->_getTable()->getAdapter(); $primaryKey = $this->_getPrimaryKey($useDirty); $info = $this->_getTable()->info(); $metadata = $info[Zend_Db_Table_Abstract::METADATA]; $where = array(); foreach ($primaryKey as $column => $value) { $tableName = $db->quoteIdentifier($info[Zend_Db_Table_Abstract::NAME], true); $type = $metadata[$column]['DATA_TYPE']; $columnName = $db->quoteIdentifier($column, true); $where[] = $db->quoteInto("{$tableName}.{$columnName} = ?", $value, $type); } return $where; } protected function _refresh() { $where = $this->_getWhereQuery(); $row = $this->_getTable()->fetchRow($where); if (null === $row) { throw new Zend_Db_Table_Row_Exception('Cannot refresh row as parent is missing'); } $this->_data = $row->toArray(); $this->_cleanData = $this->_data; $this->_modifiedFields = array(); } protected function _insert() { } protected function _postInsert() { } protected function _update() { } protected function _postUpdate() { } protected function _delete() { } protected function _postDelete() { } protected function _prepareReference(Zend_Db_Table_Abstract $dependentTable, Zend_Db_Table_Abstract $parentTable, $ruleKey) { $parentTableName = (get_class($parentTable) === 'Zend_Db_Table') ? $parentTable->getDefinitionConfigName() : get_class($parentTable); $map = $dependentTable->getReference($parentTableName, $ruleKey); if (!isset($map[Zend_Db_Table_Abstract::REF_COLUMNS])) { $parentInfo = $parentTable->info(); $map[Zend_Db_Table_Abstract::REF_COLUMNS] = array_values((array) $parentInfo['primary']); } $map[Zend_Db_Table_Abstract::COLUMNS] = (array) $map[Zend_Db_Table_Abstract::COLUMNS]; $map[Zend_Db_Table_Abstract::REF_COLUMNS] = (array) $map[Zend_Db_Table_Abstract::REF_COLUMNS]; return $map; } public function findDependentRowset($dependentTable, $ruleKey = null, Zend_Db_Table_Select $select = null) { $db = $this->_getTable()->getAdapter(); if (is_string($dependentTable)) { $dependentTable = $this->_getTableFromString($dependentTable); } if (!$dependentTable instanceof Zend_Db_Table_Abstract) { $type = gettype($dependentTable); if ($type == 'object') { $type = get_class($dependentTable); } throw new Zend_Db_Table_Row_Exception("Dependent table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($dependentTable->getDefinition() == null)) { $dependentTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if ($select === null) { $select = $dependentTable->select(); } else { $select->setTable($dependentTable); } $map = $this->_prepareReference($dependentTable, $this->_getTable(), $ruleKey); for ($i = 0; $i < count($map[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $parentColumnName = $db->foldCase($map[Zend_Db_Table_Abstract::REF_COLUMNS][$i]); $value = $this->_data[$parentColumnName]; $dependentDb = $dependentTable->getAdapter(); $dependentColumnName = $dependentDb->foldCase($map[Zend_Db_Table_Abstract::COLUMNS][$i]); $dependentColumn = $dependentDb->quoteIdentifier($dependentColumnName, true); $dependentInfo = $dependentTable->info(); $type = $dependentInfo[Zend_Db_Table_Abstract::METADATA][$dependentColumnName]['DATA_TYPE']; $select->where("$dependentColumn = ?", $value, $type); } return $dependentTable->fetchAll($select); } public function findParentRow($parentTable, $ruleKey = null, Zend_Db_Table_Select $select = null) { $db = $this->_getTable()->getAdapter(); if (is_string($parentTable)) { $parentTable = $this->_getTableFromString($parentTable); } if (!$parentTable instanceof Zend_Db_Table_Abstract) { $type = gettype($parentTable); if ($type == 'object') { $type = get_class($parentTable); } throw new Zend_Db_Table_Row_Exception("Parent table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($parentTable->getDefinition() == null)) { $parentTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if ($select === null) { $select = $parentTable->select(); } else { $select->setTable($parentTable); } $map = $this->_prepareReference($this->_getTable(), $parentTable, $ruleKey); for ($i = 0; $i < count($map[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $dependentColumnName = $db->foldCase($map[Zend_Db_Table_Abstract::COLUMNS][$i]); $value = $this->_data[$dependentColumnName]; $parentDb = $parentTable->getAdapter(); $parentColumnName = $parentDb->foldCase($map[Zend_Db_Table_Abstract::REF_COLUMNS][$i]); $parentColumn = $parentDb->quoteIdentifier($parentColumnName, true); $parentInfo = $parentTable->info(); $type = $parentInfo[Zend_Db_Table_Abstract::METADATA][$parentColumnName]['DATA_TYPE']; $nullable = $parentInfo[Zend_Db_Table_Abstract::METADATA][$parentColumnName]['NULLABLE']; if ($value === null && $nullable == true) { $select->where("$parentColumn IS NULL"); } elseif ($value === null && $nullable == false) { return null; } else { $select->where("$parentColumn = ?", $value, $type); } } return $parentTable->fetchRow($select); } public function findManyToManyRowset($matchTable, $intersectionTable, $callerRefRule = null, $matchRefRule = null, Zend_Db_Table_Select $select = null) { $db = $this->_getTable()->getAdapter(); if (is_string($intersectionTable)) { $intersectionTable = $this->_getTableFromString($intersectionTable); } if (!$intersectionTable instanceof Zend_Db_Table_Abstract) { $type = gettype($intersectionTable); if ($type == 'object') { $type = get_class($intersectionTable); } throw new Zend_Db_Table_Row_Exception("Intersection table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($intersectionTable->getDefinition() == null)) { $intersectionTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if (is_string($matchTable)) { $matchTable = $this->_getTableFromString($matchTable); } if (! $matchTable instanceof Zend_Db_Table_Abstract) { $type = gettype($matchTable); if ($type == 'object') { $type = get_class($matchTable); } throw new Zend_Db_Table_Row_Exception("Match table must be a Zend_Db_Table_Abstract, but it is $type"); } if (($tableDefinition = $this->_table->getDefinition()) !== null && ($matchTable->getDefinition() == null)) { $matchTable->setOptions(array(Zend_Db_Table_Abstract::DEFINITION => $tableDefinition)); } if ($select === null) { $select = $matchTable->select(); } else { $select->setTable($matchTable); } $interInfo = $intersectionTable->info(); $interDb = $intersectionTable->getAdapter(); $interName = $interInfo['name']; $interSchema = isset($interInfo['schema']) ? $interInfo['schema'] : null; $matchInfo = $matchTable->info(); $matchName = $matchInfo['name']; $matchSchema = isset($matchInfo['schema']) ? $matchInfo['schema'] : null; $matchMap = $this->_prepareReference($intersectionTable, $matchTable, $matchRefRule); for ($i = 0; $i < count($matchMap[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $interCol = $interDb->quoteIdentifier('i' . '.' . $matchMap[Zend_Db_Table_Abstract::COLUMNS][$i], true); $matchCol = $interDb->quoteIdentifier('m' . '.' . $matchMap[Zend_Db_Table_Abstract::REF_COLUMNS][$i], true); $joinCond[] = "$interCol = $matchCol"; } $joinCond = implode(' AND ', $joinCond); $select->from(array('i' => $interName), array(), $interSchema) ->joinInner(array('m' => $matchName), $joinCond, Zend_Db_Select::SQL_WILDCARD, $matchSchema) ->setIntegrityCheck(false); $callerMap = $this->_prepareReference($intersectionTable, $this->_getTable(), $callerRefRule); for ($i = 0; $i < count($callerMap[Zend_Db_Table_Abstract::COLUMNS]); ++$i) { $callerColumnName = $db->foldCase($callerMap[Zend_Db_Table_Abstract::REF_COLUMNS][$i]); $value = $this->_data[$callerColumnName]; $interColumnName = $interDb->foldCase($callerMap[Zend_Db_Table_Abstract::COLUMNS][$i]); $interCol = $interDb->quoteIdentifier("i.$interColumnName", true); $interInfo = $intersectionTable->info(); $type = $interInfo[Zend_Db_Table_Abstract::METADATA][$interColumnName]['DATA_TYPE']; $select->where($interDb->quoteInto("$interCol = ?", $value, $type)); } $stmt = $select->query(); $config = array( 'table' => $matchTable, 'data' => $stmt->fetchAll(Zend_Db::FETCH_ASSOC), 'rowClass' => $matchTable->getRowClass(), 'readOnly' => false, 'stored' => true ); $rowsetClass = $matchTable->getRowsetClass(); if (!class_exists($rowsetClass)) { try { Zend_Loader::loadClass($rowsetClass); } catch (Zend_Exception $e) { throw new Zend_Db_Table_Row_Exception($e->getMessage(), $e->getCode(), $e); } } $rowset = new $rowsetClass($config); return $rowset; } public function __call($method, array $args) { $matches = array(); if (count($args) && $args[0] instanceof Zend_Db_Table_Select) { $select = $args[0]; } else { $select = null; } if (preg_match('/^findParent(\w+?)(?:By(\w+))?$/', $method, $matches)) { $class = $matches[1]; $ruleKey1 = isset($matches[2]) ? $matches[2] : null; return $this->findParentRow($class, $ruleKey1, $select); } if (preg_match('/^find(\w+?)Via(\w+?)(?:By(\w+?)(?:And(\w+))?)?$/', $method, $matches)) { $class = $matches[1]; $viaClass = $matches[2]; $ruleKey1 = isset($matches[3]) ? $matches[3] : null; $ruleKey2 = isset($matches[4]) ? $matches[4] : null; return $this->findManyToManyRowset($class, $viaClass, $ruleKey1, $ruleKey2, $select); } if (preg_match('/^find(\w+?)(?:By(\w+))?$/', $method, $matches)) { $class = $matches[1]; $ruleKey1 = isset($matches[2]) ? $matches[2] : null; return $this->findDependentRowset($class, $ruleKey1, $select); } throw new Zend_Db_Table_Row_Exception("Unrecognized method '$method()'"); } protected function _getTableFromString($tableName) { if ($this->_table instanceof Zend_Db_Table_Abstract) { $tableDefinition = $this->_table->getDefinition(); if ($tableDefinition !== null && $tableDefinition->hasTableConfig($tableName)) { return new Zend_Db_Table($tableName, $tableDefinition); } } if (!class_exists($tableName)) { try { Zend_Loader::loadClass($tableName); } catch (Zend_Exception $e) { throw new Zend_Db_Table_Row_Exception($e->getMessage(), $e->getCode(), $e); } } $options = array(); if (($table = $this->_getTable())) { $options['db'] = $table->getAdapter(); } if (isset($tableDefinition) && $tableDefinition !== null) { $options[Zend_Db_Table_Abstract::DEFINITION] = $tableDefinition; } return new $tableName($options); } } 

class Zend_Db_Table_Row extends Zend_Db_Table_Row_Abstract { } 

class Zend_Db_Table_Row_Exception extends Zend_Db_Table_Exception { } 



abstract class Zend_Db_Table_Rowset_Abstract implements SeekableIterator, Countable, ArrayAccess { protected $_data = array(); protected $_table; protected $_connected = true; protected $_tableClass; protected $_rowClass = 'Zend_Db_Table_Row'; protected $_pointer = 0; protected $_count; protected $_rows = array(); protected $_stored = false; protected $_readOnly = false; public function __construct(array $config) { if (isset($config['table'])) { $this->_table = $config['table']; $this->_tableClass = get_class($this->_table); } if (isset($config['rowClass'])) { $this->_rowClass = $config['rowClass']; } if (!class_exists($this->_rowClass)) { Zend_Loader::loadClass($this->_rowClass); } if (isset($config['data'])) { $this->_data = $config['data']; } if (isset($config['readOnly'])) { $this->_readOnly = $config['readOnly']; } if (isset($config['stored'])) { $this->_stored = $config['stored']; } $this->_count = count($this->_data); $this->init(); } public function __sleep() { return array('_data', '_tableClass', '_rowClass', '_pointer', '_count', '_rows', '_stored', '_readOnly'); } public function __wakeup() { $this->_connected = false; } public function init() { } public function isConnected() { return $this->_connected; } public function getTable() { return $this->_table; } public function setTable(Zend_Db_Table_Abstract $table) { $this->_table = $table; $this->_connected = false; foreach ($this as $row) { $connected = $row->setTable($table); if ($connected == true) { $this->_connected = true; } } return $this->_connected; } public function getTableClass() { return $this->_tableClass; } public function rewind() { $this->_pointer = 0; return $this; } public function current() { if ($this->valid() === false) { return null; } return $this->_loadAndReturnRow($this->_pointer); } public function key() { return $this->_pointer; } public function next() { ++$this->_pointer; } public function valid() { return $this->_pointer >= 0 && $this->_pointer < $this->_count; } public function count() { return $this->_count; } public function seek($position) { $position = (int) $position; if ($position < 0 || $position >= $this->_count) { throw new Zend_Db_Table_Rowset_Exception("Illegal index $position"); } $this->_pointer = $position; return $this; } public function offsetExists($offset) { return isset($this->_data[(int) $offset]); } public function offsetGet($offset) { $offset = (int) $offset; if ($offset < 0 || $offset >= $this->_count) { throw new Zend_Db_Table_Rowset_Exception("Illegal index $offset"); } $this->_pointer = $offset; return $this->current(); } public function offsetSet($offset, $value) { } public function offsetUnset($offset) { } public function getRow($position, $seek = false) { try { $row = $this->_loadAndReturnRow($position); } catch (Zend_Db_Table_Rowset_Exception $e) { throw new Zend_Db_Table_Rowset_Exception('No row could be found at position ' . (int) $position, 0, $e); } if ($seek == true) { $this->seek($position); } return $row; } public function toArray() { foreach ($this->_rows as $i => $row) { $this->_data[$i] = $row->toArray(); } return $this->_data; } protected function _loadAndReturnRow($position) { if (!isset($this->_data[$position])) { throw new Zend_Db_Table_Rowset_Exception("Data for provided position does not exist"); } if (empty($this->_rows[$position])) { $this->_rows[$position] = new $this->_rowClass( array( 'table' => $this->_table, 'data' => $this->_data[$position], 'stored' => $this->_stored, 'readOnly' => $this->_readOnly ) ); } return $this->_rows[$position]; } } 

class Zend_Db_Table_Rowset extends Zend_Db_Table_Rowset_Abstract { } 

class Zend_Db_Table_Rowset_Exception extends Zend_Db_Table_Exception { } 

class Zend_Db_Select { const DISTINCT = 'distinct'; const COLUMNS = 'columns'; const FROM = 'from'; const UNION = 'union'; const WHERE = 'where'; const GROUP = 'group'; const HAVING = 'having'; const ORDER = 'order'; const LIMIT_COUNT = 'limitcount'; const LIMIT_OFFSET = 'limitoffset'; const FOR_UPDATE = 'forupdate'; const INNER_JOIN = 'inner join'; const LEFT_JOIN = 'left join'; const RIGHT_JOIN = 'right join'; const FULL_JOIN = 'full join'; const CROSS_JOIN = 'cross join'; const NATURAL_JOIN = 'natural join'; const SQL_WILDCARD = '*'; const SQL_SELECT = 'SELECT'; const SQL_UNION = 'UNION'; const SQL_UNION_ALL = 'UNION ALL'; const SQL_FROM = 'FROM'; const SQL_WHERE = 'WHERE'; const SQL_DISTINCT = 'DISTINCT'; const SQL_GROUP_BY = 'GROUP BY'; const SQL_ORDER_BY = 'ORDER BY'; const SQL_HAVING = 'HAVING'; const SQL_FOR_UPDATE = 'FOR UPDATE'; const SQL_AND = 'AND'; const SQL_AS = 'AS'; const SQL_OR = 'OR'; const SQL_ON = 'ON'; const SQL_ASC = 'ASC'; const SQL_DESC = 'DESC'; protected $_bind = array(); protected $_adapter; protected static $_partsInit = array( self::DISTINCT => false, self::COLUMNS => array(), self::UNION => array(), self::FROM => array(), self::WHERE => array(), self::GROUP => array(), self::HAVING => array(), self::ORDER => array(), self::LIMIT_COUNT => null, self::LIMIT_OFFSET => null, self::FOR_UPDATE => false ); protected static $_joinTypes = array( self::INNER_JOIN, self::LEFT_JOIN, self::RIGHT_JOIN, self::FULL_JOIN, self::CROSS_JOIN, self::NATURAL_JOIN, ); protected static $_unionTypes = array( self::SQL_UNION, self::SQL_UNION_ALL ); protected $_parts = array(); protected $_tableCols = array(); public function __construct(Zend_Db_Adapter_Abstract $adapter) { $this->_adapter = $adapter; $this->_parts = self::$_partsInit; } public function getBind() { return $this->_bind; } public function bind($bind) { $this->_bind = $bind; return $this; } public function distinct($flag = true) { $this->_parts[self::DISTINCT] = (bool) $flag; return $this; } public function from($name, $cols = '*', $schema = null) { return $this->_join(self::FROM, $name, null, $cols, $schema); } public function columns($cols = '*', $correlationName = null) { if ($correlationName === null && count($this->_parts[self::FROM])) { $correlationNameKeys = array_keys($this->_parts[self::FROM]); $correlationName = current($correlationNameKeys); } if (!array_key_exists($correlationName, $this->_parts[self::FROM])) { throw new Zend_Db_Select_Exception("No table has been specified for the FROM clause"); } $this->_tableCols($correlationName, $cols); return $this; } public function union($select = array(), $type = self::SQL_UNION) { if (!is_array($select)) { throw new Zend_Db_Select_Exception( "union() only accepts an array of Zend_Db_Select instances of sql query strings." ); } if (!in_array($type, self::$_unionTypes)) { throw new Zend_Db_Select_Exception("Invalid union type '{$type}'"); } foreach ($select as $target) { $this->_parts[self::UNION][] = array($target, $type); } return $this; } public function join($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->joinInner($name, $cond, $cols, $schema); } public function joinInner($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::INNER_JOIN, $name, $cond, $cols, $schema); } public function joinLeft($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::LEFT_JOIN, $name, $cond, $cols, $schema); } public function joinRight($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::RIGHT_JOIN, $name, $cond, $cols, $schema); } public function joinFull($name, $cond, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::FULL_JOIN, $name, $cond, $cols, $schema); } public function joinCross($name, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::CROSS_JOIN, $name, null, $cols, $schema); } public function joinNatural($name, $cols = self::SQL_WILDCARD, $schema = null) { return $this->_join(self::NATURAL_JOIN, $name, null, $cols, $schema); } public function where($cond, $value = null, $type = null) { $this->_parts[self::WHERE][] = $this->_where($cond, $value, $type, true); return $this; } public function orWhere($cond, $value = null, $type = null) { $this->_parts[self::WHERE][] = $this->_where($cond, $value, $type, false); return $this; } public function group($spec) { if (!is_array($spec)) { $spec = array($spec); } foreach ($spec as $val) { if (preg_match('/\(.*\)/', (string) $val)) { $val = new Zend_Db_Expr($val); } $this->_parts[self::GROUP][] = $val; } return $this; } public function having($cond, $value = null, $type = null) { if ($value !== null) { $cond = $this->_adapter->quoteInto($cond, $value, $type); } if ($this->_parts[self::HAVING]) { $this->_parts[self::HAVING][] = self::SQL_AND . " ($cond)"; } else { $this->_parts[self::HAVING][] = "($cond)"; } return $this; } public function orHaving($cond, $value = null, $type = null) { if ($value !== null) { $cond = $this->_adapter->quoteInto($cond, $value, $type); } if ($this->_parts[self::HAVING]) { $this->_parts[self::HAVING][] = self::SQL_OR . " ($cond)"; } else { $this->_parts[self::HAVING][] = "($cond)"; } return $this; } public function order($spec) { if (!is_array($spec)) { $spec = array($spec); } foreach ($spec as $val) { if ($val instanceof Zend_Db_Expr) { $expr = $val->__toString(); if (empty($expr)) { continue; } $this->_parts[self::ORDER][] = $val; } else { if (empty($val)) { continue; } $direction = self::SQL_ASC; if (preg_match('/(.*\W)(' . self::SQL_ASC . '|' . self::SQL_DESC . ')\b/si', $val, $matches)) { $val = trim($matches[1]); $direction = $matches[2]; } if (preg_match('/\(.*\)/', $val)) { $val = new Zend_Db_Expr($val); } $this->_parts[self::ORDER][] = array($val, $direction); } } return $this; } public function limit($count = null, $offset = null) { $this->_parts[self::LIMIT_COUNT] = (int) $count; $this->_parts[self::LIMIT_OFFSET] = (int) $offset; return $this; } public function limitPage($page, $rowCount) { $page = ($page > 0) ? $page : 1; $rowCount = ($rowCount > 0) ? $rowCount : 1; $this->_parts[self::LIMIT_COUNT] = (int) $rowCount; $this->_parts[self::LIMIT_OFFSET] = (int) $rowCount * ($page - 1); return $this; } public function forUpdate($flag = true) { $this->_parts[self::FOR_UPDATE] = (bool) $flag; return $this; } public function getPart($part) { $part = strtolower($part); if (!array_key_exists($part, $this->_parts)) { throw new Zend_Db_Select_Exception("Invalid Select part '$part'"); } return $this->_parts[$part]; } public function query($fetchMode = null, $bind = array()) { if (!empty($bind)) { $this->bind($bind); } $stmt = $this->_adapter->query($this); if ($fetchMode == null) { $fetchMode = $this->_adapter->getFetchMode(); } $stmt->setFetchMode($fetchMode); return $stmt; } public function assemble() { $sql = self::SQL_SELECT; foreach (array_keys(self::$_partsInit) as $part) { $method = '_render' . ucfirst($part); if (method_exists($this, $method)) { $sql = $this->$method($sql); } } return $sql; } public function reset($part = null) { if ($part == null) { $this->_parts = self::$_partsInit; } else if (array_key_exists($part, self::$_partsInit)) { $this->_parts[$part] = self::$_partsInit[$part]; } return $this; } public function getAdapter() { return $this->_adapter; } protected function _join($type, $name, $cond, $cols, $schema = null) { if (!in_array($type, self::$_joinTypes) && $type != self::FROM) { throw new Zend_Db_Select_Exception("Invalid join type '$type'"); } if (count($this->_parts[self::UNION])) { throw new Zend_Db_Select_Exception("Invalid use of table with " . self::SQL_UNION); } if (empty($name)) { $correlationName = $tableName = ''; } else if (is_array($name)) { foreach ($name as $_correlationName => $_tableName) { if (is_string($_correlationName)) { $tableName = $_tableName; $correlationName = $_correlationName; } else { $tableName = $_tableName; $correlationName = $this->_uniqueCorrelation($tableName); } break; } } else if ($name instanceof Zend_Db_Expr|| $name instanceof Zend_Db_Select) { $tableName = $name; $correlationName = $this->_uniqueCorrelation('t'); } else if (preg_match('/^(.+)\s+AS\s+(.+)$/i', $name, $m)) { $tableName = $m[1]; $correlationName = $m[2]; } else { $tableName = $name; $correlationName = $this->_uniqueCorrelation($tableName); } if (!is_object($tableName) && false !== strpos($tableName, '.')) { list($schema, $tableName) = explode('.', $tableName); } $lastFromCorrelationName = null; if (!empty($correlationName)) { if (array_key_exists($correlationName, $this->_parts[self::FROM])) { throw new Zend_Db_Select_Exception("You cannot define a correlation name '$correlationName' more than once"); } if ($type == self::FROM) { $tmpFromParts = $this->_parts[self::FROM]; $this->_parts[self::FROM] = array(); while ($tmpFromParts) { $currentCorrelationName = key($tmpFromParts); if ($tmpFromParts[$currentCorrelationName]['joinType'] != self::FROM) { break; } $lastFromCorrelationName = $currentCorrelationName; $this->_parts[self::FROM][$currentCorrelationName] = array_shift($tmpFromParts); } } else { $tmpFromParts = array(); } $this->_parts[self::FROM][$correlationName] = array( 'joinType' => $type, 'schema' => $schema, 'tableName' => $tableName, 'joinCondition' => $cond ); while ($tmpFromParts) { $currentCorrelationName = key($tmpFromParts); $this->_parts[self::FROM][$currentCorrelationName] = array_shift($tmpFromParts); } } if ($type == self::FROM && $lastFromCorrelationName == null) { $lastFromCorrelationName = true; } $this->_tableCols($correlationName, $cols, $lastFromCorrelationName); return $this; } public function _joinUsing($type, $name, $cond, $cols = '*', $schema = null) { if (empty($this->_parts[self::FROM])) { throw new Zend_Db_Select_Exception("You can only perform a joinUsing after specifying a FROM table"); } $join = $this->_adapter->quoteIdentifier(key($this->_parts[self::FROM]), true); $from = $this->_adapter->quoteIdentifier($this->_uniqueCorrelation($name), true); $cond1 = $from . '.' . $cond; $cond2 = $join . '.' . $cond; $cond = $cond1 . ' = ' . $cond2; return $this->_join($type, $name, $cond, $cols, $schema); } private function _uniqueCorrelation($name) { if (is_array($name)) { $c = end($name); } else { $dot = strrpos($name,'.'); $c = ($dot === false) ? $name : substr($name, $dot+1); } for ($i = 2; array_key_exists($c, $this->_parts[self::FROM]); ++$i) { $c = $name . '_' . (string) $i; } return $c; } protected function _tableCols($correlationName, $cols, $afterCorrelationName = null) { if (!is_array($cols)) { $cols = array($cols); } if ($correlationName == null) { $correlationName = ''; } $columnValues = array(); foreach (array_filter($cols) as $alias => $col) { $currentCorrelationName = $correlationName; if (is_string($col)) { if (preg_match('/^(.+)\s+' . self::SQL_AS . '\s+(.+)$/i', $col, $m)) { $col = $m[1]; $alias = $m[2]; } if (preg_match('/\(.*\)/', $col)) { $col = new Zend_Db_Expr($col); } elseif (preg_match('/(.+)\.(.+)/', $col, $m)) { $currentCorrelationName = $m[1]; $col = $m[2]; } } $columnValues[] = array($currentCorrelationName, $col, is_string($alias) ? $alias : null); } if ($columnValues) { if ($afterCorrelationName === true || is_string($afterCorrelationName)) { $tmpColumns = $this->_parts[self::COLUMNS]; $this->_parts[self::COLUMNS] = array(); } else { $tmpColumns = array(); } if (is_string($afterCorrelationName)) { while ($tmpColumns) { $this->_parts[self::COLUMNS][] = $currentColumn = array_shift($tmpColumns); if ($currentColumn[0] == $afterCorrelationName) { break; } } } foreach ($columnValues as $columnValue) { array_push($this->_parts[self::COLUMNS], $columnValue); } while ($tmpColumns) { array_push($this->_parts[self::COLUMNS], array_shift($tmpColumns)); } } } protected function _where($condition, $value = null, $type = null, $bool = true) { if (count($this->_parts[self::UNION])) { throw new Zend_Db_Select_Exception("Invalid use of where clause with " . self::SQL_UNION); } if ($value !== null) { $condition = $this->_adapter->quoteInto($condition, $value, $type); } $cond = ""; if ($this->_parts[self::WHERE]) { if ($bool === true) { $cond = self::SQL_AND . ' '; } else { $cond = self::SQL_OR . ' '; } } return $cond . "($condition)"; } protected function _getDummyTable() { return array(); } protected function _getQuotedSchema($schema = null) { if ($schema === null) { return null; } return $this->_adapter->quoteIdentifier($schema, true) . '.'; } protected function _getQuotedTable($tableName, $correlationName = null) { return $this->_adapter->quoteTableAs($tableName, $correlationName, true); } protected function _renderDistinct($sql) { if ($this->_parts[self::DISTINCT]) { $sql .= ' ' . self::SQL_DISTINCT; } return $sql; } protected function _renderColumns($sql) { if (!count($this->_parts[self::COLUMNS])) { return null; } $columns = array(); foreach ($this->_parts[self::COLUMNS] as $columnEntry) { list($correlationName, $column, $alias) = $columnEntry; if ($column instanceof Zend_Db_Expr) { $columns[] = $this->_adapter->quoteColumnAs($column, $alias, true); } else { if ($column == self::SQL_WILDCARD) { $column = new Zend_Db_Expr(self::SQL_WILDCARD); $alias = null; } if (empty($correlationName)) { $columns[] = $this->_adapter->quoteColumnAs($column, $alias, true); } else { $columns[] = $this->_adapter->quoteColumnAs(array($correlationName, $column), $alias, true); } } } return $sql .= ' ' . implode(', ', $columns); } protected function _renderFrom($sql) { if (empty($this->_parts[self::FROM])) { $this->_parts[self::FROM] = $this->_getDummyTable(); } $from = array(); foreach ($this->_parts[self::FROM] as $correlationName => $table) { $tmp = ''; $joinType = ($table['joinType'] == self::FROM) ? self::INNER_JOIN : $table['joinType']; if (! empty($from)) { $tmp .= ' ' . strtoupper($joinType) . ' '; } $tmp .= $this->_getQuotedSchema($table['schema']); $tmp .= $this->_getQuotedTable($table['tableName'], $correlationName); if (!empty($from) && ! empty($table['joinCondition'])) { $tmp .= ' ' . self::SQL_ON . ' ' . $table['joinCondition']; } $from[] = $tmp; } if (!empty($from)) { $sql .= ' ' . self::SQL_FROM . ' ' . implode("\n", $from); } return $sql; } protected function _renderUnion($sql) { if ($this->_parts[self::UNION]) { $parts = count($this->_parts[self::UNION]); foreach ($this->_parts[self::UNION] as $cnt => $union) { list($target, $type) = $union; if ($target instanceof Zend_Db_Select) { $target = $target->assemble(); } $sql .= $target; if ($cnt < $parts - 1) { $sql .= ' ' . $type . ' '; } } } return $sql; } protected function _renderWhere($sql) { if ($this->_parts[self::FROM] && $this->_parts[self::WHERE]) { $sql .= ' ' . self::SQL_WHERE . ' ' . implode(' ', $this->_parts[self::WHERE]); } return $sql; } protected function _renderGroup($sql) { if ($this->_parts[self::FROM] && $this->_parts[self::GROUP]) { $group = array(); foreach ($this->_parts[self::GROUP] as $term) { $group[] = $this->_adapter->quoteIdentifier($term, true); } $sql .= ' ' . self::SQL_GROUP_BY . ' ' . implode(",\n\t", $group); } return $sql; } protected function _renderHaving($sql) { if ($this->_parts[self::FROM] && $this->_parts[self::HAVING]) { $sql .= ' ' . self::SQL_HAVING . ' ' . implode(' ', $this->_parts[self::HAVING]); } return $sql; } protected function _renderOrder($sql) { if ($this->_parts[self::ORDER]) { $order = array(); foreach ($this->_parts[self::ORDER] as $term) { if (is_array($term)) { if(is_numeric($term[0]) && strval(intval($term[0])) == $term[0]) { $order[] = (int)trim($term[0]) . ' ' . $term[1]; } else { $order[] = $this->_adapter->quoteIdentifier($term[0], true) . ' ' . $term[1]; } } else if (is_numeric($term) && strval(intval($term)) == $term) { $order[] = (int)trim($term); } else { $order[] = $this->_adapter->quoteIdentifier($term, true); } } $sql .= ' ' . self::SQL_ORDER_BY . ' ' . implode(', ', $order); } return $sql; } protected function _renderLimitoffset($sql) { $count = 0; $offset = 0; if (!empty($this->_parts[self::LIMIT_OFFSET])) { $offset = (int) $this->_parts[self::LIMIT_OFFSET]; $count = PHP_INT_MAX; } if (!empty($this->_parts[self::LIMIT_COUNT])) { $count = (int) $this->_parts[self::LIMIT_COUNT]; } if ($count > 0) { $sql = trim($this->_adapter->limit($sql, $count, $offset)); } return $sql; } protected function _renderForupdate($sql) { if ($this->_parts[self::FOR_UPDATE]) { $sql .= ' ' . self::SQL_FOR_UPDATE; } return $sql; } public function __call($method, array $args) { $matches = array(); if (preg_match('/^join([a-zA-Z]*?)Using$/', $method, $matches)) { $type = strtolower($matches[1]); if ($type) { $type .= ' join'; if (!in_array($type, self::$_joinTypes)) { throw new Zend_Db_Select_Exception("Unrecognized method '$method()'"); } if (in_array($type, array(self::CROSS_JOIN, self::NATURAL_JOIN))) { throw new Zend_Db_Select_Exception("Cannot perform a joinUsing with method '$method()'"); } } else { $type = self::INNER_JOIN; } array_unshift($args, $type); return call_user_func_array(array($this, '_joinUsing'), $args); } throw new Zend_Db_Select_Exception("Unrecognized method '$method()'"); } public function __toString() { try { $sql = $this->assemble(); } catch (Exception $e) { trigger_error($e->getMessage(), E_USER_WARNING); $sql = ''; } return (string)$sql; } } 

class Zend_Db_Table_Select extends Zend_Db_Select { protected $_info; protected $_integrityCheck = true; protected $_table; public function __construct(Zend_Db_Table_Abstract $table) { parent::__construct($table->getAdapter()); $this->setTable($table); } public function getTable() { return $this->_table; } public function setTable(Zend_Db_Table_Abstract $table) { $this->_adapter = $table->getAdapter(); $this->_info = $table->info(); $this->_table = $table; return $this; } public function setIntegrityCheck($flag = true) { $this->_integrityCheck = $flag; return $this; } public function isReadOnly() { $readOnly = false; $fields = $this->getPart(Zend_Db_Table_Select::COLUMNS); $cols = $this->_info[Zend_Db_Table_Abstract::COLS]; if (!count($fields)) { return $readOnly; } foreach ($fields as $columnEntry) { $column = $columnEntry[1]; $alias = $columnEntry[2]; if ($alias !== null) { $column = $alias; } switch (true) { case ($column == self::SQL_WILDCARD): break; case ($column instanceof Zend_Db_Expr): case (!in_array($column, $cols)): $readOnly = true; break 2; } } return $readOnly; } public function from($name, $cols = self::SQL_WILDCARD, $schema = null) { if ($name instanceof Zend_Db_Table_Abstract) { $info = $name->info(); $name = $info[Zend_Db_Table_Abstract::NAME]; if (isset($info[Zend_Db_Table_Abstract::SCHEMA])) { $schema = $info[Zend_Db_Table_Abstract::SCHEMA]; } } return $this->joinInner($name, null, $cols, $schema); } public function assemble() { $fields = $this->getPart(Zend_Db_Table_Select::COLUMNS); $primary = $this->_info[Zend_Db_Table_Abstract::NAME]; $schema = $this->_info[Zend_Db_Table_Abstract::SCHEMA]; if (count($this->_parts[self::UNION]) == 0) { if (!count($fields)) { $this->from($primary, self::SQL_WILDCARD, $schema); $fields = $this->getPart(Zend_Db_Table_Select::COLUMNS); } $from = $this->getPart(Zend_Db_Table_Select::FROM); if ($this->_integrityCheck !== false) { foreach ($fields as $columnEntry) { list($table, $column) = $columnEntry; if ($column) { if (!isset($from[$table]) || $from[$table]['tableName'] != $primary) { throw new Zend_Db_Table_Select_Exception('Select query cannot join with another table'); } } } } } return parent::assemble(); } }

class Zend_Db_Select_Exception extends Zend_Db_Exception { } 

class Zend_Db_Table_Select_Exception extends Zend_Db_Select_Exception { } 

interface Zend_Filter_Interface { public function filter($value); } 

class Zend_Filter_Boolean implements Zend_Filter_Interface { const BOOLEAN = 1; const INTEGER = 2; const FLOAT = 4; const STRING = 8; const ZERO = 16; const EMPTY_ARRAY = 32; const NULL = 64; const PHP = 127; const FALSE_STRING = 128; const YES = 256; const ALL = 511; protected $_constants = array( self::BOOLEAN => 'boolean', self::INTEGER => 'integer', self::FLOAT => 'float', self::STRING => 'string', self::ZERO => 'zero', self::EMPTY_ARRAY => 'array', self::NULL => 'null', self::PHP => 'php', self::FALSE_STRING => 'false', self::YES => 'yes', self::ALL => 'all', ); protected $_type = self::PHP; protected $_locale = array('auto'); protected $_casting = true; public function __construct($options = null) { if ($options instanceof Zend_Config) { $options = $options->toArray(); } elseif (!is_array($options)) { $options = func_get_args(); $temp = array(); if (!empty($options)) { $temp['type'] = array_shift($options); } if (!empty($options)) { $temp['casting'] = array_shift($options); } if (!empty($options)) { $temp['locale'] = array_shift($options); } $options = $temp; } if (array_key_exists('type', $options)) { $this->setType($options['type']); } if (array_key_exists('casting', $options)) { $this->setCasting($options['casting']); } if (array_key_exists('locale', $options)) { $this->setLocale($options['locale']); } } public function getType() { return $this->_type; } public function setType($type = null) { if (is_array($type)) { $detected = 0; foreach($type as $value) { if (is_int($value)) { $detected += $value; } elseif (in_array($value, $this->_constants)) { $detected += array_search($value, $this->_constants); } } $type = $detected; } elseif (is_string($type) && in_array($type, $this->_constants)) { $type = array_search($type, $this->_constants); } if (!is_int($type) || ($type < 0) || ($type > self::ALL)) { throw new Zend_Filter_Exception('Unknown type'); } $this->_type = $type; return $this; } public function getLocale() { return $this->_locale; } public function setLocale($locale = null) { if (is_string($locale)) { $locale = array($locale); } elseif ($locale instanceof Zend_Locale) { $locale = array($locale->toString()); } elseif (!is_array($locale)) { throw new Zend_Filter_Exception('Locale has to be string, array or an instance of Zend_Locale'); } foreach ($locale as $single) { if (!Zend_Locale::isLocale($single)) { throw new Zend_Filter_Exception("Unknown locale '$single'"); } } $this->_locale = $locale; return $this; } public function getCasting() { return $this->_casting; } public function setCasting($casting = true) { $this->_casting = (boolean) $casting; return $this; } public function filter($value) { $type = $this->getType(); $casting = $this->getCasting(); if ($type >= self::YES) { $type -= self::YES; if (is_string($value)) { $locales = $this->getLocale(); foreach ($locales as $locale) { if ($this->_getLocalizedQuestion($value, false, $locale) === false) { return false; } if (!$casting && ($this->_getLocalizedQuestion($value, true, $locale) === true)) { return true; } } } } if ($type >= self::FALSE_STRING) { $type -= self::FALSE_STRING; if (is_string($value) && (strtolower($value) == 'false')) { return false; } if ((!$casting) && is_string($value) && (strtolower($value) == 'true')) { return true; } } if ($type >= self::NULL) { $type -= self::NULL; if ($value === null) { return false; } } if ($type >= self::EMPTY_ARRAY) { $type -= self::EMPTY_ARRAY; if (is_array($value) && ($value == array())) { return false; } } if ($type >= self::ZERO) { $type -= self::ZERO; if (is_string($value) && ($value == '0')) { return false; } if ((!$casting) && (is_string($value)) && ($value == '1')) { return true; } } if ($type >= self::STRING) { $type -= self::STRING; if (is_string($value) && ($value == '')) { return false; } } if ($type >= self::FLOAT) { $type -= self::FLOAT; if (is_float($value) && ($value == 0.0)) { return false; } if ((!$casting) && is_float($value) && ($value == 1.0)) { return true; } } if ($type >= self::INTEGER) { $type -= self::INTEGER; if (is_int($value) && ($value == 0)) { return false; } if ((!$casting) && is_int($value) && ($value == 1)) { return true; } } if ($type >= self::BOOLEAN) { $type -= self::BOOLEAN; if (is_bool($value)) { return $value; } } if ($casting) { return true; } return $value; } protected function _getLocalizedQuestion($value, $yes, $locale) { if ($yes == true) { $question = 'yes'; $return = true; } else { $question = 'no'; $return = false; } $str = Zend_Locale::getTranslation($question, 'question', $locale); $str = explode(':', $str); if (!empty($str)) { foreach($str as $no) { if (($no == $value) || (strtolower($no) == strtolower($value))) { return $return; } } } } } 

class Zend_Filter_Int implements Zend_Filter_Interface { public function filter($value) { return (int) ((string) $value); } } 

class Zend_Filter_StringTrim implements Zend_Filter_Interface { protected $_charList; public function __construct($options = null) { if ($options instanceof Zend_Config) { $options = $options->toArray(); } else if (!is_array($options)) { $options = func_get_args(); $temp['charlist'] = array_shift($options); $options = $temp; } if (array_key_exists('charlist', $options)) { $this->setCharList($options['charlist']); } } public function getCharList() { return $this->_charList; } public function setCharList($charList) { $this->_charList = $charList; return $this; } public function filter($value) { if (null === $this->_charList) { return $this->_unicodeTrim((string) $value); } else { return $this->_unicodeTrim((string) $value, $this->_charList); } } protected function _unicodeTrim($value, $charlist = '\\\\s') { $chars = preg_replace( array( '/[\^\-\]\\\]/S', '/\\\{4}/S', '/\//'), array( '\\\\\\0', '\\', '\/' ), $charlist ); $pattern = '^[' . $chars . ']*|[' . $chars . ']*$'; return preg_replace("/$pattern/sSD", '', $value); } } 

class Zend_Filter_StripTags implements Zend_Filter_Interface { const UNIQUE_ID_PREFIX = '__Zend_Filter_StripTags__'; public $commentsAllowed = false; protected $_tagsAllowed = array(); protected $_attributesAllowed = array(); public function __construct($options = null) { if ($options instanceof Zend_Config) { $options = $options->toArray(); } else if ((!is_array($options)) || (is_array($options) && !array_key_exists('allowTags', $options) && !array_key_exists('allowAttribs', $options) && !array_key_exists('allowComments', $options))) { $options = func_get_args(); $temp['allowTags'] = array_shift($options); if (!empty($options)) { $temp['allowAttribs'] = array_shift($options); } if (!empty($options)) { $temp['allowComments'] = array_shift($options); } $options = $temp; } if (array_key_exists('allowTags', $options)) { $this->setTagsAllowed($options['allowTags']); } if (array_key_exists('allowAttribs', $options)) { $this->setAttributesAllowed($options['allowAttribs']); } if (array_key_exists('allowComments', $options)) { $this->setCommentsAllowed($options['allowComments']); } } public function getCommentsAllowed() { return $this->commentsAllowed; } public function setCommentsAllowed($commentsAllowed) { $this->commentsAllowed = (boolean) $commentsAllowed; return $this; } public function getTagsAllowed() { return $this->_tagsAllowed; } public function setTagsAllowed($tagsAllowed) { if (!is_array($tagsAllowed)) { $tagsAllowed = array($tagsAllowed); } foreach ($tagsAllowed as $index => $element) { if (is_int($index) && is_string($element)) { $tagName = strtolower($element); $this->_tagsAllowed[$tagName] = array(); } else if (is_string($index) && (is_array($element) || is_string($element))) { $tagName = strtolower($index); if (is_string($element)) { $element = array($element); } $this->_tagsAllowed[$tagName] = array(); foreach ($element as $attribute) { if (is_string($attribute)) { $attributeName = strtolower($attribute); $this->_tagsAllowed[$tagName][$attributeName] = null; } } } } return $this; } public function getAttributesAllowed() { return $this->_attributesAllowed; } public function setAttributesAllowed($attributesAllowed) { if (!is_array($attributesAllowed)) { $attributesAllowed = array($attributesAllowed); } foreach ($attributesAllowed as $attribute) { if (is_string($attribute)) { $attributeName = strtolower($attribute); $this->_attributesAllowed[$attributeName] = null; } } return $this; } public function filter($value) { $value = (string) $value; while (strpos($value, '<!--') !== false) { $pos = strrpos($value, '<!--'); $start = substr($value, 0, $pos); $value = substr($value, $pos); if (!preg_match('/--\s*>/s', $value)) { $value = ''; } else { $value = preg_replace('/<(?:!(?:--[\s\S]*?--\s*)?(>))/s', '', $value); } $value = $start . $value; } $dataFiltered = ''; preg_match_all('/([^<]*)(<?[^>]*>?)/', (string) $value, $matches); foreach ($matches[1] as $index => $preTag) { if (strlen($preTag)) { $preTag = str_replace('>', '', $preTag); } $tag = $matches[2][$index]; if (strlen($tag)) { $tagFiltered = $this->_filterTag($tag); } else { $tagFiltered = ''; } $dataFiltered .= $preTag . $tagFiltered; } return $dataFiltered; } protected function _filterTag($tag) { $isMatch = preg_match('~(</?)(\w*)((/(?!>)|[^/>])*)(/?>)~', $tag, $matches); if (!$isMatch) { return ''; } $tagStart = $matches[1]; $tagName = strtolower($matches[2]); $tagAttributes = $matches[3]; $tagEnd = $matches[5]; if (!isset($this->_tagsAllowed[$tagName])) { return ''; } $tagAttributes = trim($tagAttributes); if (strlen($tagAttributes)) { preg_match_all('/([\w-]+)\s*=\s*(?:(")(.*?)"|(\')(.*?)\')/s', $tagAttributes, $matches); $tagAttributes = ''; foreach ($matches[1] as $index => $attributeName) { $attributeName = strtolower($attributeName); $attributeDelimiter = empty($matches[2][$index]) ? $matches[4][$index] : $matches[2][$index]; $attributeValue = empty($matches[3][$index]) ? $matches[5][$index] : $matches[3][$index]; if (!array_key_exists($attributeName, $this->_tagsAllowed[$tagName]) && !array_key_exists($attributeName, $this->_attributesAllowed)) { continue; } $tagAttributes .= " $attributeName=" . $attributeDelimiter . $attributeValue . $attributeDelimiter; } } if (strpos($tagEnd, '/') !== false) { $tagEnd = " $tagEnd"; } return $tagStart . $tagName . $tagAttributes . $tagEnd; } } 

class Zend_Mime_Message { protected $_parts = array(); protected $_mime = null; public function getParts() { return $this->_parts; } public function setParts($parts) { $this->_parts = $parts; } public function addPart(Zend_Mime_Part $part) { $this->_parts[] = $part; } public function isMultiPart() { return (count($this->_parts) > 1); } public function setMime(Zend_Mime $mime) { $this->_mime = $mime; } public function getMime() { if ($this->_mime === null) { $this->_mime = new Zend_Mime(); } return $this->_mime; } public function generateMessage($EOL = Zend_Mime::LINEEND) { if (! $this->isMultiPart()) { $body = array_shift($this->_parts); $body = $body->getContent($EOL); } else { $mime = $this->getMime(); $boundaryLine = $mime->boundaryLine($EOL); $body = 'This is a message in Mime Format.  If you see this, ' . "your mail reader does not support this format." . $EOL; foreach (array_keys($this->_parts) as $p) { $body .= $boundaryLine . $this->getPartHeaders($p, $EOL) . $EOL . $this->getPartContent($p, $EOL); } $body .= $mime->mimeEnd($EOL); } return trim($body); } public function getPartHeadersArray($partnum) { return $this->_parts[$partnum]->getHeadersArray(); } public function getPartHeaders($partnum, $EOL = Zend_Mime::LINEEND) { return $this->_parts[$partnum]->getHeaders($EOL); } public function getPartContent($partnum, $EOL = Zend_Mime::LINEEND) { return $this->_parts[$partnum]->getContent($EOL); } protected static function _disassembleMime($body, $boundary) { $start = 0; $res = array(); $p = strpos($body, '--'.$boundary."\n", $start); if ($p === false) { return array(); } $start = $p + 3 + strlen($boundary); while (($p = strpos($body, '--' . $boundary . "\n", $start)) !== false) { $res[] = substr($body, $start, $p-$start); $start = $p + 3 + strlen($boundary); } $p = strpos($body, '--' . $boundary . '--', $start); if ($p===false) { throw new Zend_Exception('Not a valid Mime Message: End Missing'); } $res[] = substr($body, $start, $p-$start); return $res; } public static function createFromMessage($message, $boundary, $EOL = Zend_Mime::LINEEND) { $parts = Zend_Mime_Decode::splitMessageStruct($message, $boundary, $EOL); $res = new self(); foreach ($parts as $part) { $newPart = new Zend_Mime_Part($part['body']); foreach ($part['header'] as $key => $value) { switch(strtolower($key)) { case 'content-type': $newPart->type = $value; break; case 'content-transfer-encoding': $newPart->encoding = $value; break; case 'content-id': $newPart->id = trim($value,'<>'); break; case 'content-disposition': $newPart->disposition = $value; break; case 'content-description': $newPart->description = $value; break; case 'content-location': $newPart->location = $value; break; case 'content-language': $newPart->language = $value; break; default: throw new Zend_Exception('Unknown header ignored for MimePart:' . $key); } } $res->addPart($newPart); } return $res; } } 

class Zend_Mail extends Zend_Mime_Message { protected static $_defaultTransport = null; protected static $_defaultFrom; protected static $_defaultReplyTo; protected $_charset = 'iso-8859-1'; protected $_headers = array(); protected $_headerEncoding = Zend_Mime::ENCODING_QUOTEDPRINTABLE; protected $_from = null; protected $_to = array(); protected $_recipients = array(); protected $_replyTo = null; protected $_returnPath = null; protected $_subject = null; protected $_date = null; protected $_messageId = null; protected $_bodyText = false; protected $_bodyHtml = false; protected $_mimeBoundary = null; protected $_type = null; public $hasAttachments = false; public static function setDefaultTransport(Zend_Mail_Transport_Abstract $transport) { self::$_defaultTransport = $transport; } public static function getDefaultTransport() { return self::$_defaultTransport; } public static function clearDefaultTransport() { self::$_defaultTransport = null; } public function __construct($charset = null) { if ($charset != null) { $this->_charset = $charset; } } public function getCharset() { return $this->_charset; } public function setType($type) { $allowed = array( Zend_Mime::MULTIPART_ALTERNATIVE, Zend_Mime::MULTIPART_MIXED, Zend_Mime::MULTIPART_RELATED, ); if (!in_array($type, $allowed)) { throw new Zend_Mail_Exception('Invalid content type "' . $type . '"'); } $this->_type = $type; return $this; } public function getType() { return $this->_type; } public function setMimeBoundary($boundary) { $this->_mimeBoundary = $boundary; return $this; } public function getMimeBoundary() { return $this->_mimeBoundary; } public function getEncodingOfHeaders() { return $this->getHeaderEncoding(); } public function getHeaderEncoding() { return $this->_headerEncoding; } public function setEncodingOfHeaders($encoding) { return $this->setHeaderEncoding($encoding); } public function setHeaderEncoding($encoding) { $allowed = array( Zend_Mime::ENCODING_BASE64, Zend_Mime::ENCODING_QUOTEDPRINTABLE ); if (!in_array($encoding, $allowed)) { throw new Zend_Mail_Exception('Invalid encoding "' . $encoding . '"'); } $this->_headerEncoding = $encoding; return $this; } public function setBodyText($txt, $charset = null, $encoding = Zend_Mime::ENCODING_QUOTEDPRINTABLE) { if ($charset === null) { $charset = $this->_charset; } $mp = new Zend_Mime_Part($txt); $mp->encoding = $encoding; $mp->type = Zend_Mime::TYPE_TEXT; $mp->disposition = Zend_Mime::DISPOSITION_INLINE; $mp->charset = $charset; $this->_bodyText = $mp; return $this; } public function getBodyText($textOnly = false) { if ($textOnly && $this->_bodyText) { $body = $this->_bodyText; return $body->getContent(); } return $this->_bodyText; } public function setBodyHtml($html, $charset = null, $encoding = Zend_Mime::ENCODING_QUOTEDPRINTABLE) { if ($charset === null) { $charset = $this->_charset; } $mp = new Zend_Mime_Part($html); $mp->encoding = $encoding; $mp->type = Zend_Mime::TYPE_HTML; $mp->disposition = Zend_Mime::DISPOSITION_INLINE; $mp->charset = $charset; $this->_bodyHtml = $mp; return $this; } public function getBodyHtml($htmlOnly = false) { if ($htmlOnly && $this->_bodyHtml) { $body = $this->_bodyHtml; return $body->getContent(); } return $this->_bodyHtml; } public function addAttachment(Zend_Mime_Part $attachment) { $this->addPart($attachment); $this->hasAttachments = true; return $this; } public function createAttachment($body, $mimeType = Zend_Mime::TYPE_OCTETSTREAM, $disposition = Zend_Mime::DISPOSITION_ATTACHMENT, $encoding = Zend_Mime::ENCODING_BASE64, $filename = null) { $mp = new Zend_Mime_Part($body); $mp->encoding = $encoding; $mp->type = $mimeType; $mp->disposition = $disposition; $mp->filename = $filename; $this->addAttachment($mp); return $mp; } public function getPartCount() { return count($this->_parts); } protected function _encodeHeader($value) { if (Zend_Mime::isPrintable($value) === false) { if ($this->getHeaderEncoding() === Zend_Mime::ENCODING_QUOTEDPRINTABLE) { $value = Zend_Mime::encodeQuotedPrintableHeader($value, $this->getCharset(), Zend_Mime::LINELENGTH, Zend_Mime::LINEEND); } else { $value = Zend_Mime::encodeBase64Header($value, $this->getCharset(), Zend_Mime::LINELENGTH, Zend_Mime::LINEEND); } } return $value; } protected function _storeHeader($headerName, $value, $append = false) { if (isset($this->_headers[$headerName])) { $this->_headers[$headerName][] = $value; } else { $this->_headers[$headerName] = array($value); } if ($append) { $this->_headers[$headerName]['append'] = true; } } protected function _clearHeader($headerName) { $this->clearHeader($headerName); } protected function _addRecipientAndHeader($headerName, $email, $name) { $email = $this->_filterEmail($email); $name = $this->_filterName($name); $this->_recipients[$email] = 1; $this->_storeHeader($headerName, $this->_formatAddress($email, $name), true); } public function addTo($email, $name='') { if (!is_array($email)) { $email = array($name => $email); } foreach ($email as $n => $recipient) { $this->_addRecipientAndHeader('To', $recipient, is_int($n) ? '' : $n); $this->_to[] = $recipient; } return $this; } public function addCc($email, $name='') { if (!is_array($email)) { $email = array($name => $email); } foreach ($email as $n => $recipient) { $this->_addRecipientAndHeader('Cc', $recipient, is_int($n) ? '' : $n); } return $this; } public function addBcc($email) { if (!is_array($email)) { $email = array($email); } foreach ($email as $recipient) { $this->_addRecipientAndHeader('Bcc', $recipient, ''); } return $this; } public function getRecipients() { return array_keys($this->_recipients); } public function clearHeader($headerName) { if (isset($this->_headers[$headerName])){ unset($this->_headers[$headerName]); } return $this; } public function clearRecipients() { $this->_recipients = array(); $this->_to = array(); $this->clearHeader('To'); $this->clearHeader('Cc'); $this->clearHeader('Bcc'); return $this; } public function setFrom($email, $name = null) { if (null !== $this->_from) { throw new Zend_Mail_Exception('From Header set twice'); } $email = $this->_filterEmail($email); $name = $this->_filterName($name); $this->_from = $email; $this->_storeHeader('From', $this->_formatAddress($email, $name), true); return $this; } public function setReplyTo($email, $name = null) { if (null !== $this->_replyTo) { throw new Zend_Mail_Exception('Reply-To Header set twice'); } $email = $this->_filterEmail($email); $name = $this->_filterName($name); $this->_replyTo = $email; $this->_storeHeader('Reply-To', $this->_formatAddress($email, $name), true); return $this; } public function getFrom() { return $this->_from; } public function getReplyTo() { return $this->_replyTo; } public function clearFrom() { $this->_from = null; $this->clearHeader('From'); return $this; } public function clearReplyTo() { $this->_replyTo = null; $this->clearHeader('Reply-To'); return $this; } public static function setDefaultFrom($email, $name = null) { self::$_defaultFrom = array('email' => $email, 'name' => $name); } public static function getDefaultFrom() { return self::$_defaultFrom; } public static function clearDefaultFrom() { self::$_defaultFrom = null; } public function setFromToDefaultFrom() { $from = self::getDefaultFrom(); if($from === null) { throw new Zend_Mail_Exception( 'No default From Address set to use'); } $this->setFrom($from['email'], $from['name']); return $this; } public static function setDefaultReplyTo($email, $name = null) { self::$_defaultReplyTo = array('email' => $email, 'name' => $name); } public static function getDefaultReplyTo() { return self::$_defaultReplyTo; } public static function clearDefaultReplyTo() { self::$_defaultReplyTo = null; } public function setReplyToFromDefault() { $replyTo = self::getDefaultReplyTo(); if($replyTo === null) { throw new Zend_Mail_Exception( 'No default Reply-To Address set to use'); } $this->setReplyTo($replyTo['email'], $replyTo['name']); return $this; } public function setReturnPath($email) { if ($this->_returnPath === null) { $email = $this->_filterEmail($email); $this->_returnPath = $email; $this->_storeHeader('Return-Path', $email, false); } else { throw new Zend_Mail_Exception('Return-Path Header set twice'); } return $this; } public function getReturnPath() { if (null !== $this->_returnPath) { return $this->_returnPath; } return $this->_from; } public function clearReturnPath() { $this->_returnPath = null; $this->clearHeader('Return-Path'); return $this; } public function setSubject($subject) { if ($this->_subject === null) { $subject = $this->_filterOther($subject); $this->_subject = $this->_encodeHeader($subject); $this->_storeHeader('Subject', $this->_subject); } else { throw new Zend_Mail_Exception('Subject set twice'); } return $this; } public function getSubject() { return $this->_subject; } public function clearSubject() { $this->_subject = null; $this->clearHeader('Subject'); return $this; } public function setDate($date = null) { if ($this->_date === null) { if ($date === null) { $date = date('r'); } else if (is_int($date)) { $date = date('r', $date); } else if (is_string($date)) { $date = strtotime($date); if ($date === false || $date < 0) { throw new Zend_Mail_Exception('String representations of Date Header must be ' . 'strtotime()-compatible'); } $date = date('r', $date); } else if ($date instanceof Zend_Date) { $date = $date->get(Zend_Date::RFC_2822); } else { throw new Zend_Mail_Exception(__METHOD__ . ' only accepts UNIX timestamps, Zend_Date objects, ' . ' and strtotime()-compatible strings'); } $this->_date = $date; $this->_storeHeader('Date', $date); } else { throw new Zend_Mail_Exception('Date Header set twice'); } return $this; } public function getDate() { return $this->_date; } public function clearDate() { $this->_date = null; $this->clearHeader('Date'); return $this; } public function setMessageId($id = true) { if ($id === null || $id === false) { return $this; } elseif ($id === true) { $id = $this->createMessageId(); } if ($this->_messageId === null) { $id = $this->_filterOther($id); $this->_messageId = $id; $this->_storeHeader('Message-Id', '<' . $this->_messageId . '>'); } else { throw new Zend_Mail_Exception('Message-ID set twice'); } return $this; } public function getMessageId() { return $this->_messageId; } public function clearMessageId() { $this->_messageId = null; $this->clearHeader('Message-Id'); return $this; } public function createMessageId() { $time = time(); if ($this->_from !== null) { $user = $this->_from; } elseif (isset($_SERVER['REMOTE_ADDR'])) { $user = $_SERVER['REMOTE_ADDR']; } else { $user = getmypid(); } $rand = mt_rand(); if ($this->_recipients !== array()) { $recipient = array_rand($this->_recipients); } else { $recipient = 'unknown'; } if (isset($_SERVER["SERVER_NAME"])) { $hostName = $_SERVER["SERVER_NAME"]; } else { $hostName = php_uname('n'); } return sha1($time . $user . $rand . $recipient) . '@' . $hostName; } public function addHeader($name, $value, $append = false) { $prohibit = array('to', 'cc', 'bcc', 'from', 'subject', 'reply-to', 'return-path', 'date', 'message-id', ); if (in_array(strtolower($name), $prohibit)) { throw new Zend_Mail_Exception('Cannot set standard header from addHeader()'); } $value = $this->_filterOther($value); $value = $this->_encodeHeader($value); $this->_storeHeader($name, $value, $append); return $this; } public function getHeaders() { return $this->_headers; } public function send($transport = null) { if ($transport === null) { if (! self::$_defaultTransport instanceof Zend_Mail_Transport_Abstract) { $transport = new Zend_Mail_Transport_Sendmail(); } else { $transport = self::$_defaultTransport; } } if ($this->_date === null) { $this->setDate(); } if(null === $this->_from && null !== self::getDefaultFrom()) { $this->setFromToDefaultFrom(); } if(null === $this->_replyTo && null !== self::getDefaultReplyTo()) { $this->setReplyToFromDefault(); } $transport->send($this); return $this; } protected function _filterEmail($email) { $rule = array("\r" => '', "\n" => '', "\t" => '', '"' => '', ',' => '', '<' => '', '>' => '', ); return strtr($email, $rule); } protected function _filterName($name) { $rule = array("\r" => '', "\n" => '', "\t" => '', '"' => "'", '<' => '[', '>' => ']', ); return trim(strtr($name, $rule)); } protected function _filterOther($data) { $rule = array("\r" => '', "\n" => '', "\t" => '', ); return strtr($data, $rule); } protected function _formatAddress($email, $name) { if ($name === '' || $name === null || $name === $email) { return $email; } else { $encodedName = $this->_encodeHeader($name); if ($encodedName === $name && strcspn($name, '()<>[]:;@\\,') != strlen($name)) { $format = '"%s" <%s>'; } else { $format = '%s <%s>'; } return sprintf($format, $encodedName, $email); } } } 

class Zend_Mail_Exception extends Zend_Exception {} 


interface Zend_Mail_Part_Interface extends RecursiveIterator { public function isMultipart(); public function getContent(); public function getSize(); public function getPart($num); public function countParts(); public function getHeaders(); public function getHeader($name, $format = null); public function getHeaderField($name, $wantedPart = 0, $firstName = 0); public function __get($name); public function __toString(); }

class Zend_Mail_Part implements RecursiveIterator, Zend_Mail_Part_Interface { protected $_headers; protected $_content; protected $_topLines = ''; protected $_parts = array(); protected $_countParts; protected $_iterationPos = 1; protected $_mail; protected $_messageNum = 0; public function __construct(array $params) { if (isset($params['handler'])) { if (!$params['handler'] instanceof Zend_Mail_Storage_Abstract) { throw new Zend_Mail_Exception('handler is not a valid mail handler'); } if (!isset($params['id'])) { throw new Zend_Mail_Exception('need a message id with a handler'); } $this->_mail = $params['handler']; $this->_messageNum = $params['id']; } if (isset($params['raw'])) { Zend_Mime_Decode::splitMessage($params['raw'], $this->_headers, $this->_content); } else if (isset($params['headers'])) { if (is_array($params['headers'])) { $this->_headers = $params['headers']; } else { if (!empty($params['noToplines'])) { Zend_Mime_Decode::splitMessage($params['headers'], $this->_headers, $null); } else { Zend_Mime_Decode::splitMessage($params['headers'], $this->_headers, $this->_topLines); } } if (isset($params['content'])) { $this->_content = $params['content']; } } } public function isMultipart() { try { return stripos($this->contentType, 'multipart/') === 0; } catch(Zend_Mail_Exception $e) { return false; } } public function getContent() { if ($this->_content !== null) { return $this->_content; } if ($this->_mail) { return $this->_mail->getRawContent($this->_messageNum); } else { throw new Zend_Mail_Exception('no content'); } } public function getSize() { return strlen($this->getContent()); } protected function _cacheContent() { if ($this->_content === null && $this->_mail) { $this->_content = $this->_mail->getRawContent($this->_messageNum); } if (!$this->isMultipart()) { return; } $boundary = $this->getHeaderField('content-type', 'boundary'); if (!$boundary) { throw new Zend_Mail_Exception('no boundary found in content type to split message'); } $parts = Zend_Mime_Decode::splitMessageStruct($this->_content, $boundary); if ($parts === null) { return; } $counter = 1; foreach ($parts as $part) { $this->_parts[$counter++] = new self(array('headers' => $part['header'], 'content' => $part['body'])); } } public function getPart($num) { if (isset($this->_parts[$num])) { return $this->_parts[$num]; } if (!$this->_mail && $this->_content === null) { throw new Zend_Mail_Exception('part not found'); } if ($this->_mail && $this->_mail->hasFetchPart) { } $this->_cacheContent(); if (!isset($this->_parts[$num])) { throw new Zend_Mail_Exception('part not found'); } return $this->_parts[$num]; } public function countParts() { if ($this->_countParts) { return $this->_countParts; } $this->_countParts = count($this->_parts); if ($this->_countParts) { return $this->_countParts; } if ($this->_mail && $this->_mail->hasFetchPart) { } $this->_cacheContent(); $this->_countParts = count($this->_parts); return $this->_countParts; } public function getHeaders() { if ($this->_headers === null) { if (!$this->_mail) { $this->_headers = array(); } else { $part = $this->_mail->getRawHeader($this->_messageNum); Zend_Mime_Decode::splitMessage($part, $this->_headers, $null); } } return $this->_headers; } public function getHeader($name, $format = null) { if ($this->_headers === null) { $this->getHeaders(); } $lowerName = strtolower($name); if ($this->headerExists($name) == false) { $lowerName = strtolower(preg_replace('%([a-z])([A-Z])%', '\1-\2', $name)); if($this->headerExists($lowerName) == false) { throw new Zend_Mail_Exception("no Header with Name $name or $lowerName found"); } } $name = $lowerName; $header = $this->_headers[$name]; switch ($format) { case 'string': if (is_array($header)) { $header = implode(Zend_Mime::LINEEND, $header); } break; case 'array': $header = (array)$header; default: } return $header; } public function headerExists($name) { $name = strtolower($name); if(isset($this->_headers[$name])) { return true; } else { return false; } } public function getHeaderField($name, $wantedPart = 0, $firstName = 0) { return Zend_Mime_Decode::splitHeaderField(current($this->getHeader($name, 'array')), $wantedPart, $firstName); } public function __get($name) { return $this->getHeader($name, 'string'); } public function __isset($name) { return $this->headerExists($name); } public function __toString() { return $this->getContent(); } public function hasChildren() { $current = $this->current(); return $current && $current instanceof Zend_Mail_Part && $current->isMultipart(); } public function getChildren() { return $this->current(); } public function valid() { if ($this->_countParts === null) { $this->countParts(); } return $this->_iterationPos && $this->_iterationPos <= $this->_countParts; } public function next() { ++$this->_iterationPos; } public function key() { return $this->_iterationPos; } public function current() { return $this->getPart($this->_iterationPos); } public function rewind() { $this->countParts(); $this->_iterationPos = 1; } } 

interface Zend_Mail_Message_Interface { public function getTopLines(); public function hasFlag($flag); public function getFlags(); }

class Zend_Mail_Message extends Zend_Mail_Part implements Zend_Mail_Message_Interface { protected $_flags = array(); public function __construct(array $params) { if (isset($params['file'])) { if (!is_resource($params['file'])) { $params['raw'] = @file_get_contents($params['file']); if ($params['raw'] === false) { throw new Zend_Mail_Exception('could not open file'); } } else { $params['raw'] = stream_get_contents($params['file']); } } if (!empty($params['flags'])) { $this->_flags = array_merge($this->_flags, array_combine($params['flags'],$params['flags'])); } parent::__construct($params); } public function getTopLines() { return $this->_topLines; } public function hasFlag($flag) { return isset($this->_flags[$flag]); } public function getFlags() { return $this->_flags; } } 

class Zend_Mail_Part_File extends Zend_Mail_Part { protected $_contentPos = array(); protected $_partPos = array(); protected $_fh; public function __construct(array $params) { if (empty($params['file'])) { throw new Zend_Mail_Exception('no file given in params'); } if (!is_resource($params['file'])) { $this->_fh = fopen($params['file'], 'r'); } else { $this->_fh = $params['file']; } if (!$this->_fh) { throw new Zend_Mail_Exception('could not open file'); } if (isset($params['startPos'])) { fseek($this->_fh, $params['startPos']); } $header = ''; $endPos = isset($params['endPos']) ? $params['endPos'] : null; while (($endPos === null || ftell($this->_fh) < $endPos) && trim($line = fgets($this->_fh))) { $header .= $line; } Zend_Mime_Decode::splitMessage($header, $this->_headers, $null); $this->_contentPos[0] = ftell($this->_fh); if ($endPos !== null) { $this->_contentPos[1] = $endPos; } else { fseek($this->_fh, 0, SEEK_END); $this->_contentPos[1] = ftell($this->_fh); } if (!$this->isMultipart()) { return; } $boundary = $this->getHeaderField('content-type', 'boundary'); if (!$boundary) { throw new Zend_Mail_Exception('no boundary found in content type to split message'); } $part = array(); $pos = $this->_contentPos[0]; fseek($this->_fh, $pos); while (!feof($this->_fh) && ($endPos === null || $pos < $endPos)) { $line = fgets($this->_fh); if ($line === false) { if (feof($this->_fh)) { break; } throw new Zend_Mail_Exception('error reading file'); } $lastPos = $pos; $pos = ftell($this->_fh); $line = trim($line); if ($line == '--' . $boundary) { if ($part) { $part[1] = $lastPos; $this->_partPos[] = $part; } $part = array($pos); } else if ($line == '--' . $boundary . '--') { $part[1] = $lastPos; $this->_partPos[] = $part; break; } } $this->_countParts = count($this->_partPos); } public function getContent($stream = null) { fseek($this->_fh, $this->_contentPos[0]); if ($stream !== null) { return stream_copy_to_stream($this->_fh, $stream, $this->_contentPos[1] - $this->_contentPos[0]); } $length = $this->_contentPos[1] - $this->_contentPos[0]; return $length < 1 ? '' : fread($this->_fh, $length); } public function getSize() { return $this->_contentPos[1] - $this->_contentPos[0]; } public function getPart($num) { --$num; if (!isset($this->_partPos[$num])) { throw new Zend_Mail_Exception('part not found'); } return new self(array('file' => $this->_fh, 'startPos' => $this->_partPos[$num][0], 'endPos' => $this->_partPos[$num][1])); } } 

abstract class Zend_Mail_Transport_Abstract { public $body = ''; public $boundary = ''; public $header = ''; protected $_headers = array(); protected $_isMultipart = false; protected $_mail = false; protected $_parts = array(); public $recipients = ''; public $EOL = "\r\n"; abstract protected function _sendMail(); protected function _getHeaders($boundary) { if (null !== $boundary) { $type = $this->_mail->getType(); if (!$type) { if ($this->_mail->hasAttachments) { $type = Zend_Mime::MULTIPART_MIXED; } elseif ($this->_mail->getBodyText() && $this->_mail->getBodyHtml()) { $type = Zend_Mime::MULTIPART_ALTERNATIVE; } else { $type = Zend_Mime::MULTIPART_MIXED; } } $this->_headers['Content-Type'] = array( $type . ';' . $this->EOL . " " . 'boundary="' . $boundary . '"' ); $this->boundary = $boundary; } $this->_headers['MIME-Version'] = array('1.0'); return $this->_headers; } protected static function _formatHeader(&$item, $key, $prefix) { $item = $prefix . ': ' . $item; } protected function _prepareHeaders($headers) { if (!$this->_mail) { throw new Zend_Mail_Transport_Exception('Missing Zend_Mail object in _mail property'); } $this->header = ''; foreach ($headers as $header => $content) { if (isset($content['append'])) { unset($content['append']); $value = implode(',' . $this->EOL . ' ', $content); $this->header .= $header . ': ' . $value . $this->EOL; } else { array_walk($content, array(get_class($this), '_formatHeader'), $header); $this->header .= implode($this->EOL, $content) . $this->EOL; } } $sane = true; foreach (explode($this->EOL, $this->header) as $line) { if (strlen(trim($line)) > 998) { $sane = false; break; } } if (!$sane) { throw new Zend_Mail_Exception('At least one mail header line is too long'); } } protected function _buildBody() { if (($text = $this->_mail->getBodyText()) && ($html = $this->_mail->getBodyHtml())) { $mime = new Zend_Mime(null); $boundaryLine = $mime->boundaryLine($this->EOL); $boundaryEnd = $mime->mimeEnd($this->EOL); $text->disposition = false; $html->disposition = false; $body = $boundaryLine . $text->getHeaders($this->EOL) . $this->EOL . $text->getContent($this->EOL) . $this->EOL . $boundaryLine . $html->getHeaders($this->EOL) . $this->EOL . $html->getContent($this->EOL) . $this->EOL . $boundaryEnd; $mp = new Zend_Mime_Part($body); $mp->type = Zend_Mime::MULTIPART_ALTERNATIVE; $mp->boundary = $mime->boundary(); $this->_isMultipart = true; array_unshift($this->_parts, $mp); $this->_headers = $this->_mail->getHeaders(); return; } if (false !== ($body = $this->_mail->getBodyHtml())) { array_unshift($this->_parts, $body); } elseif (false !== ($body = $this->_mail->getBodyText())) { array_unshift($this->_parts, $body); } if (!$body) { throw new Zend_Mail_Transport_Exception('No body specified'); } $this->_headers = $this->_mail->getHeaders(); $headers = $body->getHeadersArray($this->EOL); foreach ($headers as $header) { $this->_headers[$header[0]] = array($header[1]); } } public function send(Zend_Mail $mail) { $this->_isMultipart = false; $this->_mail = $mail; $this->_parts = $mail->getParts(); $mime = $mail->getMime(); $this->_buildBody(); $count = count($this->_parts); $boundary = null; if ($count < 1) { throw new Zend_Mail_Transport_Exception('Empty mail cannot be sent'); } if ($count > 1) { $mime = new Zend_Mime($this->_mail->getMimeBoundary()); $boundary = $mime->boundary(); } elseif ($this->_isMultipart) { $boundary = $this->_parts[0]->boundary; } $this->recipients = implode(',', $mail->getRecipients()); $this->_prepareHeaders($this->_getHeaders($boundary)); $message = new Zend_Mime_Message(); $message->setParts($this->_parts); $message->setMime($mime); $this->body = $message->generateMessage($this->EOL); $this->_sendMail(); } } 

class Zend_Mail_Transport_Sendmail extends Zend_Mail_Transport_Abstract { public $subject = null; public $parameters; public $EOL = PHP_EOL; protected $_errstr; public function __construct($parameters = null) { if ($parameters instanceof Zend_Config) { $parameters = $parameters->toArray(); } if (is_array($parameters)) { $parameters = implode(' ', $parameters); } $this->parameters = $parameters; } public function _sendMail() { if ($this->parameters === null) { set_error_handler(array($this, '_handleMailErrors')); $result = mail( $this->recipients, $this->_mail->getSubject(), $this->body, $this->header); restore_error_handler(); } else { if(!is_string($this->parameters)) { throw new Zend_Mail_Transport_Exception( 'Parameters were set but are not a string' ); } set_error_handler(array($this, '_handleMailErrors')); $result = mail( $this->recipients, $this->_mail->getSubject(), $this->body, $this->header, $this->parameters); restore_error_handler(); } if ($this->_errstr !== null || !$result) { throw new Zend_Mail_Transport_Exception('Unable to send mail. ' . $this->_errstr); } } protected function _prepareHeaders($headers) { if (!$this->_mail) { throw new Zend_Mail_Transport_Exception('_prepareHeaders requires a registered Zend_Mail object'); } if (0 === strpos(PHP_OS, 'WIN')) { if (empty($this->recipients)) { throw new Zend_Mail_Transport_Exception('Missing To addresses'); } } else { if (!isset($headers['To'])) { throw new Zend_Mail_Transport_Exception('Missing To header'); } unset($headers['To']['append']); $this->recipients = implode(',', $headers['To']); } unset($headers['To']); if (isset($headers['Subject'])) { unset($headers['Subject']); } parent::_prepareHeaders($headers); $this->header = rtrim($this->header); } public function _handleMailErrors($errno, $errstr, $errfile = null, $errline = null, array $errcontext = null) { $this->_errstr = $errstr; return true; } } 

class Zend_Mime { const TYPE_OCTETSTREAM = 'application/octet-stream'; const TYPE_TEXT = 'text/plain'; const TYPE_HTML = 'text/html'; const ENCODING_7BIT = '7bit'; const ENCODING_8BIT = '8bit'; const ENCODING_QUOTEDPRINTABLE = 'quoted-printable'; const ENCODING_BASE64 = 'base64'; const DISPOSITION_ATTACHMENT = 'attachment'; const DISPOSITION_INLINE = 'inline'; const LINELENGTH = 72; const LINEEND = "\n"; const MULTIPART_ALTERNATIVE = 'multipart/alternative'; const MULTIPART_MIXED = 'multipart/mixed'; const MULTIPART_RELATED = 'multipart/related'; protected $_boundary; protected static $makeUnique = 0; public static $qpKeys = array( "\x00","\x01","\x02","\x03","\x04","\x05","\x06","\x07", "\x08","\x09","\x0A","\x0B","\x0C","\x0D","\x0E","\x0F", "\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17", "\x18","\x19","\x1A","\x1B","\x1C","\x1D","\x1E","\x1F", "\x7F","\x80","\x81","\x82","\x83","\x84","\x85","\x86", "\x87","\x88","\x89","\x8A","\x8B","\x8C","\x8D","\x8E", "\x8F","\x90","\x91","\x92","\x93","\x94","\x95","\x96", "\x97","\x98","\x99","\x9A","\x9B","\x9C","\x9D","\x9E", "\x9F","\xA0","\xA1","\xA2","\xA3","\xA4","\xA5","\xA6", "\xA7","\xA8","\xA9","\xAA","\xAB","\xAC","\xAD","\xAE", "\xAF","\xB0","\xB1","\xB2","\xB3","\xB4","\xB5","\xB6", "\xB7","\xB8","\xB9","\xBA","\xBB","\xBC","\xBD","\xBE", "\xBF","\xC0","\xC1","\xC2","\xC3","\xC4","\xC5","\xC6", "\xC7","\xC8","\xC9","\xCA","\xCB","\xCC","\xCD","\xCE", "\xCF","\xD0","\xD1","\xD2","\xD3","\xD4","\xD5","\xD6", "\xD7","\xD8","\xD9","\xDA","\xDB","\xDC","\xDD","\xDE", "\xDF","\xE0","\xE1","\xE2","\xE3","\xE4","\xE5","\xE6", "\xE7","\xE8","\xE9","\xEA","\xEB","\xEC","\xED","\xEE", "\xEF","\xF0","\xF1","\xF2","\xF3","\xF4","\xF5","\xF6", "\xF7","\xF8","\xF9","\xFA","\xFB","\xFC","\xFD","\xFE", "\xFF" ); public static $qpReplaceValues = array( "=00","=01","=02","=03","=04","=05","=06","=07", "=08","=09","=0A","=0B","=0C","=0D","=0E","=0F", "=10","=11","=12","=13","=14","=15","=16","=17", "=18","=19","=1A","=1B","=1C","=1D","=1E","=1F", "=7F","=80","=81","=82","=83","=84","=85","=86", "=87","=88","=89","=8A","=8B","=8C","=8D","=8E", "=8F","=90","=91","=92","=93","=94","=95","=96", "=97","=98","=99","=9A","=9B","=9C","=9D","=9E", "=9F","=A0","=A1","=A2","=A3","=A4","=A5","=A6", "=A7","=A8","=A9","=AA","=AB","=AC","=AD","=AE", "=AF","=B0","=B1","=B2","=B3","=B4","=B5","=B6", "=B7","=B8","=B9","=BA","=BB","=BC","=BD","=BE", "=BF","=C0","=C1","=C2","=C3","=C4","=C5","=C6", "=C7","=C8","=C9","=CA","=CB","=CC","=CD","=CE", "=CF","=D0","=D1","=D2","=D3","=D4","=D5","=D6", "=D7","=D8","=D9","=DA","=DB","=DC","=DD","=DE", "=DF","=E0","=E1","=E2","=E3","=E4","=E5","=E6", "=E7","=E8","=E9","=EA","=EB","=EC","=ED","=EE", "=EF","=F0","=F1","=F2","=F3","=F4","=F5","=F6", "=F7","=F8","=F9","=FA","=FB","=FC","=FD","=FE", "=FF" ); public static $qpKeysString = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x7F\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"; public static function isPrintable($str) { return (strcspn($str, self::$qpKeysString) == strlen($str)); } public static function encodeQuotedPrintable($str, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { $out = ''; $str = self::_encodeQuotedPrintable($str); while ($str) { $ptr = strlen($str); if ($ptr > $lineLength) { $ptr = $lineLength; } $pos = strrpos(substr($str, 0, $ptr), '='); if ($pos !== false && $pos >= $ptr - 2) { $ptr = $pos; } if ($ptr > 0 && $str[$ptr - 1] == ' ') { --$ptr; } $out .= substr($str, 0, $ptr) . '=' . $lineEnd; $str = substr($str, $ptr); } $out = rtrim($out, $lineEnd); $out = rtrim($out, '='); return $out; } private static function _encodeQuotedPrintable($str) { $str = str_replace('=', '=3D', $str); $str = str_replace(self::$qpKeys, self::$qpReplaceValues, $str); $str = rtrim($str); return $str; } public static function encodeQuotedPrintableHeader($str, $charset, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { $prefix = sprintf('=?%s?Q?', $charset); $lineLength = $lineLength-strlen($prefix)-3; $str = self::_encodeQuotedPrintable($str); $str = str_replace(array('?', ' ', '_'), array('=3F', '=20', '=5F'), $str); $lines = array(0 => ""); $tmp = ""; while(strlen($str) > 0) { $currentLine = max(count($lines)-1, 0); $token = self::getNextQuotedPrintableToken($str); $str = substr($str, strlen($token)); $tmp .= $token; if($token == '=20') { if(strlen($lines[$currentLine].$tmp) > $lineLength) { $lines[$currentLine+1] = $tmp; } else { $lines[$currentLine] .= $tmp; } $tmp = ""; } if(strlen($str) == 0) { $lines[$currentLine] .= $tmp; } } for($i = 0; $i < count($lines); $i++) { $lines[$i] = " ".$prefix.$lines[$i]."?="; } $str = trim(implode($lineEnd, $lines)); return $str; } private static function getNextQuotedPrintableToken($str) { if(substr($str, 0, 1) == "=") { $token = substr($str, 0, 3); } else { $token = substr($str, 0, 1); } return $token; } public static function encodeBase64Header($str, $charset, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { $prefix = '=?' . $charset . '?B?'; $suffix = '?='; $remainingLength = $lineLength - strlen($prefix) - strlen($suffix); $encodedValue = self::encodeBase64($str, $remainingLength, $lineEnd); $encodedValue = str_replace($lineEnd, $suffix . $lineEnd . ' ' . $prefix, $encodedValue); $encodedValue = $prefix . $encodedValue . $suffix; return $encodedValue; } public static function encodeBase64($str, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { return rtrim(chunk_split(base64_encode($str), $lineLength, $lineEnd)); } public function __construct($boundary = null) { if ($boundary === null) { $this->_boundary = '=_' . md5(microtime(1) . self::$makeUnique++); } else { $this->_boundary = $boundary; } } public static function encode($str, $encoding, $EOL = self::LINEEND) { switch ($encoding) { case self::ENCODING_BASE64: return self::encodeBase64($str, self::LINELENGTH, $EOL); case self::ENCODING_QUOTEDPRINTABLE: return self::encodeQuotedPrintable($str, self::LINELENGTH, $EOL); default: return $str; } } public function boundary() { return $this->_boundary; } public function boundaryLine($EOL = self::LINEEND) { return $EOL . '--' . $this->_boundary . $EOL; } public function mimeEnd($EOL = self::LINEEND) { return $EOL . '--' . $this->_boundary . '--' . $EOL; } } 

class Zend_Mime_Decode { public static function splitMime($body, $boundary) { $body = str_replace("\r", '', $body); $start = 0; $res = array(); $p = strpos($body, '--' . $boundary . "\n", $start); if ($p === false) { return array(); } $start = $p + 3 + strlen($boundary); while (($p = strpos($body, '--' . $boundary . "\n", $start)) !== false) { $res[] = substr($body, $start, $p-$start); $start = $p + 3 + strlen($boundary); } $p = strpos($body, '--' . $boundary . '--', $start); if ($p===false) { throw new Zend_Exception('Not a valid Mime Message: End Missing'); } $res[] = substr($body, $start, $p-$start); return $res; } public static function splitMessageStruct($message, $boundary, $EOL = Zend_Mime::LINEEND) { $parts = self::splitMime($message, $boundary); if (count($parts) <= 0) { return null; } $result = array(); foreach ($parts as $part) { self::splitMessage($part, $headers, $body, $EOL); $result[] = array('header' => $headers, 'body' => $body ); } return $result; } public static function splitMessage($message, &$headers, &$body, $EOL = Zend_Mime::LINEEND) { $firstline = strtok($message, "\n"); if (!preg_match('%^[^\s]+[^:]*:%', $firstline)) { $headers = array(); $body = str_replace(array("\r", "\n"), array('', $EOL), $message); return; } if (strpos($message, $EOL . $EOL)) { list($headers, $body) = explode($EOL . $EOL, $message, 2); } else if ($EOL != "\r\n" && strpos($message, "\r\n\r\n")) { list($headers, $body) = explode("\r\n\r\n", $message, 2); } else if ($EOL != "\n" && strpos($message, "\n\n")) { list($headers, $body) = explode("\n\n", $message, 2); } else { @list($headers, $body) = @preg_split("%([\r\n]+)\\1%U", $message, 2); } $headers = iconv_mime_decode_headers($headers, ICONV_MIME_DECODE_CONTINUE_ON_ERROR); if ($headers === false ) { return; } foreach ($headers as $name => $header) { $lower = strtolower($name); if ($lower == $name) { continue; } unset($headers[$name]); if (!isset($headers[$lower])) { $headers[$lower] = $header; continue; } if (is_array($headers[$lower])) { $headers[$lower][] = $header; continue; } $headers[$lower] = array($headers[$lower], $header); } } public static function splitContentType($type, $wantedPart = null) { return self::splitHeaderField($type, $wantedPart, 'type'); } public static function splitHeaderField($field, $wantedPart = null, $firstName = 0) { $wantedPart = strtolower($wantedPart); $firstName = strtolower($firstName); if ($firstName === $wantedPart) { $field = strtok($field, ';'); return $field[0] == '"' ? substr($field, 1, -1) : $field; } $field = $firstName . '=' . $field; if (!preg_match_all('%([^=\s]+)\s*=\s*("[^"]+"|[^;]+)(;\s*|$)%', $field, $matches)) { throw new Zend_Exception('not a valid header field'); } if ($wantedPart) { foreach ($matches[1] as $key => $name) { if (strcasecmp($name, $wantedPart)) { continue; } if ($matches[2][$key][0] != '"') { return $matches[2][$key]; } return substr($matches[2][$key], 1, -1); } return null; } $split = array(); foreach ($matches[1] as $key => $name) { $name = strtolower($name); if ($matches[2][$key][0] == '"') { $split[$name] = substr($matches[2][$key], 1, -1); } else { $split[$name] = $matches[2][$key]; } } return $split; } public static function decodeQuotedPrintable($string) { return quoted_printable_decode($string); } } 

class Zend_Mime_Exception extends Zend_Exception {} 

class Zend_Mime_Part { public $type = Zend_Mime::TYPE_OCTETSTREAM; public $encoding = Zend_Mime::ENCODING_8BIT; public $id; public $disposition; public $filename; public $description; public $charset; public $boundary; public $location; public $language; protected $_content; protected $_isStream = false; public function __construct($content) { $this->_content = $content; if (is_resource($content)) { $this->_isStream = true; } } public function isStream() { return $this->_isStream; } public function getEncodedStream() { if (!$this->_isStream) { throw new Zend_Mime_Exception('Attempt to get a stream from a string part'); } switch ($this->encoding) { case Zend_Mime::ENCODING_QUOTEDPRINTABLE: $filter = stream_filter_append( $this->_content, 'convert.quoted-printable-encode', STREAM_FILTER_READ, array( 'line-length' => 76, 'line-break-chars' => Zend_Mime::LINEEND ) ); if (!is_resource($filter)) { throw new Zend_Mime_Exception('Failed to append quoted-printable filter'); } break; case Zend_Mime::ENCODING_BASE64: $filter = stream_filter_append( $this->_content, 'convert.base64-encode', STREAM_FILTER_READ, array( 'line-length' => 76, 'line-break-chars' => Zend_Mime::LINEEND ) ); if (!is_resource($filter)) { throw new Zend_Mime_Exception('Failed to append base64 filter'); } break; default: } return $this->_content; } public function getContent($EOL = Zend_Mime::LINEEND) { if ($this->_isStream) { return stream_get_contents($this->getEncodedStream()); } else { return Zend_Mime::encode($this->_content, $this->encoding, $EOL); } } public function getRawContent() { if ($this->_isStream) { return stream_get_contents($this->_content); } else { return $this->_content; } } public function getHeadersArray($EOL = Zend_Mime::LINEEND) { $headers = array(); $contentType = $this->type; if ($this->charset) { $contentType .= '; charset=' . $this->charset; } if ($this->boundary) { $contentType .= ';' . $EOL . " boundary=\"" . $this->boundary . '"'; } $headers[] = array('Content-Type', $contentType); if ($this->encoding) { $headers[] = array('Content-Transfer-Encoding', $this->encoding); } if ($this->id) { $headers[] = array('Content-ID', '<' . $this->id . '>'); } if ($this->disposition) { $disposition = $this->disposition; if ($this->filename) { $disposition .= '; filename="' . $this->filename . '"'; } $headers[] = array('Content-Disposition', $disposition); } if ($this->description) { $headers[] = array('Content-Description', $this->description); } if ($this->location) { $headers[] = array('Content-Location', $this->location); } if ($this->language){ $headers[] = array('Content-Language', $this->language); } return $headers; } public function getHeaders($EOL = Zend_Mime::LINEEND) { $res = ''; foreach ($this->getHeadersArray($EOL) as $header) { $res .= $header[0] . ': ' . $header[1] . $EOL; } return $res; } } 

class Zend_Loader { public static function loadClass($class, $dirs = null) { if (class_exists($class, false) || interface_exists($class, false)) { return; } if ((null !== $dirs) && !is_string($dirs) && !is_array($dirs)) { throw new Zend_Exception('Directory argument must be a string or an array'); } $className = ltrim($class, '\\'); $file = ''; $namespace = ''; if ($lastNsPos = strripos($className, '\\')) { $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $file = str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; } $file .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; if (!empty($dirs)) { $dirPath = dirname($file); if (is_string($dirs)) { $dirs = explode(PATH_SEPARATOR, $dirs); } foreach ($dirs as $key => $dir) { if ($dir == '.') { $dirs[$key] = $dirPath; } else { $dir = rtrim($dir, '\\/'); $dirs[$key] = $dir . DIRECTORY_SEPARATOR . $dirPath; } } $file = basename($file); self::loadFile($file, $dirs, true); } else { self::loadFile($file, null, true); } if (!class_exists($class, false) && !interface_exists($class, false)) { throw new Zend_Exception("File \"$file\" does not exist or class \"$class\" was not found in the file"); } } public static function loadFile($filename, $dirs = null, $once = false) { self::_securityCheck($filename); $incPath = false; if (!empty($dirs) && (is_array($dirs) || is_string($dirs))) { if (is_array($dirs)) { $dirs = implode(PATH_SEPARATOR, $dirs); } $incPath = get_include_path(); set_include_path($dirs . PATH_SEPARATOR . $incPath); } if ($once) { include_once $filename; } else { include $filename; } if ($incPath) { set_include_path($incPath); } return true; } public static function isReadable($filename) { if (is_readable($filename)) { return true; } if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN' && preg_match('/^[a-z]:/i', $filename) ) { return false; } foreach (self::explodeIncludePath() as $path) { if ($path == '.') { if (is_readable($filename)) { return true; } continue; } $file = $path . '/' . $filename; if (is_readable($file)) { return true; } } return false; } public static function explodeIncludePath($path = null) { if (null === $path) { $path = get_include_path(); } if (PATH_SEPARATOR == ':') { $paths = preg_split('#:(?!//)#', $path); } else { $paths = explode(PATH_SEPARATOR, $path); } return $paths; } public static function autoload($class) { trigger_error(__CLASS__ . '::' . __METHOD__ . ' is deprecated as of 1.8.0 and will be removed with 2.0.0; use Zend_Loader_Autoloader instead', E_USER_NOTICE); try { @self::loadClass($class); return $class; } catch (Exception $e) { return false; } } public static function registerAutoload($class = 'Zend_Loader', $enabled = true) { trigger_error(__CLASS__ . '::' . __METHOD__ . ' is deprecated as of 1.8.0 and will be removed with 2.0.0; use Zend_Loader_Autoloader instead', E_USER_NOTICE); $autoloader = Zend_Loader_Autoloader::getInstance(); $autoloader->setFallbackAutoloader(true); if ('Zend_Loader' != $class) { self::loadClass($class); $methods = get_class_methods($class); if (!in_array('autoload', (array) $methods)) { throw new Zend_Exception("The class \"$class\" does not have an autoload() method"); } $callback = array($class, 'autoload'); if ($enabled) { $autoloader->pushAutoloader($callback); } else { $autoloader->removeAutoloader($callback); } } } protected static function _securityCheck($filename) { if (preg_match('/[^a-z0-9\\/\\\\_.:-]/i', $filename)) { throw new Zend_Exception('Security check: Illegal character in filename'); } } protected static function _includeFile($filespec, $once = false) { if ($once) { return include_once $filespec; } else { return include $filespec ; } } } 

class Zend_Loader_Autoloader { protected static $_instance; protected $_autoloaders = array(); protected $_defaultAutoloader = array('Zend_Loader', 'loadClass'); protected $_fallbackAutoloader = false; protected $_internalAutoloader; protected $_namespaces = array( 'Zend_' => true, 'ZendX_' => true, ); protected $_namespaceAutoloaders = array(); protected $_suppressNotFoundWarnings = false; protected $_zfPath; public static function getInstance() { if (null === self::$_instance) { self::$_instance = new self(); } return self::$_instance; } public static function resetInstance() { self::$_instance = null; } public static function autoload($class) { $self = self::getInstance(); foreach ($self->getClassAutoloaders($class) as $autoloader) { if ($autoloader instanceof Zend_Loader_Autoloader_Interface) { if ($autoloader->autoload($class)) { return true; } } elseif (is_array($autoloader)) { if (call_user_func($autoloader, $class)) { return true; } } elseif (is_string($autoloader) || is_callable($autoloader)) { if ($autoloader($class)) { return true; } } } return false; } public function setDefaultAutoloader($callback) { if (!is_callable($callback)) { throw new Zend_Loader_Exception('Invalid callback specified for default autoloader'); } $this->_defaultAutoloader = $callback; return $this; } public function getDefaultAutoloader() { return $this->_defaultAutoloader; } public function setAutoloaders(array $autoloaders) { $this->_autoloaders = $autoloaders; return $this; } public function getAutoloaders() { return $this->_autoloaders; } public function getNamespaceAutoloaders($namespace) { $namespace = (string) $namespace; if (!array_key_exists($namespace, $this->_namespaceAutoloaders)) { return array(); } return $this->_namespaceAutoloaders[$namespace]; } public function registerNamespace($namespace) { if (is_string($namespace)) { $namespace = (array) $namespace; } elseif (!is_array($namespace)) { throw new Zend_Loader_Exception('Invalid namespace provided'); } foreach ($namespace as $ns) { if (!isset($this->_namespaces[$ns])) { $this->_namespaces[$ns] = true; } } return $this; } public function unregisterNamespace($namespace) { if (is_string($namespace)) { $namespace = (array) $namespace; } elseif (!is_array($namespace)) { throw new Zend_Loader_Exception('Invalid namespace provided'); } foreach ($namespace as $ns) { if (isset($this->_namespaces[$ns])) { unset($this->_namespaces[$ns]); } } return $this; } public function getRegisteredNamespaces() { return array_keys($this->_namespaces); } public function setZfPath($spec, $version = 'latest') { $path = $spec; if (is_array($spec)) { if (!isset($spec['path'])) { throw new Zend_Loader_Exception('No path specified for ZF'); } $path = $spec['path']; if (isset($spec['version'])) { $version = $spec['version']; } } $this->_zfPath = $this->_getVersionPath($path, $version); set_include_path(implode(PATH_SEPARATOR, array( $this->_zfPath, get_include_path(), ))); return $this; } public function getZfPath() { return $this->_zfPath; } public function suppressNotFoundWarnings($flag = null) { if (null === $flag) { return $this->_suppressNotFoundWarnings; } $this->_suppressNotFoundWarnings = (bool) $flag; return $this; } public function setFallbackAutoloader($flag) { $this->_fallbackAutoloader = (bool) $flag; return $this; } public function isFallbackAutoloader() { return $this->_fallbackAutoloader; } public function getClassAutoloaders($class) { $namespace = false; $autoloaders = array(); foreach (array_keys($this->_namespaceAutoloaders) as $ns) { if ('' == $ns) { continue; } if (0 === strpos($class, $ns)) { if ((false === $namespace) || (strlen($ns) > strlen($namespace))) { $namespace = $ns; $autoloaders = $this->getNamespaceAutoloaders($ns); } } } foreach ($this->getRegisteredNamespaces() as $ns) { if (0 === strpos($class, $ns)) { $namespace = $ns; $autoloaders[] = $this->_internalAutoloader; break; } } $autoloadersNonNamespace = $this->getNamespaceAutoloaders(''); if (count($autoloadersNonNamespace)) { foreach ($autoloadersNonNamespace as $ns) { $autoloaders[] = $ns; } unset($autoloadersNonNamespace); } if (!$namespace && $this->isFallbackAutoloader()) { $autoloaders[] = $this->_internalAutoloader; } return $autoloaders; } public function unshiftAutoloader($callback, $namespace = '') { $autoloaders = $this->getAutoloaders(); array_unshift($autoloaders, $callback); $this->setAutoloaders($autoloaders); $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); array_unshift($autoloaders, $callback); $this->_setNamespaceAutoloaders($autoloaders, $ns); } return $this; } public function pushAutoloader($callback, $namespace = '') { $autoloaders = $this->getAutoloaders(); array_push($autoloaders, $callback); $this->setAutoloaders($autoloaders); $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); array_push($autoloaders, $callback); $this->_setNamespaceAutoloaders($autoloaders, $ns); } return $this; } public function removeAutoloader($callback, $namespace = null) { if (null === $namespace) { $autoloaders = $this->getAutoloaders(); if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->setAutoloaders($autoloaders); } foreach ($this->_namespaceAutoloaders as $ns => $autoloaders) { if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->_setNamespaceAutoloaders($autoloaders, $ns); } } } else { $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->_setNamespaceAutoloaders($autoloaders, $ns); } } } return $this; } protected function __construct() { spl_autoload_register(array(__CLASS__, 'autoload')); $this->_internalAutoloader = array($this, '_autoload'); } protected function _autoload($class) { $callback = $this->getDefaultAutoloader(); try { if ($this->suppressNotFoundWarnings()) { @call_user_func($callback, $class); } else { call_user_func($callback, $class); } return $class; } catch (Zend_Exception $e) { return false; } } protected function _setNamespaceAutoloaders(array $autoloaders, $namespace = '') { $namespace = (string) $namespace; $this->_namespaceAutoloaders[$namespace] = $autoloaders; return $this; } protected function _getVersionPath($path, $version) { $type = $this->_getVersionType($version); if ($type == 'latest') { $version = 'latest'; } $availableVersions = $this->_getAvailableVersions($path, $version); if (empty($availableVersions)) { throw new Zend_Loader_Exception('No valid ZF installations discovered'); } $matchedVersion = array_pop($availableVersions); return $matchedVersion; } protected function _getVersionType($version) { if (strtolower($version) == 'latest') { return 'latest'; } $parts = explode('.', $version); $count = count($parts); if (1 == $count) { return 'major'; } if (2 == $count) { return 'minor'; } if (3 < $count) { throw new Zend_Loader_Exception('Invalid version string provided'); } return 'specific'; } protected function _getAvailableVersions($path, $version) { if (!is_dir($path)) { throw new Zend_Loader_Exception('Invalid ZF path provided'); } $path = rtrim($path, '/'); $path = rtrim($path, '\\'); $versionLen = strlen($version); $versions = array(); $dirs = glob("$path/*", GLOB_ONLYDIR); foreach ((array) $dirs as $dir) { $dirName = substr($dir, strlen($path) + 1); if (!preg_match('/^(?:ZendFramework-)?(\d+\.\d+\.\d+((a|b|pl|pr|p|rc)\d+)?)(?:-minimal)?$/i', $dirName, $matches)) { continue; } $matchedVersion = $matches[1]; if (('latest' == $version) || ((strlen($matchedVersion) >= $versionLen) && (0 === strpos($matchedVersion, $version))) ) { $versions[$matchedVersion] = $dir . '/library'; } } uksort($versions, 'version_compare'); return $versions; } } 

class Zend_Db { const PROFILER = 'profiler'; const CASE_FOLDING = 'caseFolding'; const FETCH_MODE = 'fetchMode'; const AUTO_QUOTE_IDENTIFIERS = 'autoQuoteIdentifiers'; const ALLOW_SERIALIZATION = 'allowSerialization'; const AUTO_RECONNECT_ON_UNSERIALIZE = 'autoReconnectOnUnserialize'; const INT_TYPE = 0; const BIGINT_TYPE = 1; const FLOAT_TYPE = 2; const ATTR_AUTOCOMMIT = 0; const ATTR_CASE = 8; const ATTR_CLIENT_VERSION = 5; const ATTR_CONNECTION_STATUS = 7; const ATTR_CURSOR = 10; const ATTR_CURSOR_NAME = 9; const ATTR_DRIVER_NAME = 16; const ATTR_ERRMODE = 3; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_PREFETCH = 1; const ATTR_SERVER_INFO = 6; const ATTR_SERVER_VERSION = 4; const ATTR_STATEMENT_CLASS = 13; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_TIMEOUT = 2; const CASE_LOWER = 2; const CASE_NATURAL = 0; const CASE_UPPER = 1; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERR_ALREADY_EXISTS = NULL; const ERR_CANT_MAP = NULL; const ERR_CONSTRAINT = NULL; const ERR_DISCONNECTED = NULL; const ERR_MISMATCH = NULL; const ERR_NO_PERM = NULL; const ERR_NONE = '00000'; const ERR_NOT_FOUND = NULL; const ERR_NOT_IMPLEMENTED = NULL; const ERR_SYNTAX = NULL; const ERR_TRUNCATED = NULL; const ERRMODE_EXCEPTION = 2; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const FETCH_ASSOC = 2; const FETCH_BOTH = 4; const FETCH_BOUND = 6; const FETCH_CLASS = 8; const FETCH_CLASSTYPE = 262144; const FETCH_COLUMN = 7; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_INTO = 9; const FETCH_LAZY = 1; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_OBJ = 5; const FETCH_ORI_ABS = 4; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_REL = 5; const FETCH_SERIALIZE = 524288; const FETCH_UNIQUE = 196608; const NULL_EMPTY_STRING = 1; const NULL_NATURAL = 0; const NULL_TO_STRING = NULL; const PARAM_BOOL = 5; const PARAM_INPUT_OUTPUT = -2147483648; const PARAM_INT = 1; const PARAM_LOB = 3; const PARAM_NULL = 0; const PARAM_STMT = 4; const PARAM_STR = 2; public static function factory($adapter, $config = array()) { if ($config instanceof Zend_Config) { $config = $config->toArray(); } if ($adapter instanceof Zend_Config) { if (isset($adapter->params)) { $config = $adapter->params->toArray(); } if (isset($adapter->adapter)) { $adapter = (string) $adapter->adapter; } else { $adapter = null; } } if (!is_array($config)) { throw new Zend_Db_Exception('Adapter parameters must be in an array or a Zend_Config object'); } if (!is_string($adapter) || empty($adapter)) { throw new Zend_Db_Exception('Adapter name must be specified in a string'); } $adapterNamespace = 'Zend_Db_Adapter'; if (isset($config['adapterNamespace'])) { if ($config['adapterNamespace'] != '') { $adapterNamespace = $config['adapterNamespace']; } unset($config['adapterNamespace']); } $adapterName = $adapterNamespace . '_'; $adapterName .= str_replace(' ', '_', ucwords(str_replace('_', ' ', strtolower($adapter)))); if (!class_exists($adapterName)) { Zend_Loader::loadClass($adapterName); } $dbAdapter = new $adapterName($config); if (! $dbAdapter instanceof Zend_Db_Adapter_Abstract) { throw new Zend_Db_Exception("Adapter class '$adapterName' does not extend Zend_Db_Adapter_Abstract"); } return $dbAdapter; } } 

class Zend_Db_Adapter_Exception extends Zend_Db_Exception { protected $_chainedException = null; public function __construct($message = '', $code = 0, Exception $e = null) { if ($e && (0 === $code)) { $code = $e->getCode(); } parent::__construct($message, $code, $e); } public function hasChainedException() { return ($this->_previous !== null); } public function getChainedException() { return $this->getPrevious(); } } 

class Zend_Db_Expr { protected $_expression; public function __construct($expression) { $this->_expression = (string) $expression; } public function __toString() { return $this->_expression; } } 

interface Zend_Db_Statement_Interface { public function bindColumn($column, &$param, $type = null); public function bindParam($parameter, &$variable, $type = null, $length = null, $options = null); public function bindValue($parameter, $value, $type = null); public function closeCursor(); public function columnCount(); public function errorCode(); public function errorInfo(); public function execute(array $params = array()); public function fetch($style = null, $cursor = null, $offset = null); public function fetchAll($style = null, $col = null); public function fetchColumn($col = 0); public function fetchObject($class = 'stdClass', array $config = array()); public function getAttribute($key); public function nextRowset(); public function rowCount(); public function setAttribute($key, $val); public function setFetchMode($mode); } 

abstract class Zend_Db_Statement implements Zend_Db_Statement_Interface { protected $_stmt = null; protected $_adapter = null; protected $_fetchMode = Zend_Db::FETCH_ASSOC; protected $_attribute = array(); protected $_bindColumn = array(); protected $_bindParam = array(); protected $_sqlSplit = array(); protected $_sqlParam = array(); protected $_queryId = null; public function __construct($adapter, $sql) { $this->_adapter = $adapter; if ($sql instanceof Zend_Db_Select) { $sql = $sql->assemble(); } $this->_parseParameters($sql); $this->_prepare($sql); $this->_queryId = $this->_adapter->getProfiler()->queryStart($sql); } protected function _prepare($sql) { return; } protected function _parseParameters($sql) { $sql = $this->_stripQuoted($sql); $this->_sqlSplit = preg_split('/(\?|\:[a-zA-Z0-9_]+)/', $sql, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY); $this->_sqlParam = array(); foreach ($this->_sqlSplit as $key => $val) { if ($val == '?') { if ($this->_adapter->supportsParameters('positional') === false) { throw new Zend_Db_Statement_Exception("Invalid bind-variable position '$val'"); } } else if ($val[0] == ':') { if ($this->_adapter->supportsParameters('named') === false) { throw new Zend_Db_Statement_Exception("Invalid bind-variable name '$val'"); } } $this->_sqlParam[] = $val; } $this->_bindParam = array(); } protected function _stripQuoted($sql) { $d = $this->_adapter->quoteIdentifier('a'); $d = $d[0]; $de = $this->_adapter->quoteIdentifier($d); $de = substr($de, 1, 2); $de = str_replace('\\', '\\\\', $de); $q = $this->_adapter->quote('a'); $q = $q[0]; $qe = $this->_adapter->quote($q); $qe = substr($qe, 1, 2); $qe = str_replace('\\', '\\\\', $qe); $sql = preg_replace("/$q($qe|\\\\{2}|[^$q])*$q/", '', $sql); if (!empty($q)) { $sql = preg_replace("/$q($qe|[^$q])*$q/", '', $sql); } return $sql; } public function bindColumn($column, &$param, $type = null) { $this->_bindColumn[$column] =& $param; return true; } public function bindParam($parameter, &$variable, $type = null, $length = null, $options = null) { if (!is_int($parameter) && !is_string($parameter)) { throw new Zend_Db_Statement_Exception('Invalid bind-variable position'); } $position = null; if (($intval = (int) $parameter) > 0 && $this->_adapter->supportsParameters('positional')) { if ($intval >= 1 || $intval <= count($this->_sqlParam)) { $position = $intval; } } else if ($this->_adapter->supportsParameters('named')) { if ($parameter[0] != ':') { $parameter = ':' . $parameter; } if (in_array($parameter, $this->_sqlParam) !== false) { $position = $parameter; } } if ($position === null) { throw new Zend_Db_Statement_Exception("Invalid bind-variable position '$parameter'"); } $this->_bindParam[$position] =& $variable; return $this->_bindParam($position, $variable, $type, $length, $options); } public function bindValue($parameter, $value, $type = null) { return $this->bindParam($parameter, $value, $type); } public function execute(array $params = null) { if ($this->_queryId === null) { return $this->_execute($params); } $prof = $this->_adapter->getProfiler(); $qp = $prof->getQueryProfile($this->_queryId); if ($qp->hasEnded()) { $this->_queryId = $prof->queryClone($qp); $qp = $prof->getQueryProfile($this->_queryId); } if ($params !== null) { $qp->bindParams($params); } else { $qp->bindParams($this->_bindParam); } $qp->start($this->_queryId); $retval = $this->_execute($params); $prof->queryEnd($this->_queryId); return $retval; } public function fetchAll($style = null, $col = null) { $data = array(); if ($style === Zend_Db::FETCH_COLUMN && $col === null) { $col = 0; } if ($col === null) { while ($row = $this->fetch($style)) { $data[] = $row; } } else { while (false !== ($val = $this->fetchColumn($col))) { $data[] = $val; } } return $data; } public function fetchColumn($col = 0) { $data = array(); $col = (int) $col; $row = $this->fetch(Zend_Db::FETCH_NUM); if (!is_array($row)) { return false; } return $row[$col]; } public function fetchObject($class = 'stdClass', array $config = array()) { $obj = new $class($config); $row = $this->fetch(Zend_Db::FETCH_ASSOC); if (!is_array($row)) { return false; } foreach ($row as $key => $val) { $obj->$key = $val; } return $obj; } public function getAttribute($key) { if (array_key_exists($key, $this->_attribute)) { return $this->_attribute[$key]; } } public function setAttribute($key, $val) { $this->_attribute[$key] = $val; } public function setFetchMode($mode) { switch ($mode) { case Zend_Db::FETCH_NUM: case Zend_Db::FETCH_ASSOC: case Zend_Db::FETCH_BOTH: case Zend_Db::FETCH_OBJ: $this->_fetchMode = $mode; break; case Zend_Db::FETCH_BOUND: default: $this->closeCursor(); throw new Zend_Db_Statement_Exception('invalid fetch mode'); break; } } public function _fetchBound($row) { foreach ($row as $key => $value) { if (is_int($key)) { $key++; } if (isset($this->_bindColumn[$key])) { $this->_bindColumn[$key] = $value; } } return true; } public function getAdapter() { return $this->_adapter; } public function getDriverStatement() { return $this->_stmt; } } 

class Zend_Db_Statement_Exception extends Zend_Db_Exception { public function hasChainedException() { return ($this->getPrevious() !== null); } public function getChainedException() { return $this->getPrevious(); } } 

class Zend_Db_Statement_Pdo extends Zend_Db_Statement implements IteratorAggregate { protected $_fetchMode = PDO::FETCH_ASSOC; protected function _prepare($sql) { try { $this->_stmt = $this->_adapter->getConnection()->prepare($sql); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function bindColumn($column, &$param, $type = null) { try { if ($type === null) { return $this->_stmt->bindColumn($column, $param); } else { return $this->_stmt->bindColumn($column, $param, $type); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } protected function _bindParam($parameter, &$variable, $type = null, $length = null, $options = null) { try { if ($type === null) { if (is_bool($variable)) { $type = PDO::PARAM_BOOL; } elseif ($variable === null) { $type = PDO::PARAM_NULL; } elseif (is_integer($variable)) { $type = PDO::PARAM_INT; } else { $type = PDO::PARAM_STR; } } return $this->_stmt->bindParam($parameter, $variable, $type, $length, $options); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function bindValue($parameter, $value, $type = null) { if (is_string($parameter) && $parameter[0] != ':') { $parameter = ":$parameter"; } $this->_bindParam[$parameter] = $value; try { if ($type === null) { return $this->_stmt->bindValue($parameter, $value); } else { return $this->_stmt->bindValue($parameter, $value, $type); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function closeCursor() { try { return $this->_stmt->closeCursor(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function columnCount() { try { return $this->_stmt->columnCount(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function errorCode() { try { return $this->_stmt->errorCode(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function errorInfo() { try { return $this->_stmt->errorInfo(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function _execute(array $params = null) { try { if ($params !== null) { return $this->_stmt->execute($params); } else { return $this->_stmt->execute(); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), (int) $e->getCode(), $e); } } public function fetch($style = null, $cursor = null, $offset = null) { if ($style === null) { $style = $this->_fetchMode; } try { return $this->_stmt->fetch($style, $cursor, $offset); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function getIterator() { return new IteratorIterator($this->_stmt); } public function fetchAll($style = null, $col = null) { if ($style === null) { $style = $this->_fetchMode; } try { if ($style == PDO::FETCH_COLUMN) { if ($col === null) { $col = 0; } return $this->_stmt->fetchAll($style, $col); } else { return $this->_stmt->fetchAll($style); } } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function fetchColumn($col = 0) { try { return $this->_stmt->fetchColumn($col); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function fetchObject($class = 'stdClass', array $config = array()) { try { return $this->_stmt->fetchObject($class, $config); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function getAttribute($key) { try { return $this->_stmt->getAttribute($key); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function getColumnMeta($column) { try { return $this->_stmt->getColumnMeta($column); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function nextRowset() { try { return $this->_stmt->nextRowset(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function rowCount() { try { return $this->_stmt->rowCount(); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function setAttribute($key, $val) { try { return $this->_stmt->setAttribute($key, $val); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } public function setFetchMode($mode) { $this->_fetchMode = $mode; try { return $this->_stmt->setFetchMode($mode); } catch (PDOException $e) { throw new Zend_Db_Statement_Exception($e->getMessage(), $e->getCode(), $e); } } } 


class Zend_Registry extends ArrayObject { private static $_registryClassName = 'Zend_Registry'; private static $_registry = null; public static function getInstance() { if (self::$_registry === null) { self::init(); } return self::$_registry; } public static function setInstance(Zend_Registry $registry) { if (self::$_registry !== null) { throw new Zend_Exception('Registry is already initialized'); } self::setClassName(get_class($registry)); self::$_registry = $registry; } protected static function init() { self::setInstance(new self::$_registryClassName()); } public static function setClassName($registryClassName = 'Zend_Registry') { if (self::$_registry !== null) { throw new Zend_Exception('Registry is already initialized'); } if (!is_string($registryClassName)) { throw new Zend_Exception("Argument is not a class name"); } if (!class_exists($registryClassName)) { Zend_Loader::loadClass($registryClassName); } self::$_registryClassName = $registryClassName; } public static function _unsetInstance() { self::$_registry = null; } public static function get($index) { $instance = self::getInstance(); if (!$instance->offsetExists($index)) { throw new Zend_Exception("No entry is registered for key '$index'"); } return $instance->offsetGet($index); } public static function set($index, $value) { $instance = self::getInstance(); $instance->offsetSet($index, $value); } public static function isRegistered($index) { if (self::$_registry === null) { return false; } return self::$_registry->offsetExists($index); } public function __construct($array = array(), $flags = parent::ARRAY_AS_PROPS) { parent::__construct($array, $flags); } public function offsetExists($index) { return array_key_exists($index, $this); } } 

class Zend_Filter_Exception extends Zend_Exception {} 

class Zend_Locale_Exception extends Zend_Exception { } 

class Zend_Locale_Data_Translation { public static $languageTranslation = array( 'Afrikaans' => 'af', 'Albanian' => 'sq', 'Amharic' => 'am', 'Arabic' => 'ar', 'Armenian' => 'hy', 'Assamese' => 'as', 'Azeri' => 'az', 'Azeri Latin' => 'az_Latn', 'Azeri Cyrillic' => 'az_Cyrl', 'Basque' => 'eu', 'Belarusian' => 'be', 'Bengali' => 'bn', 'Bengali Latin' => 'bn_Latn', 'Bosnian' => 'bs', 'Bulgarian' => 'bg', 'Burmese' => 'my', 'Catalan' => 'ca', 'Cherokee' => 'chr', 'Chinese' => 'zh', 'Croatian' => 'hr', 'Czech' => 'cs', 'Danish' => 'da', 'Divehi' => 'dv', 'Dutch' => 'nl', 'English' => 'en', 'Estonian' => 'et', 'Faroese' => 'fo', 'Faeroese' => 'fo', 'Farsi' => 'fa', 'Filipino' => 'fil', 'Finnish' => 'fi', 'French' => 'fr', 'Frisian' => 'fy', 'Macedonian' => 'mk', 'Gaelic' => 'gd', 'Galician' => 'gl', 'Georgian' => 'ka', 'German' => 'de', 'Greek' => 'el', 'Guarani' => 'gn', 'Gujarati' => 'gu', 'Hausa' => 'ha', 'Hawaiian' => 'haw', 'Hebrew' => 'he', 'Hindi' => 'hi', 'Hungarian' => 'hu', 'Icelandic' => 'is', 'Igbo' => 'ig', 'Indonesian' => 'id', 'Inuktitut' => 'iu', 'Italian' => 'it', 'Japanese' => 'ja', 'Kannada' => 'kn', 'Kanuri' => 'kr', 'Kashmiri' => 'ks', 'Kazakh' => 'kk', 'Khmer' => 'km', 'Konkani' => 'kok', 'Korean' => 'ko', 'Kyrgyz' => 'ky', 'Lao' => 'lo', 'Latin' => 'la', 'Latvian' => 'lv', 'Lithuanian' => 'lt', 'Macedonian' => 'mk', 'Malay' => 'ms', 'Malayalam' => 'ml', 'Maltese' => 'mt', 'Manipuri' => 'mni', 'Maori' => 'mi', 'Marathi' => 'mr', 'Mongolian' => 'mn', 'Nepali' => 'ne', 'Norwegian' => 'no', 'Norwegian Bokmal' => 'nb', 'Norwegian Nynorsk' => 'nn', 'Oriya' => 'or', 'Oromo' => 'om', 'Papiamentu' => 'pap', 'Pashto' => 'ps', 'Polish' => 'pl', 'Portuguese' => 'pt', 'Punjabi' => 'pa', 'Quecha' => 'qu', 'Quechua' => 'qu', 'Rhaeto-Romanic' => 'rm', 'Romanian' => 'ro', 'Russian' => 'ru', 'Sami' => 'smi', 'Sami Inari' => 'smn', 'Sami Lule' => 'smj', 'Sami Northern' => 'se', 'Sami Skolt' => 'sms', 'Sami Southern' => 'sma', 'Sanskrit' => 'sa', 'Serbian' => 'sr', 'Serbian Latin' => 'sr_Latn', 'Serbian Cyrillic' => 'sr_Cyrl', 'Sindhi' => 'sd', 'Sinhalese' => 'si', 'Slovak' => 'sk', 'Slovenian' => 'sl', 'Somali' => 'so', 'Sorbian' => 'wen', 'Spanish' => 'es', 'Swahili' => 'sw', 'Swedish' => 'sv', 'Syriac' => 'syr', 'Tajik' => 'tg', 'Tamazight' => 'tmh', 'Tamil' => 'ta', 'Tatar' => 'tt', 'Telugu' => 'te', 'Thai' => 'th', 'Tibetan' => 'bo', 'Tigrigna' => 'ti', 'Tsonga' => 'ts', 'Tswana' => 'tn', 'Turkish' => 'tr', 'Turkmen' => 'tk', 'Uighur' => 'ug', 'Ukrainian' => 'uk', 'Urdu' => 'ur', 'Uzbek' => 'uz', 'Uzbek Latin' => 'uz_Latn', 'Uzbek Cyrillic' => 'uz_Cyrl', 'Venda' => 've', 'Vietnamese' => 'vi', 'Welsh' => 'cy', 'Xhosa' => 'xh', 'Yiddish' => 'yi', 'Yoruba' => 'yo', 'Zulu' => 'zu', ); public static $regionTranslation = array( 'Albania' => 'AL', 'Algeria' => 'DZ', 'Argentina' => 'AR', 'Armenia' => 'AM', 'Australia' => 'AU', 'Austria' => 'AT', 'Bahrain' => 'BH', 'Bangladesh' => 'BD', 'Belgium' => 'BE', 'Belize' => 'BZ', 'Bhutan' => 'BT', 'Bolivia' => 'BO', 'Bosnia Herzegovina' => 'BA', 'Brazil' => 'BR', 'Brazilian' => 'BR', 'Brunei Darussalam' => 'BN', 'Cameroon' => 'CM', 'Canada' => 'CA', 'Chile' => 'CL', 'China' => 'CN', 'Colombia' => 'CO', 'Costa Rica' => 'CR', "Cote d'Ivoire" => 'CI', 'Czech Republic' => 'CZ', 'Dominican Republic' => 'DO', 'Denmark' => 'DK', 'Ecuador' => 'EC', 'Egypt' => 'EG', 'El Salvador' => 'SV', 'Eritrea' => 'ER', 'Ethiopia' => 'ET', 'Finland' => 'FI', 'France' => 'FR', 'Germany' => 'DE', 'Greece' => 'GR', 'Guatemala' => 'GT', 'Haiti' => 'HT', 'Honduras' => 'HN', 'Hong Kong' => 'HK', 'Hong Kong SAR' => 'HK', 'Hungary' => 'HU', 'Iceland' => 'IS', 'India' => 'IN', 'Indonesia' => 'ID', 'Iran' => 'IR', 'Iraq' => 'IQ', 'Ireland' => 'IE', 'Italy' => 'IT', 'Jamaica' => 'JM', 'Japan' => 'JP', 'Jordan' => 'JO', 'Korea' => 'KR', 'Kuwait' => 'KW', 'Lebanon' => 'LB', 'Libya' => 'LY', 'Liechtenstein' => 'LI', 'Luxembourg' => 'LU', 'Macau' => 'MO', 'Macao SAR' => 'MO', 'Malaysia' => 'MY', 'Mali' => 'ML', 'Mexico' => 'MX', 'Moldava' => 'MD', 'Monaco' => 'MC', 'Morocco' => 'MA', 'Netherlands' => 'NL', 'New Zealand' => 'NZ', 'Nicaragua' => 'NI', 'Nigeria' => 'NG', 'Norway' => 'NO', 'Oman' => 'OM', 'Pakistan' => 'PK', 'Panama' => 'PA', 'Paraguay' => 'PY', "People's Republic of China" => 'CN', 'Peru' => 'PE', 'Philippines' => 'PH', 'Poland' => 'PL', 'Portugal' => 'PT', 'PRC' => 'CN', 'Puerto Rico' => 'PR', 'Qatar' => 'QA', 'Reunion' => 'RE', 'Russia' => 'RU', 'Saudi Arabia' => 'SA', 'Senegal' => 'SN', 'Singapore' => 'SG', 'Slovakia' => 'SK', 'South Africa' => 'ZA', 'Spain' => 'ES', 'Sri Lanka' => 'LK', 'Sweden' => 'SE', 'Switzerland' => 'CH', 'Syria' => 'SY', 'Taiwan' => 'TW', 'The Netherlands' => 'NL', 'Trinidad' => 'TT', 'Tunisia' => 'TN', 'UAE' => 'AE', 'United Kingdom' => 'GB', 'United States' => 'US', 'Uruguay' => 'UY', 'Venezuela' => 'VE', 'Yemen' => 'YE', 'Zimbabwe' => 'ZW', ); } 

class Zend_Locale { private static $_localeData = array( 'root' => true, 'aa_DJ' => true, 'aa_ER' => true, 'aa_ET' => true, 'aa' => true, 'af_NA' => true, 'af_ZA' => true, 'af' => true, 'ak_GH' => true, 'ak' => true, 'am_ET' => true, 'am' => true, 'ar_AE' => true, 'ar_BH' => true, 'ar_DZ' => true, 'ar_EG' => true, 'ar_IQ' => true, 'ar_JO' => true, 'ar_KW' => true, 'ar_LB' => true, 'ar_LY' => true, 'ar_MA' => true, 'ar_OM' => true, 'ar_QA' => true, 'ar_SA' => true, 'ar_SD' => true, 'ar_SY' => true, 'ar_TN' => true, 'ar_YE' => true, 'ar' => true, 'as_IN' => true, 'as' => true, 'az_AZ' => true, 'az' => true, 'be_BY' => true, 'be' => true, 'bg_BG' => true, 'bg' => true, 'bn_BD' => true, 'bn_IN' => true, 'bn' => true, 'bo_CN' => true, 'bo_IN' => true, 'bo' => true, 'bs_BA' => true, 'bs' => true, 'byn_ER'=> true, 'byn' => true, 'ca_ES' => true, 'ca' => true, 'cch_NG'=> true, 'cch' => true, 'cop' => true, 'cs_CZ' => true, 'cs' => true, 'cy_GB' => true, 'cy' => true, 'da_DK' => true, 'da' => true, 'de_AT' => true, 'de_BE' => true, 'de_CH' => true, 'de_DE' => true, 'de_LI' => true, 'de_LU' => true, 'de' => true, 'dv_MV' => true, 'dv' => true, 'dz_BT' => true, 'dz' => true, 'ee_GH' => true, 'ee_TG' => true, 'ee' => true, 'el_CY' => true, 'el_GR' => true, 'el' => true, 'en_AS' => true, 'en_AU' => true, 'en_BE' => true, 'en_BW' => true, 'en_BZ' => true, 'en_CA' => true, 'en_GB' => true, 'en_GU' => true, 'en_HK' => true, 'en_IE' => true, 'en_IN' => true, 'en_JM' => true, 'en_MH' => true, 'en_MP' => true, 'en_MT' => true, 'en_NA' => true, 'en_NZ' => true, 'en_PH' => true, 'en_PK' => true, 'en_SG' => true, 'en_TT' => true, 'en_UM' => true, 'en_US' => true, 'en_VI' => true, 'en_ZA' => true, 'en_ZW' => true, 'en' => true, 'eo' => true, 'es_AR' => true, 'es_BO' => true, 'es_CL' => true, 'es_CO' => true, 'es_CR' => true, 'es_DO' => true, 'es_EC' => true, 'es_ES' => true, 'es_GT' => true, 'es_HN' => true, 'es_MX' => true, 'es_NI' => true, 'es_PA' => true, 'es_PE' => true, 'es_PR' => true, 'es_PY' => true, 'es_SV' => true, 'es_US' => true, 'es_UY' => true, 'es_VE' => true, 'es' => true, 'et_EE' => true, 'et' => true, 'eu_ES' => true, 'eu' => true, 'fa_AF' => true, 'fa_IR' => true, 'fa' => true, 'fi_FI' => true, 'fi' => true, 'fil_PH'=> true, 'fil' => true, 'fo_FO' => true, 'fo' => true, 'fr_BE' => true, 'fr_CA' => true, 'fr_CH' => true, 'fr_FR' => true, 'fr_LU' => true, 'fr_MC' => true, 'fr_SN' => true, 'fr' => true, 'fur_IT'=> true, 'fur' => true, 'ga_IE' => true, 'ga' => true, 'gaa_GH'=> true, 'gaa' => true, 'gez_ER'=> true, 'gez_ET'=> true, 'gez' => true, 'gl_ES' => true, 'gl' => true, 'gsw_CH'=> true, 'gsw' => true, 'gu_IN' => true, 'gu' => true, 'gv_GB' => true, 'gv' => true, 'ha_GH' => true, 'ha_NE' => true, 'ha_NG' => true, 'ha_SD' => true, 'ha' => true, 'haw_US'=> true, 'haw' => true, 'he_IL' => true, 'he' => true, 'hi_IN' => true, 'hi' => true, 'hr_HR' => true, 'hr' => true, 'hu_HU' => true, 'hu' => true, 'hy_AM' => true, 'hy' => true, 'ia' => true, 'id_ID' => true, 'id' => true, 'ig_NG' => true, 'ig' => true, 'ii_CN' => true, 'ii' => true, 'in' => true, 'is_IS' => true, 'is' => true, 'it_CH' => true, 'it_IT' => true, 'it' => true, 'iu' => true, 'iw' => true, 'ja_JP' => true, 'ja' => true, 'ka_GE' => true, 'ka' => true, 'kaj_NG'=> true, 'kaj' => true, 'kam_KE'=> true, 'kam' => true, 'kcg_NG'=> true, 'kcg' => true, 'kfo_CI'=> true, 'kfo' => true, 'kk_KZ' => true, 'kk' => true, 'kl_GL' => true, 'kl' => true, 'km_KH' => true, 'km' => true, 'kn_IN' => true, 'kn' => true, 'ko_KR' => true, 'ko' => true, 'kok_IN'=> true, 'kok' => true, 'kpe_GN'=> true, 'kpe_LR'=> true, 'kpe' => true, 'ku_IQ' => true, 'ku_IR' => true, 'ku_SY' => true, 'ku_TR' => true, 'ku' => true, 'kw_GB' => true, 'kw' => true, 'ky_KG' => true, 'ky' => true, 'ln_CD' => true, 'ln_CG' => true, 'ln' => true, 'lo_LA' => true, 'lo' => true, 'lt_LT' => true, 'lt' => true, 'lv_LV' => true, 'lv' => true, 'mk_MK' => true, 'mk' => true, 'ml_IN' => true, 'ml' => true, 'mn_CN' => true, 'mn_MN' => true, 'mn' => true, 'mo' => true, 'mr_IN' => true, 'mr' => true, 'ms_BN' => true, 'ms_MY' => true, 'ms' => true, 'mt_MT' => true, 'mt' => true, 'my_MM' => true, 'my' => true, 'nb_NO' => true, 'nb' => true, 'nds_DE'=> true, 'nds' => true, 'ne_IN' => true, 'ne_NP' => true, 'ne' => true, 'nl_BE' => true, 'nl_NL' => true, 'nl' => true, 'nn_NO' => true, 'nn' => true, 'no' => true, 'nr_ZA' => true, 'nr' => true, 'nso_ZA'=> true, 'nso' => true, 'ny_MW' => true, 'ny' => true, 'oc_FR' => true, 'oc' => true, 'om_ET' => true, 'om_KE' => true, 'om' => true, 'or_IN' => true, 'or' => true, 'pa_IN' => true, 'pa_PK' => true, 'pa' => true, 'pl_PL' => true, 'pl' => true, 'ps_AF' => true, 'ps' => true, 'pt_BR' => true, 'pt_PT' => true, 'pt' => true, 'ro_MD' => true, 'ro_RO' => true, 'ro' => true, 'ru_RU' => true, 'ru_UA' => true, 'ru' => true, 'rw_RW' => true, 'rw' => true, 'sa_IN' => true, 'sa' => true, 'se_FI' => true, 'se_NO' => true, 'se' => true, 'sh_BA' => true, 'sh_CS' => true, 'sh_YU' => true, 'sh' => true, 'si_LK' => true, 'si' => true, 'sid_ET'=> true, 'sid' => true, 'sk_SK' => true, 'sk' => true, 'sl_SI' => true, 'sl' => true, 'so_DJ' => true, 'so_ET' => true, 'so_KE' => true, 'so_SO' => true, 'so' => true, 'sq_AL' => true, 'sq' => true, 'sr_BA' => true, 'sr_CS' => true, 'sr_ME' => true, 'sr_RS' => true, 'sr_YU' => true, 'sr' => true, 'ss_SZ' => true, 'ss_ZA' => true, 'ss' => true, 'st_LS' => true, 'st_ZA' => true, 'st' => true, 'sv_FI' => true, 'sv_SE' => true, 'sv' => true, 'sw_KE' => true, 'sw_TZ' => true, 'sw' => true, 'syr_SY'=> true, 'syr' => true, 'ta_IN' => true, 'ta' => true, 'te_IN' => true, 'te' => true, 'tg_TJ' => true, 'tg' => true, 'th_TH' => true, 'th' => true, 'ti_ER' => true, 'ti_ET' => true, 'ti' => true, 'tig_ER'=> true, 'tig' => true, 'tl' => true, 'tn_ZA' => true, 'tn' => true, 'to_TO' => true, 'to' => true, 'tr_TR' => true, 'tr' => true, 'trv_TW'=> true, 'trv' => true, 'ts_ZA' => true, 'ts' => true, 'tt_RU' => true, 'tt' => true, 'ug_CN' => true, 'ug' => true, 'uk_UA' => true, 'uk' => true, 'ur_IN' => true, 'ur_PK' => true, 'ur' => true, 'uz_AF' => true, 'uz_UZ' => true, 'uz' => true, 've_ZA' => true, 've' => true, 'vi_VN' => true, 'vi' => true, 'wal_ET'=> true, 'wal' => true, 'wo_SN' => true, 'wo' => true, 'xh_ZA' => true, 'xh' => true, 'yo_NG' => true, 'yo' => true, 'zh_CN' => true, 'zh_HK' => true, 'zh_MO' => true, 'zh_SG' => true, 'zh_TW' => true, 'zh' => true, 'zu_ZA' => true, 'zu' => true ); private static $_territoryData = array( 'AD' => 'ca_AD', 'AE' => 'ar_AE', 'AF' => 'fa_AF', 'AG' => 'en_AG', 'AI' => 'en_AI', 'AL' => 'sq_AL', 'AM' => 'hy_AM', 'AN' => 'pap_AN', 'AO' => 'pt_AO', 'AQ' => 'und_AQ', 'AR' => 'es_AR', 'AS' => 'sm_AS', 'AT' => 'de_AT', 'AU' => 'en_AU', 'AW' => 'nl_AW', 'AX' => 'sv_AX', 'AZ' => 'az_Latn_AZ', 'BA' => 'bs_BA', 'BB' => 'en_BB', 'BD' => 'bn_BD', 'BE' => 'nl_BE', 'BF' => 'mos_BF', 'BG' => 'bg_BG', 'BH' => 'ar_BH', 'BI' => 'rn_BI', 'BJ' => 'fr_BJ', 'BL' => 'fr_BL', 'BM' => 'en_BM', 'BN' => 'ms_BN', 'BO' => 'es_BO', 'BR' => 'pt_BR', 'BS' => 'en_BS', 'BT' => 'dz_BT', 'BV' => 'und_BV', 'BW' => 'en_BW', 'BY' => 'be_BY', 'BZ' => 'en_BZ', 'CA' => 'en_CA', 'CC' => 'ms_CC', 'CD' => 'sw_CD', 'CF' => 'fr_CF', 'CG' => 'fr_CG', 'CH' => 'de_CH', 'CI' => 'fr_CI', 'CK' => 'en_CK', 'CL' => 'es_CL', 'CM' => 'fr_CM', 'CN' => 'zh_Hans_CN', 'CO' => 'es_CO', 'CR' => 'es_CR', 'CU' => 'es_CU', 'CV' => 'kea_CV', 'CX' => 'en_CX', 'CY' => 'el_CY', 'CZ' => 'cs_CZ', 'DE' => 'de_DE', 'DJ' => 'aa_DJ', 'DK' => 'da_DK', 'DM' => 'en_DM', 'DO' => 'es_DO', 'DZ' => 'ar_DZ', 'EC' => 'es_EC', 'EE' => 'et_EE', 'EG' => 'ar_EG', 'EH' => 'ar_EH', 'ER' => 'ti_ER', 'ES' => 'es_ES', 'ET' => 'en_ET', 'FI' => 'fi_FI', 'FJ' => 'hi_FJ', 'FK' => 'en_FK', 'FM' => 'chk_FM', 'FO' => 'fo_FO', 'FR' => 'fr_FR', 'GA' => 'fr_GA', 'GB' => 'en_GB', 'GD' => 'en_GD', 'GE' => 'ka_GE', 'GF' => 'fr_GF', 'GG' => 'en_GG', 'GH' => 'ak_GH', 'GI' => 'en_GI', 'GL' => 'iu_GL', 'GM' => 'en_GM', 'GN' => 'fr_GN', 'GP' => 'fr_GP', 'GQ' => 'fan_GQ', 'GR' => 'el_GR', 'GS' => 'und_GS', 'GT' => 'es_GT', 'GU' => 'en_GU', 'GW' => 'pt_GW', 'GY' => 'en_GY', 'HK' => 'zh_Hant_HK', 'HM' => 'und_HM', 'HN' => 'es_HN', 'HR' => 'hr_HR', 'HT' => 'ht_HT', 'HU' => 'hu_HU', 'ID' => 'id_ID', 'IE' => 'en_IE', 'IL' => 'he_IL', 'IM' => 'en_IM', 'IN' => 'hi_IN', 'IO' => 'und_IO', 'IQ' => 'ar_IQ', 'IR' => 'fa_IR', 'IS' => 'is_IS', 'IT' => 'it_IT', 'JE' => 'en_JE', 'JM' => 'en_JM', 'JO' => 'ar_JO', 'JP' => 'ja_JP', 'KE' => 'en_KE', 'KG' => 'ky_Cyrl_KG', 'KH' => 'km_KH', 'KI' => 'en_KI', 'KM' => 'ar_KM', 'KN' => 'en_KN', 'KP' => 'ko_KP', 'KR' => 'ko_KR', 'KW' => 'ar_KW', 'KY' => 'en_KY', 'KZ' => 'ru_KZ', 'LA' => 'lo_LA', 'LB' => 'ar_LB', 'LC' => 'en_LC', 'LI' => 'de_LI', 'LK' => 'si_LK', 'LR' => 'en_LR', 'LS' => 'st_LS', 'LT' => 'lt_LT', 'LU' => 'fr_LU', 'LV' => 'lv_LV', 'LY' => 'ar_LY', 'MA' => 'ar_MA', 'MC' => 'fr_MC', 'MD' => 'ro_MD', 'ME' => 'sr_Latn_ME', 'MF' => 'fr_MF', 'MG' => 'mg_MG', 'MH' => 'mh_MH', 'MK' => 'mk_MK', 'ML' => 'bm_ML', 'MM' => 'my_MM', 'MN' => 'mn_Cyrl_MN', 'MO' => 'zh_Hant_MO', 'MP' => 'en_MP', 'MQ' => 'fr_MQ', 'MR' => 'ar_MR', 'MS' => 'en_MS', 'MT' => 'mt_MT', 'MU' => 'mfe_MU', 'MV' => 'dv_MV', 'MW' => 'ny_MW', 'MX' => 'es_MX', 'MY' => 'ms_MY', 'MZ' => 'pt_MZ', 'NA' => 'kj_NA', 'NC' => 'fr_NC', 'NE' => 'ha_Latn_NE', 'NF' => 'en_NF', 'NG' => 'en_NG', 'NI' => 'es_NI', 'NL' => 'nl_NL', 'NO' => 'nb_NO', 'NP' => 'ne_NP', 'NR' => 'en_NR', 'NU' => 'niu_NU', 'NZ' => 'en_NZ', 'OM' => 'ar_OM', 'PA' => 'es_PA', 'PE' => 'es_PE', 'PF' => 'fr_PF', 'PG' => 'tpi_PG', 'PH' => 'fil_PH', 'PK' => 'ur_PK', 'PL' => 'pl_PL', 'PM' => 'fr_PM', 'PN' => 'en_PN', 'PR' => 'es_PR', 'PS' => 'ar_PS', 'PT' => 'pt_PT', 'PW' => 'pau_PW', 'PY' => 'gn_PY', 'QA' => 'ar_QA', 'RE' => 'fr_RE', 'RO' => 'ro_RO', 'RS' => 'sr_Cyrl_RS', 'RU' => 'ru_RU', 'RW' => 'rw_RW', 'SA' => 'ar_SA', 'SB' => 'en_SB', 'SC' => 'crs_SC', 'SD' => 'ar_SD', 'SE' => 'sv_SE', 'SG' => 'en_SG', 'SH' => 'en_SH', 'SI' => 'sl_SI', 'SJ' => 'nb_SJ', 'SK' => 'sk_SK', 'SL' => 'kri_SL', 'SM' => 'it_SM', 'SN' => 'fr_SN', 'SO' => 'sw_SO', 'SR' => 'srn_SR', 'ST' => 'pt_ST', 'SV' => 'es_SV', 'SY' => 'ar_SY', 'SZ' => 'en_SZ', 'TC' => 'en_TC', 'TD' => 'fr_TD', 'TF' => 'und_TF', 'TG' => 'fr_TG', 'TH' => 'th_TH', 'TJ' => 'tg_Cyrl_TJ', 'TK' => 'tkl_TK', 'TL' => 'pt_TL', 'TM' => 'tk_TM', 'TN' => 'ar_TN', 'TO' => 'to_TO', 'TR' => 'tr_TR', 'TT' => 'en_TT', 'TV' => 'tvl_TV', 'TW' => 'zh_Hant_TW', 'TZ' => 'sw_TZ', 'UA' => 'uk_UA', 'UG' => 'sw_UG', 'UM' => 'en_UM', 'US' => 'en_US', 'UY' => 'es_UY', 'UZ' => 'uz_Cyrl_UZ', 'VA' => 'it_VA', 'VC' => 'en_VC', 'VE' => 'es_VE', 'VG' => 'en_VG', 'VI' => 'en_VI', 'VU' => 'bi_VU', 'WF' => 'wls_WF', 'WS' => 'sm_WS', 'YE' => 'ar_YE', 'YT' => 'swb_YT', 'ZA' => 'en_ZA', 'ZM' => 'en_ZM', 'ZW' => 'sn_ZW' ); const BROWSER = 'browser'; const ENVIRONMENT = 'environment'; const ZFDEFAULT = 'default'; public static $compatibilityMode = false; private static $_breakChain = false; protected $_locale; protected static $_auto; protected static $_browser; protected static $_environment; protected static $_default = array('en' => true); public function __construct($locale = null) { $this->setLocale($locale); } public function serialize() { return serialize($this); } public function toString() { return (string) $this->_locale; } public function __toString() { return $this->toString(); } public static function getDefault() { if ((self::$compatibilityMode === true) or (func_num_args() > 0)) { if (!self::$_breakChain) { self::$_breakChain = true; trigger_error('You are running Zend_Locale in compatibility mode... please migrate your scripts', E_USER_NOTICE); $params = func_get_args(); $param = null; if (isset($params[0])) { $param = $params[0]; } return self::getOrder($param); } self::$_breakChain = false; } return self::$_default; } public static function setDefault($locale, $quality = 1) { if (($locale === 'auto') or ($locale === 'root') or ($locale === 'default') or ($locale === 'environment') or ($locale === 'browser')) { throw new Zend_Locale_Exception('Only full qualified locales can be used as default!'); } if (($quality < 0.1) or ($quality > 100)) { throw new Zend_Locale_Exception("Quality must be between 0.1 and 100"); } if ($quality > 1) { $quality /= 100; } $locale = self::_prepareLocale($locale); if (isset(self::$_localeData[(string) $locale]) === true) { self::$_default = array((string) $locale => $quality); } else { $elocale = explode('_', (string) $locale); if (isset(self::$_localeData[$elocale[0]]) === true) { self::$_default = array($elocale[0] => $quality); } else { throw new Zend_Locale_Exception("Unknown locale '" . (string) $locale . "' can not be set as default!"); } } self::$_auto = self::getBrowser() + self::getEnvironment() + self::getDefault(); } public static function getEnvironment() { if (self::$_environment !== null) { return self::$_environment; } $language = setlocale(LC_ALL, 0); $languages = explode(';', $language); $languagearray = array(); foreach ($languages as $locale) { if (strpos($locale, '=') !== false) { $language = substr($locale, strpos($locale, '=')); $language = substr($language, 1); } if ($language !== 'C') { if (strpos($language, '.') !== false) { $language = substr($language, 0, strpos($language, '.')); } else if (strpos($language, '@') !== false) { $language = substr($language, 0, strpos($language, '@')); } $language = str_ireplace( array_keys(Zend_Locale_Data_Translation::$languageTranslation), array_values(Zend_Locale_Data_Translation::$languageTranslation), (string) $language ); $language = str_ireplace( array_keys(Zend_Locale_Data_Translation::$regionTranslation), array_values(Zend_Locale_Data_Translation::$regionTranslation), $language ); if (isset(self::$_localeData[$language]) === true) { $languagearray[$language] = 1; if (strpos($language, '_') !== false) { $languagearray[substr($language, 0, strpos($language, '_'))] = 1; } } } } self::$_environment = $languagearray; return $languagearray; } public static function getBrowser() { if (self::$_browser !== null) { return self::$_browser; } $httplanguages = getenv('HTTP_ACCEPT_LANGUAGE'); if (empty($httplanguages) && array_key_exists('HTTP_ACCEPT_LANGUAGE', $_SERVER)) { $httplanguages = $_SERVER['HTTP_ACCEPT_LANGUAGE']; } $languages = array(); if (empty($httplanguages)) { return $languages; } $accepted = preg_split('/,\s*/', $httplanguages); foreach ($accepted as $accept) { $match = null; $result = preg_match('/^([a-z]{1,8}(?:[-_][a-z]{1,8})*)(?:;\s*q=(0(?:\.[0-9]{1,3})?|1(?:\.0{1,3})?))?$/i', $accept, $match); if ($result < 1) { continue; } if (isset($match[2]) === true) { $quality = (float) $match[2]; } else { $quality = 1.0; } $countrys = explode('-', $match[1]); $region = array_shift($countrys); $country2 = explode('_', $region); $region = array_shift($country2); foreach ($countrys as $country) { $languages[$region . '_' . strtoupper($country)] = $quality; } foreach ($country2 as $country) { $languages[$region . '_' . strtoupper($country)] = $quality; } if ((isset($languages[$region]) === false) || ($languages[$region] < $quality)) { $languages[$region] = $quality; } } self::$_browser = $languages; return $languages; } public function setLocale($locale = null) { $locale = self::_prepareLocale($locale); if (isset(self::$_localeData[(string) $locale]) === false) { $region = substr((string) $locale, 0, 3); if (isset($region[2]) === true) { if (($region[2] === '_') or ($region[2] === '-')) { $region = substr($region, 0, 2); } } if (isset(self::$_localeData[(string) $region]) === true) { $this->_locale = $region; } else { $this->_locale = 'root'; } } else { $this->_locale = $locale; } } public function getLanguage() { $locale = explode('_', $this->_locale); return $locale[0]; } public function getRegion() { $locale = explode('_', $this->_locale); if (isset($locale[1]) === true) { return $locale[1]; } return false; } public static function getHttpCharset() { $httpcharsets = getenv('HTTP_ACCEPT_CHARSET'); $charsets = array(); if ($httpcharsets === false) { return $charsets; } $accepted = preg_split('/,\s*/', $httpcharsets); foreach ($accepted as $accept) { if (empty($accept) === true) { continue; } if (strpos($accept, ';') !== false) { $quality = (float) substr($accept, (strpos($accept, '=') + 1)); $pos = substr($accept, 0, strpos($accept, ';')); $charsets[$pos] = $quality; } else { $quality = 1.0; $charsets[$accept] = $quality; } } return $charsets; } public function equals(Zend_Locale $object) { if ($object->toString() === $this->toString()) { return true; } return false; } public static function getTranslationList($path = null, $locale = null, $value = null) { $locale = self::findLocale($locale); $result = Zend_Locale_Data::getList($locale, $path, $value); if (empty($result) === true) { return false; } return $result; } public static function getLanguageTranslationList($locale = null) { trigger_error("The method getLanguageTranslationList is deprecated. Use getTranslationList('language', $locale) instead", E_USER_NOTICE); return self::getTranslationList('language', $locale); } public static function getScriptTranslationList($locale = null) { trigger_error("The method getScriptTranslationList is deprecated. Use getTranslationList('script', $locale) instead", E_USER_NOTICE); return self::getTranslationList('script', $locale); } public static function getCountryTranslationList($locale = null) { trigger_error("The method getCountryTranslationList is deprecated. Use getTranslationList('territory', $locale, 2) instead", E_USER_NOTICE); return self::getTranslationList('territory', $locale, 2); } public static function getTerritoryTranslationList($locale = null) { trigger_error("The method getTerritoryTranslationList is deprecated. Use getTranslationList('territory', $locale, 1) instead", E_USER_NOTICE); return self::getTranslationList('territory', $locale, 1); } public static function getTranslation($value = null, $path = null, $locale = null) { $locale = self::findLocale($locale); $result = Zend_Locale_Data::getContent($locale, $path, $value); if (empty($result) === true && '0' !== $result) { return false; } return $result; } public static function getLanguageTranslation($value, $locale = null) { trigger_error("The method getLanguageTranslation is deprecated. Use getTranslation($value, 'language', $locale) instead", E_USER_NOTICE); return self::getTranslation($value, 'language', $locale); } public static function getScriptTranslation($value, $locale = null) { trigger_error("The method getScriptTranslation is deprecated. Use getTranslation($value, 'script', $locale) instead", E_USER_NOTICE); return self::getTranslation($value, 'script', $locale); } public static function getCountryTranslation($value, $locale = null) { trigger_error("The method getCountryTranslation is deprecated. Use getTranslation($value, 'country', $locale) instead", E_USER_NOTICE); return self::getTranslation($value, 'country', $locale); } public static function getTerritoryTranslation($value, $locale = null) { trigger_error("The method getTerritoryTranslation is deprecated. Use getTranslation($value, 'territory', $locale) instead", E_USER_NOTICE); return self::getTranslation($value, 'territory', $locale); } public static function getQuestion($locale = null) { $locale = self::findLocale($locale); $quest = Zend_Locale_Data::getList($locale, 'question'); $yes = explode(':', $quest['yes']); $no = explode(':', $quest['no']); $quest['yes'] = $yes[0]; $quest['yesarray'] = $yes; $quest['no'] = $no[0]; $quest['noarray'] = $no; $quest['yesexpr'] = self::_prepareQuestionString($yes); $quest['noexpr'] = self::_prepareQuestionString($no); return $quest; } private static function _prepareQuestionString($input) { $regex = ''; if (is_array($input) === true) { $regex = '^'; $start = true; foreach ($input as $row) { if ($start === false) { $regex .= '|'; } $start = false; $regex .= '('; $one = null; if (strlen($row) > 2) { $one = true; } foreach (str_split($row, 1) as $char) { $regex .= '[' . $char; $regex .= strtoupper($char) . ']'; if ($one === true) { $one = false; $regex .= '('; } } if ($one === false) { $regex .= ')'; } $regex .= '?)'; } } return $regex; } public static function isLocale($locale, $strict = false, $compatible = true) { if (($locale instanceof Zend_Locale) || (is_string($locale) && array_key_exists($locale, self::$_localeData)) ) { return true; } if (($locale === null) || (!is_string($locale) and !is_array($locale))) { return false; } try { $locale = self::_prepareLocale($locale, $strict); } catch (Zend_Locale_Exception $e) { return false; } if (($compatible === true) and (self::$compatibilityMode === true)) { trigger_error('You are running Zend_Locale in compatibility mode... please migrate your scripts', E_USER_NOTICE); if (isset(self::$_localeData[$locale]) === true) { return $locale; } else if (!$strict) { $locale = explode('_', $locale); if (isset(self::$_localeData[$locale[0]]) === true) { return $locale[0]; } } } else { if (isset(self::$_localeData[$locale]) === true) { return true; } else if (!$strict) { $locale = explode('_', $locale); if (isset(self::$_localeData[$locale[0]]) === true) { return true; } } } return false; } public static function findLocale($locale = null) { if ($locale === null) { if (Zend_Registry::isRegistered('Zend_Locale')) { $locale = Zend_Registry::get('Zend_Locale'); } } if ($locale === null) { $locale = new Zend_Locale(); } if (!Zend_Locale::isLocale($locale, true, false)) { if (!Zend_Locale::isLocale($locale, false, false)) { $locale = Zend_Locale::getLocaleToTerritory($locale); if (empty($locale)) { throw new Zend_Locale_Exception("The locale '$locale' is no known locale"); } } else { $locale = new Zend_Locale($locale); } } $locale = self::_prepareLocale($locale); return $locale; } public static function getLocaleToTerritory($territory) { $territory = strtoupper($territory); if (array_key_exists($territory, self::$_territoryData)) { return self::$_territoryData[$territory]; } return null; } public static function getLocaleList() { $list = self::$_localeData; unset($list['root']); unset($list['auto']); unset($list['browser']); unset($list['environment']); return $list; } public static function getCache() { return Zend_Locale_Data::getCache(); } public static function setCache(Zend_Cache_Core $cache) { Zend_Locale_Data::setCache($cache); } public static function hasCache() { return Zend_Locale_Data::hasCache(); } public static function removeCache() { Zend_Locale_Data::removeCache(); } public static function clearCache($tag = null) { Zend_Locale_Data::clearCache($tag); } public static function disableCache($flag) { Zend_Locale_Data::disableCache($flag); } private static function _prepareLocale($locale, $strict = false) { if ($locale instanceof Zend_Locale) { $locale = $locale->toString(); } if (is_array($locale)) { return ''; } if (empty(self::$_auto) === true) { self::$_browser = self::getBrowser(); self::$_environment = self::getEnvironment(); self::$_breakChain = true; self::$_auto = self::getBrowser() + self::getEnvironment() + self::getDefault(); } if (!$strict) { if ($locale === 'browser') { $locale = self::$_browser; } if ($locale === 'environment') { $locale = self::$_environment; } if ($locale === 'default') { $locale = self::$_default; } if (($locale === 'auto') or ($locale === null)) { $locale = self::$_auto; } if (is_array($locale) === true) { $locale = key($locale); } } if ($locale === null) { throw new Zend_Locale_Exception('Autodetection of Locale has been failed!'); } if (strpos($locale, '-') !== false) { $locale = strtr($locale, '-', '_'); } $parts = explode('_', $locale); if (!isset(self::$_localeData[$parts[0]])) { if ((count($parts) == 1) && array_key_exists($parts[0], self::$_territoryData)) { return self::$_territoryData[$parts[0]]; } return ''; } foreach($parts as $key => $value) { if ((strlen($value) < 2) || (strlen($value) > 3)) { unset($parts[$key]); } } $locale = implode('_', $parts); return (string) $locale; } public static function getOrder($order = null) { switch ($order) { case self::ENVIRONMENT: self::$_breakChain = true; $languages = self::getEnvironment() + self::getBrowser() + self::getDefault(); break; case self::ZFDEFAULT: self::$_breakChain = true; $languages = self::getDefault() + self::getEnvironment() + self::getBrowser(); break; default: self::$_breakChain = true; $languages = self::getBrowser() + self::getEnvironment() + self::getDefault(); break; } return $languages; } } 

class Zend_Cache_Exception extends Zend_Exception {} 

abstract class Zend_Cache { public static $standardFrontends = array('Core', 'Output', 'Class', 'File', 'Function', 'Page'); public static $standardBackends = array('File', 'Sqlite', 'Memcached', 'Libmemcached', 'Apc', 'ZendPlatform', 'Xcache', 'TwoLevels', 'WinCache', 'ZendServer_Disk', 'ZendServer_ShMem'); public static $standardExtendedBackends = array('File', 'Apc', 'TwoLevels', 'Memcached', 'Libmemcached', 'Sqlite', 'WinCache'); public static $availableFrontends = array('Core', 'Output', 'Class', 'File', 'Function', 'Page'); public static $availableBackends = array('File', 'Sqlite', 'Memcached', 'Libmemcached', 'Apc', 'ZendPlatform', 'Xcache', 'WinCache', 'TwoLevels'); const CLEANING_MODE_ALL = 'all'; const CLEANING_MODE_OLD = 'old'; const CLEANING_MODE_MATCHING_TAG = 'matchingTag'; const CLEANING_MODE_NOT_MATCHING_TAG = 'notMatchingTag'; const CLEANING_MODE_MATCHING_ANY_TAG = 'matchingAnyTag'; public static function factory($frontend, $backend, $frontendOptions = array(), $backendOptions = array(), $customFrontendNaming = false, $customBackendNaming = false, $autoload = false) { if (is_string($backend)) { $backendObject = self::_makeBackend($backend, $backendOptions, $customBackendNaming, $autoload); } else { if ((is_object($backend)) && (in_array('Zend_Cache_Backend_Interface', class_implements($backend)))) { $backendObject = $backend; } else { self::throwException('backend must be a backend name (string) or an object which implements Zend_Cache_Backend_Interface'); } } if (is_string($frontend)) { $frontendObject = self::_makeFrontend($frontend, $frontendOptions, $customFrontendNaming, $autoload); } else { if (is_object($frontend)) { $frontendObject = $frontend; } else { self::throwException('frontend must be a frontend name (string) or an object'); } } $frontendObject->setBackend($backendObject); return $frontendObject; } public static function _makeBackend($backend, $backendOptions, $customBackendNaming = false, $autoload = false) { if (!$customBackendNaming) { $backend = self::_normalizeName($backend); } if (in_array($backend, Zend_Cache::$standardBackends)) { $backendClass = 'Zend_Cache_Backend_' . $backend; } else { if (!preg_match('~^[\w]+$~D', $backend)) { Zend_Cache::throwException("Invalid backend name [$backend]"); } if (!$customBackendNaming) { $backendClass = 'Zend_Cache_Backend_' . $backend; } else { $backendClass = $backend; } if (!$autoload) { $file = str_replace('_', DIRECTORY_SEPARATOR, $backendClass) . '.php'; if (!(self::_isReadable($file))) { self::throwException("file $file not found in include_path"); } } } return new $backendClass($backendOptions); } public static function _makeFrontend($frontend, $frontendOptions = array(), $customFrontendNaming = false, $autoload = false) { if (!$customFrontendNaming) { $frontend = self::_normalizeName($frontend); } if (in_array($frontend, self::$standardFrontends)) { $frontendClass = 'Zend_Cache_' . ($frontend != 'Core' ? 'Frontend_' : '') . $frontend; } else { if (!preg_match('~^[\w]+$~D', $frontend)) { Zend_Cache::throwException("Invalid frontend name [$frontend]"); } if (!$customFrontendNaming) { $frontendClass = 'Zend_Cache_Frontend_' . $frontend; } else { $frontendClass = $frontend; } if (!$autoload) { $file = str_replace('_', DIRECTORY_SEPARATOR, $frontendClass) . '.php'; if (!(self::_isReadable($file))) { self::throwException("file $file not found in include_path"); } } } return new $frontendClass($frontendOptions); } public static function throwException($msg, Exception $e = null) { throw new Zend_Cache_Exception($msg, 0, $e); } protected static function _normalizeName($name) { $name = ucfirst(strtolower($name)); $name = str_replace(array('-', '_', '.'), ' ', $name); $name = ucwords($name); $name = str_replace(' ', '', $name); if (stripos($name, 'ZendServer') === 0) { $name = 'ZendServer_' . substr($name, strlen('ZendServer')); } return $name; } private static function _isReadable($filename) { if (!$fh = @fopen($filename, 'r', true)) { return false; } @fclose($fh); return true; } } 

class Zend_Locale_Data { private static $_ldml = array(); private static $_list = array(); private static $_cache = null; private static $_cacheTags = false; private static $_cacheDisabled = false; private static function _readFile($locale, $path, $attribute, $value, $temp) { if (!empty(self::$_ldml[(string) $locale])) { $result = self::$_ldml[(string) $locale]->xpath($path); if (!empty($result)) { foreach ($result as &$found) { if (empty($value)) { if (empty($attribute)) { $temp[] = (string) $found; } else if (empty($temp[(string) $found[$attribute]])){ $temp[(string) $found[$attribute]] = (string) $found; } } else if (empty ($temp[$value])) { if (empty($attribute)) { $temp[$value] = (string) $found; } else { $temp[$value] = (string) $found[$attribute]; } } } } } return $temp; } private static function _findRoute($locale, $path, $attribute, $value, &$temp) { if (empty(self::$_ldml[(string) $locale])) { $filename = dirname(__FILE__) . '/Data/' . $locale . '.xml'; if (!file_exists($filename)) { throw new Zend_Locale_Exception("Missing locale file '$filename' for '$locale' locale."); } self::$_ldml[(string) $locale] = simplexml_load_file($filename); } $search = ''; $tok = strtok($path, '/'); if (!empty(self::$_ldml[(string) $locale])) { while ($tok !== false) { $search .= '/' . $tok; if (strpos($search, '[@') !== false) { while (strrpos($search, '[@') > strrpos($search, ']')) { $tok = strtok('/'); if (empty($tok)) { $search .= '/'; } $search = $search . '/' . $tok; } } $result = self::$_ldml[(string) $locale]->xpath($search . '/alias'); if (!empty($result)) { $source = $result[0]['source']; $newpath = $result[0]['path']; if ($newpath != '//ldml') { while (substr($newpath,0,3) == '../') { $newpath = substr($newpath, 3); $search = substr($search, 0, strrpos($search, '/')); } $path = $search . '/' . $newpath; while (($tok = strtok('/'))!== false) { $path = $path . '/' . $tok; } } if ($source != 'locale') { $locale = $source; } $temp = self::_getFile($locale, $path, $attribute, $value, $temp); return false; } $tok = strtok('/'); } } return true; } private static function _getFile($locale, $path, $attribute = false, $value = false, $temp = array()) { $result = self::_findRoute($locale, $path, $attribute, $value, $temp); if ($result) { $temp = self::_readFile($locale, $path, $attribute, $value, $temp); } if (($locale != 'root') && ($result)) { $locale = substr($locale, 0, -strlen(strrchr($locale, '_'))); if (!empty($locale)) { $temp = self::_getFile($locale, $path, $attribute, $value, $temp); } else { $temp = self::_getFile('root', $path, $attribute, $value, $temp); } } return $temp; } private static function _calendarDetail($locale, $list) { $ret = "001"; foreach ($list as $key => $value) { if (strpos($locale, '_') !== false) { $locale = substr($locale, strpos($locale, '_') + 1); } if (strpos($key, $locale) !== false) { $ret = $key; break; } } return $ret; } private static function _checkLocale($locale) { if (empty($locale)) { $locale = new Zend_Locale(); } if (!(Zend_Locale::isLocale((string) $locale, null, false))) { throw new Zend_Locale_Exception("Locale (" . (string) $locale . ") is a unknown locale"); } return (string) $locale; } public static function getList($locale, $path, $value = false) { $locale = self::_checkLocale($locale); if (!isset(self::$_cache) && !self::$_cacheDisabled) { self::$_cache = Zend_Cache::factory( 'Core', 'File', array('automatic_serialization' => true), array()); } $val = $value; if (is_array($value)) { $val = implode('_' , $value); } $val = urlencode($val); $id = strtr('Zend_LocaleL_' . $locale . '_' . $path . '_' . $val, array('-' => '_', '%' => '_', '+' => '_')); if (!self::$_cacheDisabled && ($result = self::$_cache->load($id))) { return unserialize($result); } $temp = array(); switch(strtolower($path)) { case 'language': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/languages/language', 'type'); break; case 'script': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/scripts/script', 'type'); break; case 'territory': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/territories/territory', 'type'); if ($value === 1) { foreach($temp as $key => $value) { if ((is_numeric($key) === false) and ($key != 'QO') and ($key != 'QU')) { unset($temp[$key]); } } } else if ($value === 2) { foreach($temp as $key => $value) { if (is_numeric($key) or ($key == 'QO') or ($key == 'QU')) { unset($temp[$key]); } } } break; case 'variant': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/variants/variant', 'type'); break; case 'key': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/keys/key', 'type'); break; case 'type': if (empty($type)) { $temp = self::_getFile($locale, '/ldml/localeDisplayNames/types/type', 'type'); } else { if (($value == 'calendar') or ($value == 'collation') or ($value == 'currency')) { $temp = self::_getFile($locale, '/ldml/localeDisplayNames/types/type[@key=\'' . $value . '\']', 'type'); } else { $temp = self::_getFile($locale, '/ldml/localeDisplayNames/types/type[@type=\'' . $value . '\']', 'type'); } } break; case 'layout': $temp = self::_getFile($locale, '/ldml/layout/orientation', 'lines', 'lines'); $temp += self::_getFile($locale, '/ldml/layout/orientation', 'characters', 'characters'); $temp += self::_getFile($locale, '/ldml/layout/inList', '', 'inList'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'currency\']', '', 'currency'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'dayWidth\']', '', 'dayWidth'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'fields\']', '', 'fields'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'keys\']', '', 'keys'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'languages\']', '', 'languages'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'long\']', '', 'long'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'measurementSystemNames\']', '', 'measurementSystemNames'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'monthWidth\']', '', 'monthWidth'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'quarterWidth\']', '', 'quarterWidth'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'scripts\']', '', 'scripts'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'territories\']', '', 'territories'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'types\']', '', 'types'); $temp += self::_getFile($locale, '/ldml/layout/inText[@type=\'variants\']', '', 'variants'); break; case 'characters': $temp = self::_getFile($locale, '/ldml/characters/exemplarCharacters', '', 'characters'); $temp += self::_getFile($locale, '/ldml/characters/exemplarCharacters[@type=\'auxiliary\']', '', 'auxiliary'); $temp += self::_getFile($locale, '/ldml/characters/exemplarCharacters[@type=\'currencySymbol\']', '', 'currencySymbol'); break; case 'delimiters': $temp = self::_getFile($locale, '/ldml/delimiters/quotationStart', '', 'quoteStart'); $temp += self::_getFile($locale, '/ldml/delimiters/quotationEnd', '', 'quoteEnd'); $temp += self::_getFile($locale, '/ldml/delimiters/alternateQuotationStart', '', 'quoteStartAlt'); $temp += self::_getFile($locale, '/ldml/delimiters/alternateQuotationEnd', '', 'quoteEndAlt'); break; case 'measurement': $temp = self::_getFile('supplementalData', '/supplementalData/measurementData/measurementSystem[@type=\'metric\']', 'territories', 'metric'); $temp += self::_getFile('supplementalData', '/supplementalData/measurementData/measurementSystem[@type=\'US\']', 'territories', 'US'); $temp += self::_getFile('supplementalData', '/supplementalData/measurementData/paperSize[@type=\'A4\']', 'territories', 'A4'); $temp += self::_getFile('supplementalData', '/supplementalData/measurementData/paperSize[@type=\'US-Letter\']', 'territories', 'US-Letter'); break; case 'months': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/default', 'choice', 'context'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'format\']/default', 'choice', 'default'); $temp['format']['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'format\']/monthWidth[@type=\'abbreviated\']/month', 'type'); $temp['format']['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'format\']/monthWidth[@type=\'narrow\']/month', 'type'); $temp['format']['wide'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'format\']/monthWidth[@type=\'wide\']/month', 'type'); $temp['stand-alone']['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'stand-alone\']/monthWidth[@type=\'abbreviated\']/month', 'type'); $temp['stand-alone']['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'stand-alone\']/monthWidth[@type=\'narrow\']/month', 'type'); $temp['stand-alone']['wide'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'stand-alone\']/monthWidth[@type=\'wide\']/month', 'type'); break; case 'month': if (empty($value)) { $value = array("gregorian", "format", "wide"); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/months/monthContext[@type=\'' . $value[1] . '\']/monthWidth[@type=\'' . $value[2] . '\']/month', 'type'); break; case 'days': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/default', 'choice', 'context'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'format\']/default', 'choice', 'default'); $temp['format']['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'format\']/dayWidth[@type=\'abbreviated\']/day', 'type'); $temp['format']['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'format\']/dayWidth[@type=\'narrow\']/day', 'type'); $temp['format']['wide'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'format\']/dayWidth[@type=\'wide\']/day', 'type'); $temp['stand-alone']['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'stand-alone\']/dayWidth[@type=\'abbreviated\']/day', 'type'); $temp['stand-alone']['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'stand-alone\']/dayWidth[@type=\'narrow\']/day', 'type'); $temp['stand-alone']['wide'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'stand-alone\']/dayWidth[@type=\'wide\']/day', 'type'); break; case 'day': if (empty($value)) { $value = array("gregorian", "format", "wide"); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/days/dayContext[@type=\'' . $value[1] . '\']/dayWidth[@type=\'' . $value[2] . '\']/day', 'type'); break; case 'week': $minDays = self::_calendarDetail($locale, self::_getFile('supplementalData', '/supplementalData/weekData/minDays', 'territories')); $firstDay = self::_calendarDetail($locale, self::_getFile('supplementalData', '/supplementalData/weekData/firstDay', 'territories')); $weekStart = self::_calendarDetail($locale, self::_getFile('supplementalData', '/supplementalData/weekData/weekendStart', 'territories')); $weekEnd = self::_calendarDetail($locale, self::_getFile('supplementalData', '/supplementalData/weekData/weekendEnd', 'territories')); $temp = self::_getFile('supplementalData', "/supplementalData/weekData/minDays[@territories='" . $minDays . "']", 'count', 'minDays'); $temp += self::_getFile('supplementalData', "/supplementalData/weekData/firstDay[@territories='" . $firstDay . "']", 'day', 'firstDay'); $temp += self::_getFile('supplementalData', "/supplementalData/weekData/weekendStart[@territories='" . $weekStart . "']", 'day', 'weekendStart'); $temp += self::_getFile('supplementalData', "/supplementalData/weekData/weekendEnd[@territories='" . $weekEnd . "']", 'day', 'weekendEnd'); break; case 'quarters': if (empty($value)) { $value = "gregorian"; } $temp['format']['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/quarters/quarterContext[@type=\'format\']/quarterWidth[@type=\'abbreviated\']/quarter', 'type'); $temp['format']['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/quarters/quarterContext[@type=\'format\']/quarterWidth[@type=\'narrow\']/quarter', 'type'); $temp['format']['wide'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/quarters/quarterContext[@type=\'format\']/quarterWidth[@type=\'wide\']/quarter', 'type'); $temp['stand-alone']['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/quarters/quarterContext[@type=\'stand-alone\']/quarterWidth[@type=\'abbreviated\']/quarter', 'type'); $temp['stand-alone']['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/quarters/quarterContext[@type=\'stand-alone\']/quarterWidth[@type=\'narrow\']/quarter', 'type'); $temp['stand-alone']['wide'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/quarters/quarterContext[@type=\'stand-alone\']/quarterWidth[@type=\'wide\']/quarter', 'type'); break; case 'quarter': if (empty($value)) { $value = array("gregorian", "format", "wide"); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/quarters/quarterContext[@type=\'' . $value[1] . '\']/quarterWidth[@type=\'' . $value[2] . '\']/quarter', 'type'); break; case 'eras': if (empty($value)) { $value = "gregorian"; } $temp['names'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/eras/eraNames/era', 'type'); $temp['abbreviated'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/eras/eraAbbr/era', 'type'); $temp['narrow'] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/eras/eraNarrow/era', 'type'); break; case 'era': if (empty($value)) { $value = array("gregorian", "Abbr"); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/eras/era' . $value[1] . '/era', 'type'); break; case 'date': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'full\']/dateFormat/pattern', '', 'full'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'long\']/dateFormat/pattern', '', 'long'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'medium\']/dateFormat/pattern', '', 'medium'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'short\']/dateFormat/pattern', '', 'short'); break; case 'time': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'full\']/timeFormat/pattern', '', 'full'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'long\']/timeFormat/pattern', '', 'long'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'medium\']/timeFormat/pattern', '', 'medium'); $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'short\']/timeFormat/pattern', '', 'short'); break; case 'datetime': if (empty($value)) { $value = "gregorian"; } $timefull = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'full\']/timeFormat/pattern', '', 'full'); $timelong = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'long\']/timeFormat/pattern', '', 'long'); $timemedi = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'medium\']/timeFormat/pattern', '', 'medi'); $timeshor = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/timeFormatLength[@type=\'short\']/timeFormat/pattern', '', 'shor'); $datefull = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'full\']/dateFormat/pattern', '', 'full'); $datelong = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'long\']/dateFormat/pattern', '', 'long'); $datemedi = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'medium\']/dateFormat/pattern', '', 'medi'); $dateshor = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/dateFormatLength[@type=\'short\']/dateFormat/pattern', '', 'shor'); $full = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/dateTimeFormatLength[@type=\'full\']/dateTimeFormat/pattern', '', 'full'); $long = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/dateTimeFormatLength[@type=\'long\']/dateTimeFormat/pattern', '', 'long'); $medi = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/dateTimeFormatLength[@type=\'medium\']/dateTimeFormat/pattern', '', 'medi'); $shor = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/dateTimeFormatLength[@type=\'short\']/dateTimeFormat/pattern', '', 'shor'); $temp['full'] = str_replace(array('{0}', '{1}'), array($timefull['full'], $datefull['full']), $full['full']); $temp['long'] = str_replace(array('{0}', '{1}'), array($timelong['long'], $datelong['long']), $long['long']); $temp['medium'] = str_replace(array('{0}', '{1}'), array($timemedi['medi'], $datemedi['medi']), $medi['medi']); $temp['short'] = str_replace(array('{0}', '{1}'), array($timeshor['shor'], $dateshor['shor']), $shor['shor']); break; case 'dateitem': if (empty($value)) { $value = "gregorian"; } $_temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/availableFormats/dateFormatItem', 'id'); foreach($_temp as $key => $found) { $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/availableFormats/dateFormatItem[@id=\'' . $key . '\']', '', $key); } break; case 'dateinterval': if (empty($value)) { $value = "gregorian"; } $_temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/intervalFormats/intervalFormatItem', 'id'); foreach($_temp as $key => $found) { $temp[$key] = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateTimeFormats/intervalFormats/intervalFormatItem[@id=\'' . $key . '\']/greatestDifference', 'id'); } break; case 'field': if (empty($value)) { $value = "gregorian"; } $temp2 = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/fields/field', 'type'); foreach ($temp2 as $key => $keyvalue) { $temp += self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/fields/field[@type=\'' . $key . '\']/displayName', '', $key); } break; case 'relative': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/fields/field/relative', 'type'); break; case 'symbols': $temp = self::_getFile($locale, '/ldml/numbers/symbols/decimal', '', 'decimal'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/group', '', 'group'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/list', '', 'list'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/percentSign', '', 'percent'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/nativeZeroDigit', '', 'zero'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/patternDigit', '', 'pattern'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/plusSign', '', 'plus'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/minusSign', '', 'minus'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/exponential', '', 'exponent'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/perMille', '', 'mille'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/infinity', '', 'infinity'); $temp += self::_getFile($locale, '/ldml/numbers/symbols/nan', '', 'nan'); break; case 'nametocurrency': $_temp = self::_getFile($locale, '/ldml/numbers/currencies/currency', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $key . '\']/displayName', '', $key); } break; case 'currencytoname': $_temp = self::_getFile($locale, '/ldml/numbers/currencies/currency', 'type'); foreach ($_temp as $key => $keyvalue) { $val = self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $key . '\']/displayName', '', $key); if (!isset($val[$key])) { continue; } if (!isset($temp[$val[$key]])) { $temp[$val[$key]] = $key; } else { $temp[$val[$key]] .= " " . $key; } } break; case 'currencysymbol': $_temp = self::_getFile($locale, '/ldml/numbers/currencies/currency', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $key . '\']/symbol', '', $key); } break; case 'question': $temp = self::_getFile($locale, '/ldml/posix/messages/yesstr', '', 'yes'); $temp += self::_getFile($locale, '/ldml/posix/messages/nostr', '', 'no'); break; case 'currencyfraction': $_temp = self::_getFile('supplementalData', '/supplementalData/currencyData/fractions/info', 'iso4217'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/currencyData/fractions/info[@iso4217=\'' . $key . '\']', 'digits', $key); } break; case 'currencyrounding': $_temp = self::_getFile('supplementalData', '/supplementalData/currencyData/fractions/info', 'iso4217'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/currencyData/fractions/info[@iso4217=\'' . $key . '\']', 'rounding', $key); } break; case 'currencytoregion': $_temp = self::_getFile('supplementalData', '/supplementalData/currencyData/region', 'iso3166'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('supplementalData', '/supplementalData/currencyData/region[@iso3166=\'' . $key . '\']/currency', 'iso4217', $key); } break; case 'regiontocurrency': $_temp = self::_getFile('supplementalData', '/supplementalData/currencyData/region', 'iso3166'); foreach ($_temp as $key => $keyvalue) { $val = self::_getFile('supplementalData', '/supplementalData/currencyData/region[@iso3166=\'' . $key . '\']/currency', 'iso4217', $key); if (!isset($val[$key])) { continue; } if (!isset($temp[$val[$key]])) { $temp[$val[$key]] = $key; } else { $temp[$val[$key]] .= " " . $key; } } break; case 'regiontoterritory': $_temp = self::_getFile('supplementalData', '/supplementalData/territoryContainment/group', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/territoryContainment/group[@type=\'' . $key . '\']', 'contains', $key); } break; case 'territorytoregion': $_temp2 = self::_getFile('supplementalData', '/supplementalData/territoryContainment/group', 'type'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('supplementalData', '/supplementalData/territoryContainment/group[@type=\'' . $key . '\']', 'contains', $key); } foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'scripttolanguage': $_temp = self::_getFile('supplementalData', '/supplementalData/languageData/language', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $key . '\']', 'scripts', $key); if (empty($temp[$key])) { unset($temp[$key]); } } break; case 'languagetoscript': $_temp2 = self::_getFile('supplementalData', '/supplementalData/languageData/language', 'type'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $key . '\']', 'scripts', $key); } foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if (empty($found3)) { continue; } if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'territorytolanguage': $_temp = self::_getFile('supplementalData', '/supplementalData/languageData/language', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $key . '\']', 'territories', $key); if (empty($temp[$key])) { unset($temp[$key]); } } break; case 'languagetoterritory': $_temp2 = self::_getFile('supplementalData', '/supplementalData/languageData/language', 'type'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $key . '\']', 'territories', $key); } foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if (empty($found3)) { continue; } if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'timezonetowindows': $_temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/mapTimezones[@type=\'windows\']/mapZone', 'other'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/timezoneData/mapTimezones[@type=\'windows\']/mapZone[@other=\'' . $key . '\']', 'type', $key); } break; case 'windowstotimezone': $_temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/mapTimezones[@type=\'windows\']/mapZone', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/timezoneData/mapTimezones[@type=\'windows\']/mapZone[@type=\'' .$key . '\']', 'other', $key); } break; case 'territorytotimezone': $_temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/zoneFormatting/zoneItem', 'type'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/timezoneData/zoneFormatting/zoneItem[@type=\'' . $key . '\']', 'territory', $key); } break; case 'timezonetoterritory': $_temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/zoneFormatting/zoneItem', 'territory'); foreach ($_temp as $key => $found) { $temp += self::_getFile('supplementalData', '/supplementalData/timezoneData/zoneFormatting/zoneItem[@territory=\'' . $key . '\']', 'type', $key); } break; case 'citytotimezone': $_temp = self::_getFile($locale, '/ldml/dates/timeZoneNames/zone', 'type'); foreach($_temp as $key => $found) { $temp += self::_getFile($locale, '/ldml/dates/timeZoneNames/zone[@type=\'' . $key . '\']/exemplarCity', '', $key); } break; case 'timezonetocity': $_temp = self::_getFile($locale, '/ldml/dates/timeZoneNames/zone', 'type'); $temp = array(); foreach($_temp as $key => $found) { $temp += self::_getFile($locale, '/ldml/dates/timeZoneNames/zone[@type=\'' . $key . '\']/exemplarCity', '', $key); if (!empty($temp[$key])) { $temp[$temp[$key]] = $key; } unset($temp[$key]); } break; case 'phonetoterritory': $_temp = self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory', 'territory'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory[@territory=\'' . $key . '\']/telephoneCountryCode', 'code', $key); } break; case 'territorytophone': $_temp = self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory', 'territory'); foreach ($_temp as $key => $keyvalue) { $val = self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory[@territory=\'' . $key . '\']/telephoneCountryCode', 'code', $key); if (!isset($val[$key])) { continue; } if (!isset($temp[$val[$key]])) { $temp[$val[$key]] = $key; } else { $temp[$val[$key]] .= " " . $key; } } break; case 'numerictoterritory': $_temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes', 'type'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@type=\'' . $key . '\']', 'numeric', $key); } break; case 'territorytonumeric': $_temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes', 'numeric'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@numeric=\'' . $key . '\']', 'type', $key); } break; case 'alpha3toterritory': $_temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes', 'type'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@type=\'' . $key . '\']', 'alpha3', $key); } break; case 'territorytoalpha3': $_temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes', 'alpha3'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@alpha3=\'' . $key . '\']', 'type', $key); } break; case 'postaltoterritory': $_temp = self::_getFile('postalCodeData', '/supplementalData/postalCodeData/postCodeRegex', 'territoryId'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('postalCodeData', '/supplementalData/postalCodeData/postCodeRegex[@territoryId=\'' . $key . '\']', 'territoryId'); } break; case 'numberingsystem': $_temp = self::_getFile('numberingSystems', '/supplementalData/numberingSystems/numberingSystem', 'id'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('numberingSystems', '/supplementalData/numberingSystems/numberingSystem[@id=\'' . $key . '\']', 'digits', $key); if (empty($temp[$key])) { unset($temp[$key]); } } break; case 'chartofallback': $_temp = self::_getFile('characters', '/supplementalData/characters/character-fallback/character', 'value'); foreach ($_temp as $key => $keyvalue) { $temp2 = self::_getFile('characters', '/supplementalData/characters/character-fallback/character[@value=\'' . $key . '\']/substitute', '', $key); $temp[current($temp2)] = $key; } break; case 'fallbacktochar': $_temp = self::_getFile('characters', '/supplementalData/characters/character-fallback/character', 'value'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('characters', '/supplementalData/characters/character-fallback/character[@value=\'' . $key . '\']/substitute', '', $key); } break; case 'localeupgrade': $_temp = self::_getFile('likelySubtags', '/supplementalData/likelySubtags/likelySubtag', 'from'); foreach ($_temp as $key => $keyvalue) { $temp += self::_getFile('likelySubtags', '/supplementalData/likelySubtags/likelySubtag[@from=\'' . $key . '\']', 'to', $key); } break; case 'unit': $_temp = self::_getFile($locale, '/ldml/units/unit', 'type'); foreach($_temp as $key => $keyvalue) { $_temp2 = self::_getFile($locale, '/ldml/units/unit[@type=\'' . $key . '\']/unitPattern', 'count'); $temp[$key] = $_temp2; } break; default : throw new Zend_Locale_Exception("Unknown list ($path) for parsing locale data."); break; } if (isset(self::$_cache)) { if (self::$_cacheTags) { self::$_cache->save( serialize($temp), $id, array('Zend_Locale')); } else { self::$_cache->save( serialize($temp), $id); } } return $temp; } public static function getContent($locale, $path, $value = false) { $locale = self::_checkLocale($locale); if (!isset(self::$_cache) && !self::$_cacheDisabled) { self::$_cache = Zend_Cache::factory( 'Core', 'File', array('automatic_serialization' => true), array()); } $val = $value; if (is_array($value)) { $val = implode('_' , $value); } $val = urlencode($val); $id = strtr('Zend_LocaleC_' . $locale . '_' . $path . '_' . $val, array('-' => '_', '%' => '_', '+' => '_')); if (!self::$_cacheDisabled && ($result = self::$_cache->load($id))) { return unserialize($result); } switch(strtolower($path)) { case 'language': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/languages/language[@type=\'' . $value . '\']', 'type'); break; case 'script': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/scripts/script[@type=\'' . $value . '\']', 'type'); break; case 'country': case 'territory': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/territories/territory[@type=\'' . $value . '\']', 'type'); break; case 'variant': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/variants/variant[@type=\'' . $value . '\']', 'type'); break; case 'key': $temp = self::_getFile($locale, '/ldml/localeDisplayNames/keys/key[@type=\'' . $value . '\']', 'type'); break; case 'defaultcalendar': $temp = self::_getFile($locale, '/ldml/dates/calendars/default', 'choice', 'default'); break; case 'monthcontext': if (empty ($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/default', 'choice', 'context'); break; case 'defaultmonth': if (empty ($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/months/monthContext[@type=\'format\']/default', 'choice', 'default'); break; case 'month': if (!is_array($value)) { $temp = $value; $value = array("gregorian", "format", "wide", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/months/monthContext[@type=\'' . $value[1] . '\']/monthWidth[@type=\'' . $value[2] . '\']/month[@type=\'' . $value[3] . '\']', 'type'); break; case 'daycontext': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/default', 'choice', 'context'); break; case 'defaultday': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/days/dayContext[@type=\'format\']/default', 'choice', 'default'); break; case 'day': if (!is_array($value)) { $temp = $value; $value = array("gregorian", "format", "wide", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/days/dayContext[@type=\'' . $value[1] . '\']/dayWidth[@type=\'' . $value[2] . '\']/day[@type=\'' . $value[3] . '\']', 'type'); break; case 'quarter': if (!is_array($value)) { $temp = $value; $value = array("gregorian", "format", "wide", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/quarters/quarterContext[@type=\'' . $value[1] . '\']/quarterWidth[@type=\'' . $value[2] . '\']/quarter[@type=\'' . $value[3] . '\']', 'type'); break; case 'am': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/am', '', 'am'); break; case 'pm': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/pm', '', 'pm'); break; case 'era': if (!is_array($value)) { $temp = $value; $value = array("gregorian", "Abbr", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/eras/era' . $value[1] . '/era[@type=\'' . $value[2] . '\']', 'type'); break; case 'defaultdate': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/dateFormats/default', 'choice', 'default'); break; case 'date': if (empty($value)) { $value = array("gregorian", "medium"); } if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/dateFormats/dateFormatLength[@type=\'' . $value[1] . '\']/dateFormat/pattern', '', 'pattern'); break; case 'defaulttime': if (empty($value)) { $value = "gregorian"; } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value . '\']/timeFormats/default', 'choice', 'default'); break; case 'time': if (empty($value)) { $value = array("gregorian", "medium"); } if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/timeFormats/timeFormatLength[@type=\'' . $value[1] . '\']/timeFormat/pattern', '', 'pattern'); break; case 'datetime': if (empty($value)) { $value = array("gregorian", "medium"); } if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp); } $date = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/dateFormats/dateFormatLength[@type=\'' . $value[1] . '\']/dateFormat/pattern', '', 'pattern'); $time = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/timeFormats/timeFormatLength[@type=\'' . $value[1] . '\']/timeFormat/pattern', '', 'pattern'); $datetime = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/dateTimeFormats/dateTimeFormatLength[@type=\'' . $value[1] . '\']/dateTimeFormat/pattern', '', 'pattern'); $temp = str_replace(array('{0}', '{1}'), array(current($time), current($date)), current($datetime)); break; case 'dateitem': if (empty($value)) { $value = array("gregorian", "yyMMdd"); } if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/dateTimeFormats/availableFormats/dateFormatItem[@id=\'' . $value[1] . '\']', ''); break; case 'dateinterval': if (empty($value)) { $value = array("gregorian", "yMd", "y"); } if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp, $temp[0]); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/dateTimeFormats/intervalFormats/intervalFormatItem[@id=\'' . $value[1] . '\']/greatestDifference[@id=\'' . $value[2] . '\']', ''); break; case 'field': if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/fields/field[@type=\'' . $value[1] . '\']/displayName', '', $value[1]); break; case 'relative': if (!is_array($value)) { $temp = $value; $value = array("gregorian", $temp); } $temp = self::_getFile($locale, '/ldml/dates/calendars/calendar[@type=\'' . $value[0] . '\']/fields/field/relative[@type=\'' . $value[1] . '\']', '', $value[1]); break; case 'defaultnumberingsystem': $temp = self::_getFile($locale, '/ldml/numbers/defaultNumberingSystem', '', 'default'); break; case 'decimalnumber': $temp = self::_getFile($locale, '/ldml/numbers/decimalFormats/decimalFormatLength/decimalFormat/pattern', '', 'default'); break; case 'scientificnumber': $temp = self::_getFile($locale, '/ldml/numbers/scientificFormats/scientificFormatLength/scientificFormat/pattern', '', 'default'); break; case 'percentnumber': $temp = self::_getFile($locale, '/ldml/numbers/percentFormats/percentFormatLength/percentFormat/pattern', '', 'default'); break; case 'currencynumber': $temp = self::_getFile($locale, '/ldml/numbers/currencyFormats/currencyFormatLength/currencyFormat/pattern', '', 'default'); break; case 'nametocurrency': $temp = self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $value . '\']/displayName', '', $value); break; case 'currencytoname': $temp = self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $value . '\']/displayName', '', $value); $_temp = self::_getFile($locale, '/ldml/numbers/currencies/currency', 'type'); $temp = array(); foreach ($_temp as $key => $keyvalue) { $val = self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $key . '\']/displayName', '', $key); if (!isset($val[$key]) or ($val[$key] != $value)) { continue; } if (!isset($temp[$val[$key]])) { $temp[$val[$key]] = $key; } else { $temp[$val[$key]] .= " " . $key; } } break; case 'currencysymbol': $temp = self::_getFile($locale, '/ldml/numbers/currencies/currency[@type=\'' . $value . '\']/symbol', '', $value); break; case 'question': $temp = self::_getFile($locale, '/ldml/posix/messages/' . $value . 'str', '', $value); break; case 'currencyfraction': if (empty($value)) { $value = "DEFAULT"; } $temp = self::_getFile('supplementalData', '/supplementalData/currencyData/fractions/info[@iso4217=\'' . $value . '\']', 'digits', 'digits'); break; case 'currencyrounding': if (empty($value)) { $value = "DEFAULT"; } $temp = self::_getFile('supplementalData', '/supplementalData/currencyData/fractions/info[@iso4217=\'' . $value . '\']', 'rounding', 'rounding'); break; case 'currencytoregion': $temp = self::_getFile('supplementalData', '/supplementalData/currencyData/region[@iso3166=\'' . $value . '\']/currency', 'iso4217', $value); break; case 'regiontocurrency': $_temp = self::_getFile('supplementalData', '/supplementalData/currencyData/region', 'iso3166'); $temp = array(); foreach ($_temp as $key => $keyvalue) { $val = self::_getFile('supplementalData', '/supplementalData/currencyData/region[@iso3166=\'' . $key . '\']/currency', 'iso4217', $key); if (!isset($val[$key]) or ($val[$key] != $value)) { continue; } if (!isset($temp[$val[$key]])) { $temp[$val[$key]] = $key; } else { $temp[$val[$key]] .= " " . $key; } } break; case 'regiontoterritory': $temp = self::_getFile('supplementalData', '/supplementalData/territoryContainment/group[@type=\'' . $value . '\']', 'contains', $value); break; case 'territorytoregion': $_temp2 = self::_getFile('supplementalData', '/supplementalData/territoryContainment/group', 'type'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('supplementalData', '/supplementalData/territoryContainment/group[@type=\'' . $key . '\']', 'contains', $key); } $temp = array(); foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if ($found3 !== $value) { continue; } if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'scripttolanguage': $temp = self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $value . '\']', 'scripts', $value); break; case 'languagetoscript': $_temp2 = self::_getFile('supplementalData', '/supplementalData/languageData/language', 'type'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $key . '\']', 'scripts', $key); } $temp = array(); foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if ($found3 !== $value) { continue; } if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'territorytolanguage': $temp = self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $value . '\']', 'territories', $value); break; case 'languagetoterritory': $_temp2 = self::_getFile('supplementalData', '/supplementalData/languageData/language', 'type'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('supplementalData', '/supplementalData/languageData/language[@type=\'' . $key . '\']', 'territories', $key); } $temp = array(); foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if ($found3 !== $value) { continue; } if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'timezonetowindows': $temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/mapTimezones[@type=\'windows\']/mapZone[@other=\''.$value.'\']', 'type', $value); break; case 'windowstotimezone': $temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/mapTimezones[@type=\'windows\']/mapZone[@type=\''.$value.'\']', 'other', $value); break; case 'territorytotimezone': $temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/zoneFormatting/zoneItem[@type=\'' . $value . '\']', 'territory', $value); break; case 'timezonetoterritory': $temp = self::_getFile('supplementalData', '/supplementalData/timezoneData/zoneFormatting/zoneItem[@territory=\'' . $value . '\']', 'type', $value); break; case 'citytotimezone': $temp = self::_getFile($locale, '/ldml/dates/timeZoneNames/zone[@type=\'' . $value . '\']/exemplarCity', '', $value); break; case 'timezonetocity': $_temp = self::_getFile($locale, '/ldml/dates/timeZoneNames/zone', 'type'); $temp = array(); foreach($_temp as $key => $found) { $temp += self::_getFile($locale, '/ldml/dates/timeZoneNames/zone[@type=\'' . $key . '\']/exemplarCity', '', $key); if (!empty($temp[$key])) { if ($temp[$key] == $value) { $temp[$temp[$key]] = $key; } } unset($temp[$key]); } break; case 'phonetoterritory': $temp = self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory[@territory=\'' . $value . '\']/telephoneCountryCode', 'code', $value); break; case 'territorytophone': $_temp2 = self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory', 'territory'); $_temp = array(); foreach ($_temp2 as $key => $found) { $_temp += self::_getFile('telephoneCodeData', '/supplementalData/telephoneCodeData/codesByTerritory[@territory=\'' . $key . '\']/telephoneCountryCode', 'code', $key); } $temp = array(); foreach($_temp as $key => $found) { $_temp3 = explode(" ", $found); foreach($_temp3 as $found3) { if ($found3 !== $value) { continue; } if (!isset($temp[$found3])) { $temp[$found3] = (string) $key; } else { $temp[$found3] .= " " . $key; } } } break; case 'numerictoterritory': $temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@type=\''.$value.'\']', 'numeric', $value); break; case 'territorytonumeric': $temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@numeric=\''.$value.'\']', 'type', $value); break; case 'alpha3toterritory': $temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@type=\''.$value.'\']', 'alpha3', $value); break; case 'territorytoalpha3': $temp = self::_getFile('supplementalData', '/supplementalData/codeMappings/territoryCodes[@alpha3=\''.$value.'\']', 'type', $value); break; case 'postaltoterritory': $temp = self::_getFile('postalCodeData', '/supplementalData/postalCodeData/postCodeRegex[@territoryId=\'' . $value . '\']', 'territoryId'); break; case 'numberingsystem': $temp = self::_getFile('numberingSystems', '/supplementalData/numberingSystems/numberingSystem[@id=\'' . strtolower($value) . '\']', 'digits', $value); break; case 'chartofallback': $_temp = self::_getFile('characters', '/supplementalData/characters/character-fallback/character', 'value'); foreach ($_temp as $key => $keyvalue) { $temp2 = self::_getFile('characters', '/supplementalData/characters/character-fallback/character[@value=\'' . $key . '\']/substitute', '', $key); if (current($temp2) == $value) { $temp = $key; } } break; $temp = self::_getFile('characters', '/supplementalData/characters/character-fallback/character[@value=\'' . $value . '\']/substitute', '', $value); break; case 'fallbacktochar': $temp = self::_getFile('characters', '/supplementalData/characters/character-fallback/character[@value=\'' . $value . '\']/substitute', ''); break; case 'localeupgrade': $temp = self::_getFile('likelySubtags', '/supplementalData/likelySubtags/likelySubtag[@from=\'' . $value . '\']', 'to', $value); break; case 'unit': $temp = self::_getFile($locale, '/ldml/units/unit[@type=\'' . $value[0] . '\']/unitPattern[@count=\'' . $value[1] . '\']', ''); break; default : throw new Zend_Locale_Exception("Unknown detail ($path) for parsing locale data."); break; } if (is_array($temp)) { $temp = current($temp); } if (isset(self::$_cache)) { if (self::$_cacheTags) { self::$_cache->save( serialize($temp), $id, array('Zend_Locale')); } else { self::$_cache->save( serialize($temp), $id); } } return $temp; } public static function getCache() { return self::$_cache; } public static function setCache(Zend_Cache_Core $cache) { self::$_cache = $cache; self::_getTagSupportForCache(); } public static function hasCache() { if (self::$_cache !== null) { return true; } return false; } public static function removeCache() { self::$_cache = null; } public static function clearCache() { if (self::$_cacheTags) { self::$_cache->clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array('Zend_Locale')); } else { self::$_cache->clean(Zend_Cache::CLEANING_MODE_ALL); } } public static function disableCache($flag) { self::$_cacheDisabled = (boolean) $flag; } private static function _getTagSupportForCache() { $backend = self::$_cache->getBackend(); if ($backend instanceof Zend_Cache_Backend_ExtendedInterface) { $cacheOptions = $backend->getCapabilities(); self::$_cacheTags = $cacheOptions['tags']; } else { self::$_cacheTags = false; } return self::$_cacheTags; } } 

class Zend_Mail_Transport_Exception extends Zend_Mail_Exception {} 

